#+TITLE: PELVis: The PEL Visualizer
#+AUTHOR: Adam Washington
#+OPTIONS: toc:4

* Introduction

  This docment is a [[http://www.literateprogramming.com/index.html][literate]] program for analyzing data collected on
  the SESAME beamline. The document itself was written in
  [[http://orgmode.org/][Org Mode]] while the majority of the source is intended to be run
  through python.

  If your primary goal is to simply use PELVis, then the
  [[file:readme.org][user documentation]] would be the best place to start.

* PELVis application

  The main user application is the pelvis.py script that the user runs
  to view neutron data.

** Application skeleton

   Below is the rough layout of the PELVis application.  More details can be found in the individual sections

#+begin_src python :tangle pelvis.py :noweb tangle :padline no
  """A GUI for handling polarization data generated by a PAPA detector.
  
  This program was written to help with analyzing polarization data produced
  by the PAPA detector.  The general workflow is:
  1)Load Neutron Data
  2)Subtract Background
  3)Select Region of Interest
  4)Plot Spectrum data
  
  The primary class is PelvisFrame, which controls the whole program.
  PelvisFrame contains a PositionPanel, to examine single pixels, and
  a PelvisOptionPanel, which accepts user parameters.
  
  """
  
  <<pelvis_imports>>
  
  RESOLUTION = 400

  <<position_panel>>
  <<pelvis_option_panel>>
  <<pelvis_frame>>
  if __name__=="__main__":
      app=wx.PySimpleApp()
      pelvisframe = PelvisFrame(app.Yield)
      app.MainLoop()
  
#+end_src
** Imports

   The PELVis application uses a large number of packages to handle
   the work. 


   This code was originally written for Python 2.5.  This version of
   Python did not have the =with= statement and needed it imported
   from the future.  If PELVis is run on version 2.6 or later, this
   should not be an issue.  As such, it should be possible to remove
   this import, but it has not been tested.
#+name:pelvis_imports
#+begin_src python
  import __future__
#+end_src

   The [[Reader][PelFile]] class handles all of the data loading from the neutron
   event files.

#+name:pelvis_imports
#+begin_src python
  
  from reader import PelFile
#+end_src

   [[Image Panel][ImagePanel]] is a custom widget for displaying 2D graph data in a
   wxPython frame.

#+name:pelvis_imports
#+begin_src python
  from ImagePanel import ImagePanel
#+end_src

   [[GraphPanel][GraphPanel]] is a custom widget for displayed 1D graphs in a wxPython
   Frame.

#+name:pelvis_imports
#+begin_src python
  from GraphPanel import GraphPanel
#+end_src

   The [[ColorBarPanel]] is a custom widget for displaying a legended
   color bar for 2D color maps.  The [[ColorMapPicker]] is a custom dialog
   for chosing a color bar.

#+name:pelvis_imports
#+begin_src python
  from colorbarpanel import ColorBarPanel, ColorMapPicker
#+end_src

   The [[MonFile]] class handles reading the SNS monitor count files.

#+name:pelvis_imports
#+begin_src python
  from monfile import MonFile
#+end_src

   [[SpectrumDialog]] is a custom dialog which handles viewing and
   exporting 1D spectral data from the Pelvis application.

#+name:pelvis_imports
#+begin_src python
  from SpectrumDialog import SpectrumDialog
#+end_src

   The Python built-in TemporaryFile class is used to cache Flat
   Files, since they can use a large amount of memory.  If the Flat
   File functionality is removed, this import can be dropped.

#+name:pelvis_imports
#+begin_src python
  
  from tempfile import TemporaryFile
#+end_src

   =math= is not used, as it has been essentially superseded by
   numpy.  This import should be dropped.

#+name:pelvis_imports
#+begin_src python
  
  import math
#+end_src

   =time= is used for sleeping in a couple of functions.  This is
   almost never truly necessary and probably should be dropped.

#+name:pelvis_imports
#+begin_src python
  import time
#+end_src

   [[http://docs.numpy.org][=numpy=]] is a Python library for handling multidimensional arrays.
   It is many orders of magnitude faster and smaller than using Python
   Lists, plus easier to read, once you're used to it.  By local
   convention, =numpy= is always imported as =np=, just because it's
   called so often.

#+name:pelvis_imports
#+begin_src python
  
  import numpy as np
#+end_src

   [[http://matplotlib.org][=matplotlib=]] is a plotting library for python.  It handles all of
   the plots within the application.

#+name:pelvis_imports
#+begin_src python
  from matplotlib import pyplot as plt
#+end_src

   The =cm= submodule of matplotlib handles color maps and is needed for
   controlling the display of the 2D detector data.

#+name:pelvis_imports
#+begin_src python
  import matplotlib.cm as cm
#+end_src

   [[http://www.wxpython.org][wx]] is the GUI toolkit used to make the user interface for PelVis

#+name:pelvis_imports
#+begin_src python
  
  import wx
#+end_src


* GUI Controls

  We're using [[https://www.wxwidgets.org/][wxWidgets]] as our GUI toolkit through the [[http://www.wxpython.org][wxPython]]
  binding library.  wxWidgets was chosen as it is cross platform and
  provided a more complete toolkit than the default Tk toolkit that
  comes with Python.  The largest disadvantage to this decision is
  that wxPython has not yet been officially ported to Python 3.

** Pelvis Frame

    The Pelvis Frame is the main UI for the application.
    Unfortunately, it also contains a large amount of application
    logic, which should be extracted out into its own class.  That
    would certainly make working on the Reduction programs easier.
    If you're looking for a good improvement to make to the code.
    This would be it.

    The class starts off with a large number of constant definitions.
    These constants are identifiers for menu commands, which are
    needed for the wxWidget menu system.

#+name:pelvis_frame
#+begin_src python
  class PelvisFrame(wx.Frame):
      """The main application window for PELvis"""
  
      #Menu ID constants
      ID_OPEN = 100
      ID_OPENTWO = 110
      ID_SAVE = 130
      ID_SPECTRUM=140
      ID_IMAGE_ARRAY=160
      ID_EXIT = 190
  
      ID_GREY = 200
      ID_HUEVAL = 220
      ID_SPECTRAL = 230
      ID_PICKER = 290
      ID_POLAR = 300
      ID_FLIPPING = 310
      ID_SPIN_UP = 320
      ID_SPIN_DOWN = 330
  
      ID_FLAT = 420
      ID_FAKEFLAT = 430
      ID_ROD = 440
      ID_EXPORT_ROI = 450
      ID_IMPORT_ROI = 460
  
      ID_COPY = 500
  
      def __init__(self,Yield):
          <<pelvis_frame_init>>
  
      <<pelvis_handle_pels>>
  
      <<pelvis_on_image_array>>
  
      <<pelvis_load_norm_pel>>
                  
  #    def getLambdaRange(self):
  #        try:
  #            lmin = int(float(self.lambdaMin.GetValue())*10)
  #        except ValueError:
  #            lmin = 0
  #        try:
  #            lmax = int(float(self.lambdaMax.GetValue())*10)
  #        except ValueError:
  #            lmax = 200 
  #        return (lmin,lmax)
  
      <<pelvis_updaters>>
  
      <<pelvis_on_update_button>>
  
      <<pelvis_on_open>>
  
      <<pelvis_on_open_set>>
  
      <<pelvis_flat_files>>
  
      <<pelvis_menu_commands>>  
      def setColorMap(self,cmap):
          """Changes to the given colormap"""
          self.imPanel.cmap = cmap
          self.colorbar.setCmap(cmap)
          self.update()
  
  
      <<pelvis_on_exit>>
      <<pelvis_load_up_and_down>>
  
      <<pelvis_menu_commands_2>>
                  
  
  
  
#+end_src

*** Initialization

     The frame is created with a single parameter: =Yield=.  This points
     to a function which allows Pelvis to temporarily return control
     back to the GUI.  This is necessary to amintain responsiveness
     of the user interface while performing long calculations
     (e.g. loading a file).

     We start by creating a wxFrame.  We also set the initial data to
     an empty file, store the =Yield= command, and create a default
     data mask that accepts all pixels.

#+name:pelvis_frame_init
#+begin_src python
          """Create a PELvis frame
  
          Keyword arguments:
          Yield -- A function to give control back to the main event loop
  
          """
          wx.Frame.__init__(self,None,wx.ID_ANY,"PEL Visualizer")
          self.data = PelFile()
          self.Yield = Yield
          self.mask = np.ones((128,16),dtype=np.bool)
#+end_src


     Now we can create the actual components of the GUI.  The =xPanel=
     and =yPanel= are [[Graph Panel][graphs]] which display the integrated intensity
     along an axis.  =imPanel= displays the actual, 2D detector [[ImagePanel][image]].
     =colorbar= gives the current scale of the color scheme on the
     imPanel.  =opPanel= is a generic [[Option Panel][panel]] for the user to input data
     about the current region of interest.  =posPanel= displays
     position information to the user.  =cmp= stores the current color
     map for use on the =imPanel=. =specDlg= is a [[SpectrumDialog][dialog box]]
     which handles displaying and saving wavelength spectrums.
     Finally, =imageSaveDialog= is a custom file saving dialog for
     handling saving the current detector image to a file.

#+name:pelvis_frame_init
#+begin_src python  
          #Create items in the frame
          self.yPanel = GraphPanel(self,(2,8),64,GraphPanel.VERTICAL)
          self.xPanel = GraphPanel(self,(8,2),64,GraphPanel.INVERTED)
          self.colorbar = ColorBarPanel(self,cm.jet)
          self.opPanel = PelvisOptionPanel(self)
          self.posPanel = PositionPanel(self)
          self.imPanel = ImagePanel(self,self.posPanel.set,
                                    self.opPanel.setPosMin,self.opPanel.setPosMax)
          self.specDlg = SpectrumDialog(self)
  
          self.cmp = None #color map
          self.imageSaveDialog=wx.FileDialog(self,"Choose graphics file",wildcard="Portable Network Graphic (png)|*.PNG|Windows Bitmap (bmp)|*.BMP|Joint Photographic Experts Group (jpg)|*.JPG|Portable Network Monocrome (pnm)|*.PNM|Tagged Image File Format (tif)|*.TIF|Archaic, useless format (pcx)|*.PCX",style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
#+end_src

     The Pelvis Frame class has two dynamic member functions.  The
     first is =update=, which is responsible for setting the image in
     the image panel.  The function assumes that the 3D array of data
     that has been displayed hasn't changed, but that some of the
     parameters for the display (e.g. wavelength range, intensity
     caps) may have changed.  The other member function, =updateData=,
     is used whenever the underlying 3D array may have changed.

#+name:pelvis_frame_init
#+begin_src python  
  
          self.update = self.updateSingle#update the image
          self.updateData = self.updateSingleData#update the data in the image
#+end_src

     Below is the creation and layout of the menu for the PELVis
     application.  To add an entry to a menu, we need to append both a
     message code (e.g. =ID_EXIT=) and a title.  If the title contains
     a tab character, a hotkey can follow that tab character to allow
     for a more keyboard oriented interaction with the program.
     Additionally, if there is an ampersand in front of a character,
     then that character will serve as the hotkey for that command
     when accessing the menu through the keyboard.  The =Append=
     function will also accept tooltext for the menu, but the current
     version of wxpython seems to be ignoring it.

#+name:pelvis_frame_init
#+begin_src python  
  
          #Create the menu
          menubar = wx.MenuBar()
          filemenu = wx.Menu()
          editmenu = wx.Menu()
          scalemenu = wx.Menu()
          analysismenu = wx.Menu()
          noisemenu = wx.Menu()
  
          #populate the menu
          filemenu.Append(self.ID_OPEN,"&Open\tCtrl-O"," Open a PEL file")
          filemenu.Append(self.ID_OPENTWO,"&Polarized Set"," Open two PEL files")
          filemenu.Append(self.ID_SAVE,"&Save\tCtrl-S"," Save an image file")
          filemenu.Append(self.ID_SPECTRUM,"Spectrum"," View the TOF spectrum")
          filemenu.Append(self.ID_IMAGE_ARRAY,"&Export Images..."," Save a series of TOF snapshots")
          filemenu.Append(self.ID_EXIT,"&Quit\tCtrl-Q"," Quit")
  
          editmenu.Append(self.ID_COPY,"&Copy\tCtrl-c","Copy the current image to the clipboard")
  
          scalemenu.Append(self.ID_GREY,"Greyscale\tCtrl-G","Monochrome images")
          scalemenu.Append(self.ID_HUEVAL,"Hue and Value\tCtrl-H","Scaled Rainbow Images")
          scalemenu.Append(self.ID_SPECTRAL,"spectral","Uses spectrum of light")
          scalemenu.Append(self.ID_PICKER,"Map Picker..."," Select from the full list of colormaps")
  
          analysismenu.Append(self.ID_POLAR,"Check Polarization\tCtrl-P","2d plot of polarization data")
          analysismenu.Append(self.ID_FLIPPING,"Check Flipping Ratio\tCtrl-F","2d plot of  spin up over spin down")
          analysismenu.Append(self.ID_SPIN_UP,"View Spin Up State\tCtrl-U","2d plot of  spin up")
          analysismenu.Append(self.ID_SPIN_DOWN,"View Spin Down State\tCtrl-D","2d plot of  spin down")
  
          noisemenu.Append(self.ID_FLAT,"&Load Flat"," Load a blank run for background subtraction")
          noisemenu.Append(self.ID_FAKEFLAT,"Si&mulate Flat"," Drop out background within the same image")
          noisemenu.Append(self.ID_ROD,"Region of &Disinterest"," Drop out background within the same image")
          noisemenu.Append(self.ID_EXPORT_ROI,"Export ROI"," Export a binary file corresponding to where the data is above the minimum intensity.")
          noisemenu.Append(self.ID_IMPORT_ROI,"Import ROI"," Add another exclusion mask.")
#+end_src

     Each menu item needs to be bound to a function.  This is
     performed by connecting the menu signal (e.g. =ID_EXIT=) to the
     corresponding function (e.g. =OnExit=).  There's probably a
     better way of doing this through some config file, but that will
     be left as an exercise to the reader.

#+name:pelvis_frame_init
#+begin_src python  
  
  
          #Bind events to the menu
          self.Connect(self.ID_EXIT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnExit)
          self.Connect(self.ID_OPEN,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnOpen)
          self.Connect(self.ID_OPENTWO,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnOpenSet)
          self.Connect(self.ID_SAVE,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSave)
          self.Connect(self.ID_SPECTRUM,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSpectrum)
          self.Connect(self.ID_IMAGE_ARRAY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnImageArray)
          self.Connect(self.ID_GREY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnGrey)
          self.Connect(self.ID_HUEVAL,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnHueVal)
          self.Connect(self.ID_SPECTRAL,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSpectral)
          self.Connect(self.ID_PICKER,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnPicker)
          self.Connect(self.ID_POLAR,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnPolar)
          self.Connect(self.ID_FLIPPING,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFlipping)
          self.Connect(self.ID_SPIN_UP,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnAnalysisSpinUp)
          self.Connect(self.ID_SPIN_DOWN,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnAnalysisSpinDown)
  
          self.Connect(self.ID_FLAT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFlat)
          self.Connect(self.ID_FAKEFLAT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFakeFlat)
          self.Connect(self.ID_ROD,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnROD)
          self.Connect(self.ID_EXPORT_ROI,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnExportROI)
          self.Connect(self.ID_IMPORT_ROI,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnImportROI)
          self.Connect(self.ID_COPY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnCopy)
#+end_src

     We can now add the menus into the menubar and assign that menubar
     to the application.  Adding an ampersand into the title of a
     menu assigns an Alt hotkey to that menu (e.g. pressing Alt+F
     will open the =&File= menu).

#+name:pelvis_frame_init
#+begin_src python  

  
          menubar.Append(filemenu,"&File")
          menubar.Append(editmenu,"&Edit")
          menubar.Append(scalemenu,"&Color")
          menubar.Append(analysismenu,"&Analysis")
          menubar.Append(noisemenu,"&Noise")
          self.SetMenuBar(menubar)
#+end_src

     We can now add all of the GUI components to the window.  A
     progress bar is added to the bottom of the window to give
     feedback on the loading of files.

#+name:pelvis_frame_init
#+begin_src python  
  
          #arrange window
          sizer = wx.GridBagSizer()
          sizer.Add(self.colorbar,pos=wx.GBPosition(0,9),span=wx.GBSpan(9,1))
          sizer.Add(self.imPanel,pos=wx.GBPosition(0,1),span=wx.GBSpan(8,8))
          sizer.Add(self.yPanel,pos=wx.GBPosition(0,0),span=wx.GBSpan(8,1))
          sizer.Add(self.xPanel,pos=wx.GBPosition(8,1),span=wx.GBSpan(1,8))
          sizer.Add(self.opPanel,pos=wx.GBPosition(0,10),span=wx.GBSpan(8,1),flag=wx.EXPAND)
          sizer.Add(self.posPanel,pos=wx.GBPosition(8,0),flag=wx.EXPAND)
          self.progress = wx.Gauge(self,range=1000)
          sizer.Add(self.progress,pos=wx.GBPosition(9,0),span=wx.GBSpan(1,11),flag=wx.EXPAND)
#+end_src

     A button to force the image display to update is added and bound
     to the [[pelvis_on_update_button_link][OnUpdateButton]] function.

#+name:pelvis_frame_init
#+begin_src python  
  
          updateButton = wx.Button(self,-1,"Update")
          updateButton.Bind(wx.EVT_BUTTON,self.OnUpdateButton)
          sizer.Add(updateButton,flag=wx.EXPAND,pos=wx.GBPosition(8,10))
#+end_src

     All that remains is some final cleanup.  The data is set to an
     empty file, the background is set to empty, as the window
     undergoes stanard intialization.

#+name:pelvis_frame_init
#+begin_src python  
  
          self.data = self.makePel()
          self.flatrun = None#background data
          
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Show(True)
#+end_src

     


*** Handling Pel Files

     There's a large amount of references to Pel files in this
     section, which might be confusing, since you will almost never
     encounter an actual Pel file.  The PELVis program was originally
     written to view neutron data comes of off the PAPA detector.  The
     data off of the PAPA was saved in a binary format called the PAPA
     Electronic Log, or PEL for short.  

     The software which came with the detector was written in
     Labview 5.  [[http://ni.com/labview][Labview]] files are stored in a proprietary format
     which can only be read by Labview itself.  Modern versions of
     Labview are not backwards compatible enough to read Labview 5
     code.  Versions of Labview old enough to read the code are
     generally unavailable and difficult to install on modern
     operating systems.  Thus, while the vendor's supplied code could
     open the files, we could not extended it to perform the sorts of
     calulcations that we would like.  Thus, it was necessary to write
     a new program from scratch to read these files.  This is that
     application.

     Once we obtained the Helium-3 detector, we replaced the PAPA
     detector, as the PAPA had terrible noise issues.  However, PELVis
     had grown to the point where the reading of the data file was
     only a small part of the functionality.  By changing the [[reader]]
     code to handle the SNS file format (which was quite similar to
     the Pel format), we were able to continue using the same suite.

     The =makePel= function creates a blank neutron run.  It's just a
     default for when the user hasn't loaded any data yet.

#+name: pelvis_handle_pels
#+begin_src python
  def makePel(self):
      """Create a blank Pel object for loading detector data"""
      data = PelFile()
      def statusfunc(x):
          self.progress.SetValue(x)
          self.Yield()
      data.statusfunc = statusfunc
      return data
#+end_src

     The =loadPel= command reads in a neutron data file.  It takes as
     a single parameter a message to display to the user about what
     sort of file should be loaded.  There is also the ability to load
     a pre-histogrammed version of the neutron data, stored in the
     [[http://docs.numpy.org][numpy's]] native binary format.  In practice, this hasn't been that
     useful and may be dropped.  The numpy files do read far faster,
     but they also take up huge amounts of disk space compared to the
     event files, plus they need preprocessing from said event files
     to be created in the first place.

     This function also loads the monitor file that corresponds to the
     data set.

#+name: pelvis_handle_pels
#+begin_src python  
  def loadPel(self,message):
      """Load a .pel file and its monitor data.
      
      Keyword arguments:
      message -- The title for the load file dialog.
      
      """
      dlg=wx.FileDialog(self,message,wildcard="He3 data|*neutron_event.dat|Preformatted Histograms|*.npy",style=wx.FD_OPEN)
      if dlg.ShowModal()==wx.ID_OK:
      #            self.SetCursor(wx.CURSOR_WAIT)
          path = dlg.GetPath()
          if path[-3:] == "dat":
              data = self.makePel()
              data.readfileimage(path)
          elif path[-3:] == "npy":
              data = np.load(path)
      #            self.SetCursor(wx.CURSOR_ARROW)
      else:
          return (None,None)
      mon = MonFile(path[:-17]+"bmon_histo.dat")
      return (data,mon)
#+end_src

     The =loadNormPel= function loads a neutron data set and a set of
     counts from the beam monitor.  In the unlikely event that there
     is a [[flat run]], the flat is subtracted out of the data set.  The
     neutron data is then normalized to the monitor count.

#+name: pelvis_load_norm_pel
#+begin_src python

      def loadNormPel(self,message):
          """Load a .pel file, normalize it by monitor, and subtract background"""
          (data,mon) = self.loadPel(message)
          if isinstance(data,PelFile):
              data = np.asarray(data.make3d(),np.float32)
          if mon is None:
              return (data,1)
          if self.flatrun != None:
              flatrun = np.load(self.flatrun)
              self.flatrun.seek(0)
              flatrun *= mon.time
              data -= flatrun
          spec = mon.spec
          monsum = np.sum(spec)
          print("Integrated monitor counts: " + str(monsum))
          data /= monsum
          return (data,np.sum(mon.spec))
#+end_src

     The =loadUpAndDown= function is a helper function to load both
     spin states of a flipping measurement.

#+name:pelvis_load_up_and_down
#+begin_src python
      def loadUpAndDown(self):
          """Read in spin flip data"""
          u3d,uscale = self.loadNormPel("Spin Up State")
          if u3d is None:
              return False
          del self.data
          d3d,dscale = self.loadNormPel("Spin Down State")
          self.data = (u3d,d3d)
          self.scale = (uscale,dscale)
          return True
#+end_src



*** Menu Commands

     The Image Array command causes Pelvis to export the detector
     image, one wavelength bin at a time.  It can be useful to find
     effects which are sensitive to both position and wavelength, but
     it honestly hasn't seen much use.

     The =path= and =ext= variables are used to get the file name that
     the user chose and then sandwich the wavelength between them.

#+name: pelvis_on_image_array
#+begin_src python

      def OnImageArray(self,event):
          """Exports the 2d detector image by wavelength"""
          dlg = self.imageSaveDialog
          if dlg.ShowModal()==wx.ID_OK:
              path=dlg.GetPath()
              ext = path[-4:]
              path = path[:-4]
              (lmin,lmax) = self.opPanel.getLambdaRange()
              for i in range(lmin,lmax):
                  file=path+("%03i"%i)+ext
                  self.opPanel.setLambdaRange(0.1*i,0.1*(i+1))
                  self.updateData()
                  self.update()
                  self.imPanel.saveImage(file)
                  self.progress.SetValue(1000*(i-lmin)/(lmax-lmin))
                  self.Yield()
              self.opPanel.setLambdaRange(lmin*0.1,lmax*0.1)
              self.updateData()
              self.progress.SetValue(0)
#+end_src

     The =OnUpdateButton= isn't really a menu command, but is rather
     the calback for when the user clicks the update button.  All it
     does is call the current value of the =updateData= function.
     This function exists mostly because wxWidgets won't follow the
     dynamically changing definition for =updateData= and needs a
     static location for the callback.

<<pelvis_on_update_button_link>>
#+name: pelvis_on_update_button
#+begin_src python
      def OnUpdateButton(self,event):
          """Refresh the data when the user pushes the "Update" button"""
          #This function is needed for wxWidgets to allow
          #for dynamically changing the bound function
          self.updateData(event)
#+end_src

     The =OnOpen= function handles opening a single data set.
     [[*Handling%20Pel%20Files][loadNormPel]] does all of the actual file loading.  The =data= and
     =scale= values are set to the actual neutron data and monitor
     counts, respectively.  The =updateData= and =update= functions
     are also set to single data file mode.

#+name:pelvis_on_open
#+begin_src python
      def OnOpen(self,event):
          """Load a single .pel file for display"""
          data,scale = self.loadNormPel("Choose the Pel File to Open")
          if data is None:
              return
          self.data = data
          self.scale = scale
          self.progress.SetValue(0)
          self.specDlg.setMode("up")
          self.updateData = self.updateSingleData
          self.update = self.updateSingle
          self.updateData()
#+end_src

     Similarly to =OnOpen=, =OnOpenSet= loads two data files for
     examining a polarization measurement.  The actual file loading is
     handled by [[*Handling%20Pel%20Files][loadUpAndDown]].  Should the files load, the application
     switches to presenting polarization information.

#+name:pelvis_on_open_set
#+begin_src python
      def OnOpenSet(self,event):
          """Load a spin flip measurement for display"""
          if self.loadUpAndDown():
              self.OnPolar(event)
#+end_src

     Back when the PAPA detector first arrived, there was a light leak
     that caused an enormous noise signal across the detector.  The
     flat files were an attempt to eliminate that.  The flat files are
     essentiall a position sensitive calculation of the detector noise
     per unit time.  In practice, this functionality is almost never
     used and should probably be removed, as it may be out of date or
     inaccurate. 

     =OnFlat= starts by having the user load in a background run.
     This run is then flattened into a 3D positional map (the
     background is assumed to be wavelength independent).  This 2D map
     is normalized to the time of the measurement.

     The =OnFakeFlat= function tries to use the background to simulate
     having performed a flat measurement.  Honestly, this is probably
     better perofrmed by simple background subtraction and should be
     removed from the program.

#+name:pelvis_flat_files
#+begin_src python
      def OnFlat(self,event):
          """Load a blank run for background subtraction"""
          (data,mon) = self.loadPel("Choose a Blank Run")
          if data == None:
              return
          if isinstance(data,PelFile):
              flatrun = data.make3d()
          elif isinstance(data,np.ndarray):
              flatrun = data
          flatrun = np.sum(flatrun,axis=2)
          flatrun /= RESOLUTION
          flatrun /= float(mon.time)
          flatrun = np.expand_dims(flatrun,2)
          self.flatrun = TemporaryFile()
          np.save(self.flatrun,flatrun)
          self.flatrun.seek(0)
          self.progress.SetValue(0)
  
      def OnFakeFlat(self,event):
          """Create a fake background run from outside the region of interest."""
          (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
          totarea = 512*512
          centarea = (yMax-yMin)*(xMax-xMin)
          backgroundarea = totarea-centarea
          if type(self.data) is tuple:
              (u,d)=self.data
  
              totu = np.sum(u)
              totd = np.sum(d)
              centu = np.sum(u[yMin:yMax,xMin:xMax,:])
              centd = np.sum(d[yMin:yMax,xMin:xMax,:])
  
              backgroundu = totu-centu
              backgroundd = totd-centd
              backgroundrateu = backgroundu/backgroundarea
              backgroundrated = backgroundd/backgroundarea
              backgroundrateu /= (RESOLUTION + 1) #normalize against the wavelengths
              backgroundrated /= (RESOLUTION + 1) #normalize against the wavelengths
              ###Stupid Memory Errors
              del self.data
              u -= backgroundrateu
              d -= backgroundrated
              ###
              self.data=(u,d)
          else:
              d=self.data
              tot = np.sum(d)
              cent = np.sum(d[yMin:yMax,xMin:xMax,:])
              background = tot-cent
              backgroundrate = background/backgroundarea
              backgroundrate /= (RESOLUTION + 1) #normalize against the wavelengths
              self.data-=backgroundrate
          self.updateData()
#+end_src

     The =OnROD= command is really just the background subtraction
     function.  The =ROD= standards for "Region of Disinterest", which
     is a play on the phrase "Region of Interest".

     The code simply finds the average per pixel count rate in the current
     selected region of interest and subtracts it from all the pixel.
     Note that the background subtraction is performed per wavelength
     bin, so wavelength specific backgrounds are handled appropriately.

#+name:pelvis_menu_commands
#+begin_src python
  #Subtract out the region of disinterest
  def OnROD(self,event):
      """Take the region of interest as background noise"""
      (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
      area = (yMax-yMin)*(xMax-xMin)
      if type(self.data) is tuple:
          u,d=self.data
          del self.data
          totu = np.sum(np.sum(u[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          totd = np.sum(np.sum(d[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          totu /= area
          totd /= area
          u -= totu
          d -= totd
          self.data=(u,d)
      else:
          d=self.data
          totd = np.sum(np.sum(d[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          #totd = np.atleast_3d(totd)
          totd /= area
          #print(totd.shape)
          #print(self.data.shape)
          self.data -= totd
      self.updateData()
#+end_src

     The =OnExportROI= function creates a 2D binary map of all of the
     pixels where the intensity is less that the minimum intensity and
     saves the map to a file.  The map can either be a text file for
     readability or a binary file in numpy format for speed and
     compactness.  Not that =OnExportROI= does *not* change the
     current mask for the application. 

#+name:pelvis_menu_commands
#+begin_src python 
  
  def OnExportROI(self,event):
      """Save a file containing a map of where the current data
      image is greater than vmin"""
      vMin,_ = self.opPanel.getIntensityRange()
      mask = self.flatdata > vMin
      # (vMin,vMax) = self.opPanel.getIntensityRange()#
      # (xMin,xMax,yMin,yMax) = self.opPanel.getRoi()#
      # (lMin,lMax) = self.opPanel.getLambdaRange()#
      # (lMin,lMax) = (lMin/10,lMax/10)#
      # mask = [["xMin",xMin], ["xMax",xMax], ["yMin",yMin], ["yMax",yMax], \
      #         ["lMin",lMin], ["lMax",lMax], ["vMin",vMin], ["vMax",vMax]]#
      dlg = wx.FileDialog(self,
                          "Where to save the mask file?",
                          wildcard="Numpy dump (npy)|*.npy|Text (dat)|*.dat",
                          style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
      if dlg.ShowModal()==wx.ID_OK:
          path=dlg.GetPath()
          ext = path[-4:]
          if ext == ".dat":
              np.savetxt(path,mask,fmt="%d")
          else:
              np.save(path,mask)
#+end_src

     The =OnImportROI= sets the detector mask used for specifying the
     region of interest.  It can load either of the mask formats
     exported by =OnExportROI=.  A mask is loaded additively - if a
     pixel is masked in either the current mask or in the loaded mask
     file, it will be masked in the final mask.  Currently, the only
     way to remove a pixel from the mask is to restart the
     application.  Obviously, this is suboptimal and a simple
     =RemoveMask= function should be written to return to an unmasked
     state.

#+name:pelvis_menu_commands
#+begin_src python 
  
  def OnImportROI(self,event):
      """Adds another mask to the current system mask"""
      dlg = wx.FileDialog(self,
                          "Which Mask File?",
                          wildcard="Numpy dump (npy)|*.npy|Text (dat)|*.dat",
                          style=wx.FD_OPEN)
      time.sleep(.1)
      if dlg.ShowModal()==wx.ID_OK:
          path = dlg.GetPath()
          ext = path[-4:]
          if ext == ".dat":
              newmask = np.loadtxt(path,dtype=np.bool)
              newmask=dict(newmask)#
          else:
              newmask = np.load(path)
          self.mask = np.logical_and(self.mask,newmask)
          #self.opPanel.setPosMin(newmask["xMin"],newmask["yMin"])#
          #self.opPanel.setPosMax(newmask["xMax"],newmask["yMax"])#
          #self.opPanel.setLambdaRange(newmask["lMin"],newmask["lMax"])#
          #self.opPanel.setIntensityRange(newmask["vMin"],newmask["vMax"])#
          self.updateData()
  
#+end_src

     =OnSave= save the current detector image to a graphics file.  The
     actual image saving is handled by the [[ImagePanel]] class.

#+name:pelvis_menu_commands
#+begin_src python   
  
  def OnSave(self,event):
      """Save the current 2D image to a file"""
      print("OnSave")
  #        dlg=wx.FileDialog(self,"Choose graphics file",wildcard="Windows Bitmap (bmp)|*.BMP|Portable Network Graphic (png)|*.PNG|Joint Photographic Experts Group (jpg)|*.JPG|Portable Network Monocrome (pnm)|*.PNM|Tagged Image File Format (tif)|*.TIF|Archaic, useless format (pcx)|*.PCX",style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
      dlg = self.imageSaveDialog
      if dlg.ShowModal()==wx.ID_OK:
          self.imPanel.saveImage(dlg.GetPath())
#+end_src

     The =OnSpectrum= function formats the data into a 1D format for
     use by the [[SpectrumDialog]] in actually giving the spectral
     information.  The data is masked by both the mask generated by
     =OnImportROI= and by the user's chosen region of interest.  The
     total counts per wavelength bin are then sent to the
     SpectrumDialog, along with the scale from the monitor count. 

     The user's chosen intensity range display is also sent to the
     spectrum dialog.  This is helpful in getting proper bounds for
     graphing the polarization and flipping ratio, since dividing by
     small numbers can give strange boundary ranges.  Unfortunately,
     this is NOT useful with raw intensity rates, since the intensity
     range per pixel on the detector doesn't necessarily correspond to
     what we're interested in with  the intensity per wavelength bin.

#+name:pelvis_menu_commands
#+begin_src python   
  
  def OnSpectrum(self,event):
      """Display a plot of the region of interest versus wavelength"""
      print("OnSpectrum")
      (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
      if type(self.data) is tuple:
          u3d,d3d = self.data
          u3d = u3d[:,:,:]
          d3d = d3d[:,:,:]
          u3d[np.logical_not(self.mask)] = 0
          d3d[np.logical_not(self.mask)] = 0
          u = np.sum(np.sum(u3d[yMin:yMax,xMin:xMax],0),0)
          d = np.sum(np.sum(d3d[yMin:yMax,xMin:xMax],0),0)
          uscale,dscale = self.scale
          self.specDlg.setScale(uscale,dscale)            
          self.specDlg.setData(u,d)
      else:
          copy = self.data[:,:,:]
          copy[np.logical_not(self.mask)] = 0
          u = np.sum(np.sum(copy[yMin:yMax,xMin:xMax],0),0)
          #            u *= self.scale
          self.specDlg.setScale(self.scale)
          self.specDlg.setData(u)
      self.specDlg.setIntensityRange(self.opPanel.getIntensityRange())
      self.specDlg.Show()
#+end_src
     
     There are a couple of menu functions for setting the color scheme
     of the detector image.  =OnGrey= gives a greyscale image, as one
     would expect.  =OnHueVal= gives an image where the intensity if
     encoded into the Hue, with the saturation and Value both pegged
     at the maximum.  Finally, =OnSpectral= is the default, with a
     color scheme that starts at zero and passes through the range of
     hues before arriving at white.

     If the user wants a different color map, they can use the
     [[ColorMapPicker]] to chose from any of the installed color maps.
     PELVis currently does not support creating custom color spectra.

#+name:pelvis_menu_commands
#+begin_src python   
    
  def OnGrey(self,event):
      """Set the colormap to gray"""
      self.imPanel.cmap = cm.gray
      self.colorbar.setCmap(cm.gray)
      self.update()
  
  def OnHueVal(self,event):
      """Set the colormap to a rainbow"""
      self.imPanel.cmap = cm.jet
      self.colorbar.setCmap(cm.jet)
      self.update()
  
  def OnSpectral(self,event):
      """Set the colormap to the spectral map"""
      self.imPanel.cmap = cm.spectral
      self.colorbar.setCmap(cm.spectral)
      self.update()
  
  def OnPicker(self,event):
      """Let the user pick a color map from a list"""
      if self.cmp is None:
          self.cmp = ColorMapPicker(self,self.setColorMap)
      self.cmp.Show()
  
#+end_src

     The =OnExit= function is run when the user closes the program
     from the menu.  It's not that interesting.
     
#+name:pelvis_on_exit
#+begin_src python
    
  def OnExit(self,event):
        """Quit the program"""
        self.Close()
#+end_src

     There are four functions to set the current data interpretation
     mode for the application.  Each one sets the =update= and
     =updateData= functions to the [[*Updaters][proper function]] to handle the data
     type, then sets the mode of the spectrum dialog.

     It currently looks like the update function is always set to
     updateSingle.  If this is the case, then the code can be
     simplified.  This is worth investigation.

#+name:pelvis_menu_commands_2
#+begin_src python
  def OnPolar(self,event):
      """Display neutron polarization"""
      print("OnPolar")
      self.specDlg.setMode("polar")
      self.updateData = self.updateDataPolar
      self.update = self.updateSingle
      self.updateData()
    
  def OnFlipping(self,event):
      """Display the flipping ratio"""
      print("OnFlip")
      self.specDlg.setMode("flipping")
      self.updateData = self.updateDataFlip
      self.update = self.updateSingle
      self.updateData()
    
  def OnAnalysisSpinUp(self,event):
      """Display the Spin Up data"""
      print("OnSpinUp")
      self.specDlg.setMode("up")
      self.updateData = self.updateDataUp
      self.update = self.updateSingle
      self.updateData()
    
  def OnAnalysisSpinDown(self,event):
      """Display the Spin Down data"""
      print("OnSpinDown")
      self.specDlg.setMode("down")
      self.updateData = self.updateDataDown
      self.update = self.updateSingle
      self.updateData()
#+end_src

     =OnCopy= is called when a user selects the Copy command from the
     Edit menu.  This copies the current detector image to the
     clipboard, though everything is really handled by the [[ImagePanel]] class.

#+name:pelvis_menu_commands_2
#+begin_src python   
      
  def OnCopy(self,event):
      """Copy the image to a clipboard"""
      self.imPanel.copyToClipboard()
#+end_src


     

*** Updaters

     There are two updates which need to be performed.  The first is
     updating the data, which involves taking the 3D arrays of neutron
     data and turning them into a single, 2D map.  The second is using
     that 2D data to update the other parts of the application.  All
     of the function with data in the name handle converting the 3D
     data into the 2D map, while the remaining functions pass the 2D
     data to the rest of the application.

     =updateSingleData= is used when only a single file is loaded.  As
     the only thing we can do is give intensity per pixel, a simple
     sum is performed along the wavelength axis.

#+name: pelvis_updaters
#+begin_src python
      def updateSingleData(self,event=None):
          """Update changes in wavelength on a single file"""
          print("Make 2d")
          (lmin,lmax) = self.opPanel.getLambdaRange()
          self.flatdata = np.sum(self.data[:,:,lmin:lmax],2)
          self.update()
#+end_src

     =updateDataFlip= and =updateDataPolar= require both an up and
     down state from a polarization measurement.  They then calculate
     the per pixel neutron flipping ratio and polarization,
     respectively.  a value of 10^{-9} is added to the denominator to
     prevent divide by zero errors.

#+name:pelvis_updaters
#+begin_src python
  
      def updateDataFlip(self,event=None):
          """Update changes in wavelength for flipping ratios"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,d3d)=self.data
          u = np.sum(u3d[:,:,lmin:lmax],2)
          d = np.sum(d3d[:,:,lmin:lmax],2)
          self.flatdata = u/(d+1e-6)
          self.update()
  
      def updateDataPolar(self,event=None):
          """Update changes in wavelength for polarizations"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,d3d)=self.data
          u = np.sum(u3d[:,:,lmin:lmax],2)
          d = np.sum(d3d[:,:,lmin:lmax],2)
          self.flatdata = (u-d)/(u+d+1e-6)
          self.update()
#+end_src

     The =updateDataUp= and =updateDataDown= commands display the
     neutron intensity per pixel in a single spin state.  They are
     largely identical to =updateSingleData=, except for the line
     which selects the spin state.

#+name:pelvis_updaters
#+begin_src python

      def updateDataUp(self,event=None):
          """Update changes in wavelength for the spin up state"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,_)=self.data
          self.flatdata = np.sum(u3d[:,:,lmin:lmax],2)
          self.update()
  
      def updateDataDown(self,event=None):
          """Update changes in wavelength for the spin down state"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (_,d3d)=self.data
          self.flatdata = np.sum(d3d[:,:,lmin:lmax],2)
          self.update()
#+end_src

     The =updateSingle= function takes the current 2D data, performs
     the appropriate masking, and updates the data in the [[GraphPanel][GraphPanels]].
     It also updates the range on the color bar and forces the
     [[ImagePanel][detector image]] to update.

#+name:pelvis_updaters
#+begin_src python
  
      def updateSingle(self,event=None):
          """Update the 2D data for the region of interest and intensity"""
          (vMin,vMax) = self.opPanel.getIntensityRange()
          (xMin,xMax,yMin,yMax) = self.opPanel.getRoi()
          data = self.flatdata[:,:]
  
          #Mask to zero during the summing parts
          data[np.logical_not(self.mask)] = 0
          self.posPanel.data = data
          self.posPanel.setRange(xMin,yMin,xMax,yMax)
          x=np.arange(128,0,-1)
          y=np.sum(data[:,xMin:xMax],axis=1)
          self.yPanel.SetPlot(x,y)
          #handle the x-plot
          x=np.arange(0,16,1)
          y=np.sum(data[yMin:yMax,:],axis=0)
          self.xPanel.SetPlot(x,y)
          if vMin is None:
              vMin = np.min(data)
          if vMax is None:
              vMax = np.max(data)
          self.colorbar.setRange(vMin,vMax)
          self.colorbar.update()
          #mask to vmin for the plotting
          data[np.logical_not(self.mask)] = vMin
          self.imPanel.update(self.flatdata,vMin,vMax)

#+end_src


** Position Panel

   This is a class to provide a small panel which provides
   information about single pixels of detector data via the cursor
   position.  It also provides aggregate information over the region
   of interest.

*** Position Panel Class Skeleton

#+Name:position_panel
#+begin_src python :noweb tangle
  class PositionPanel(wx.Panel):
      """A panel with pixel information
  
      The intent of this panel is to provide information about
      single pixels of detector data via cursor position.  It
      also provides aggregate information over the region of
      interest.
  
      """

      def __init__(self,parent):
          """Create a PositionPanel"""
          <<position_panel_init>>
      <<position_panel_updating>>
#+end_src

*** Initialization of the PositionPanel

     Creating a new PositionPanel requires only a single parameter:
     the parent frame which will hold the panel.  The constructor
     begins by creating the text controls that display the X and Y
     position of the cursor, as well as the value under the cursor (Z)
     and the integrated value over the region of interest (ROI).

#+name: position_panel_init
#+begin_src python
          wx.Panel.__init__(self,parent)
          sizer=wx.GridBagSizer(3,2)
          sizer.Add(wx.StaticText(self,-1,"X:"),pos=wx.GBPosition(0,0))
          self.x = wx.TextCtrl(self,-1,"")   
          sizer.Add(self.x,pos=wx.GBPosition(0,1))
          sizer.Add(wx.StaticText(self,-1,"Y:"),pos=wx.GBPosition(1,0))
          self.y = wx.TextCtrl(self,-1,"")
          sizer.Add(self.y,pos=wx.GBPosition(1,1))
          sizer.Add(wx.StaticText(self,-1,"Z:"),pos=wx.GBPosition(2,0))
          self.intensity = wx.TextCtrl(self,-1,"")
          sizer.Add(self.intensity,pos=wx.GBPosition(2,1))
          self.integrate = wx.TextCtrl(self,-1,"")
          sizer.Add(wx.StaticText(self,-1,"ROI:"),pos=wx.GBPosition(3,0))
          sizer.Add(self.integrate,pos=wx.GBPosition(3,1))

#+end_src
  
     We give a default region of interest that covers the entire detector.

#+name: position_panel_init
#+begin_src python
          #Set the starting region of interest
          self.minX = 0
          self.minY = 0
          self.maxX = 16
          self.maxY = 128

#+end_src

     The text controls are for display purposes only, so we'll ensure
     that they aren't editable.

#+name: position_panel_init
#+begin_src python  
          self.x.SetEditable(False)
          self.y.SetEditable(False)
          self.intensity.SetEditable(False)
#+end_src

     The class member =self.data= is a pointer to the actual data
     being examined.  We'll initialize it to =None= to begin with.

#+name: position_panel_init
#+begin_src python
          self.data = None #A 2D numpy array of the data being examined.

#+end_src

Finally, we need to do the standard GUI layout code.

#+name: position_panel_init
#+begin_src python
          self.SetAutoLayout(True)
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Layout()
#+end_src

*** Update position data

     As implied by the name, the primary function of the position
     panel is to provide the direct numbers for the value under the
     user's cursor.  To do that, it must know where the mouse is.  The
     =set= function takes the x and y position of the cursor and
     updates the panel accordingly.

#+Name:position_panel_updating
#+begin_src python
      def set(self,x,y):
          """Updates the position being examined"""
          self.x.SetValue(str(x))
          self.y.SetValue(str(y))
          if self.data is None:
              return
          self.intensity.SetValue(str(self.data[y,x]))
#+end_src

     Obviously, this is of no use if the panel doesn't know the
     detector values.  The =setData= function provides a 2D array of
     values for the Panel to report on.

#+Name:position_panel_updating
#+begin_src python
      def setData(self,data):
          """Updates the data being examined"""
          self.data=data
#+end_src

     The remaining functions deal with the region of interest
     integration.  The =setRange= function controls the region of
     interest while the =updateIntegration= function handles
     calculating 

#+Name:position_panel_updating
#+begin_src python
      def setRange(self,minX,minY,maxX,maxY):
          """Updates the region of interest for integration"""
          self.minX = minX
          self.minY = minY
          self.maxX = maxX
          self.maxY = maxY
          self.updateIntegration()
      def updateIntegration(self):
          """Calculates the sum of the data over the region of interest"""
          self.integrate.SetValue(
              str(np.sum(self.data[self.minY:self.maxY,self.minX:self.maxX])))
#+end_src


** Option Panel

    The class PelvisOptionPanel creates a panel of labeled text boxes
    for user entry.  This is used to control values such as the
    wavelength range, region of interest, and intensity values.

    As an experiment in software architecture, the class generates the
    layout of the panel from a list of configurations.  Each list item
    is a tuple of four values

    | Position | 0           |                      1 | 2                    | 3             |
    | Value    | Name        | Relative list position | Label                | Default Value |
    | Type     | string      |                    int | string               | string        |
    | Example  | "lambdaMax" |                     30 | "Maximum Wavelength" | "19.7"        |

    The panel generates a set of text controls with the given labels
    and default values.  The text controls are arranged from top to
    bottom by the order of the relative list position from smallest to
    largest.

    The advantage to this setup is that adding new options onto the
    panel is trivial.  Putting a new item into the list adds a new
    option onto the panel.  The disadvantage is that the data is a
    little more cumbersome to access as the values are not members of
    the class.  This could be fixed with Python accessors and
    properties, but I have not done so yet.  As this design decision
    was made to ease life for future maintainers and, seeing as you're
    reading this, you are the future maintainer, feel free to return
    to hard coded values if you find it easier to handle.
    
#+name:pelvis_option_panel
#+begin_src python :noweb tangle
  class PelvisOptionPanel(wx.Panel):
      """A panel for user parameters
  
      The panel gets it's parameters and appearance from the built in
      DEFAULTS variable.  This was designed to allow the easy addition
      of more parameters in the future.
  
      """
      #Each parameter is a tuple
      #0 - variable name
      #1 - position in list
      #2 - label
      #3 - default value
      DEFAULTS = [("lambdaMax",0,"Maximum Wavelength","20"),
                  ("lambdaMin",10,"Minimum Wavelength","0"),
                  ("intMax",20,"Maximum Intensity",""),
                  ("intMin",30,"Minimum Intensity",""),
                  ("xMin",40,"Minimun X","0"),
                  ("xMax",50,"Maximum X","16"),
                  ("yMin",60,"Minimun Y","0"),
                  ("yMax",70,"Maximum Y","128")]
  
      def __init__(self,parent):
          """Creates a PelvisOptionPanel"""
          <<pelvis_option_panel_init>>
  
      <<pelvis_option_panel_wavelength>>
  
      <<pelvis_option_panel_intensity>>
  
      <<pelvis_option_panel_roi>>
  
  
#+end_src

*** Initialization

     We begin by initializing the superclass and creating a sizer for
     the panel
#+name:pelvis_option_panel_init
#+begin_src python
          wx.Panel.__init__(self,parent)
          sizer=wx.BoxSizer(wx.VERTICAL)
#+end_src   

     We then create the text controls.  The controls are held in the
     local dictionary =options=, which will need to be used every time
     we want to access one of the values.
#+name:pelvis_option_panel_init
#+begin_src python
          self.options={}#member which holds the created text controls
  
          self.DEFAULTS.sort(lambda x,y: x[1]-y[1])
          for option in self.DEFAULTS:
              (key,_,title,val) = option
              sizer.Add(wx.StaticText(self,-1,title))
              self.options[key] = wx.TextCtrl(self,-1,val)
              sizer.Add(self.options[key])
#+end_src

     Finally, we perform the standard cleanup for a wxPanel
  
#+name:pelvis_option_panel_init
#+begin_src python
          self.SetAutoLayout(True)
          self.specDlg = SpectrumDialog(self)
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Layout()
#+end_src

*** Wavelength Range

     When a set of parameters is added, it's useful to put in a
     standard getter and setter.  The setters are fairly standard, but
     the getter can be a little tricky, since the user might add a
     non-standard value.  It's good to provide default values if the
     user's input cannot be parsed.

     Note that the code below is *wrong*.  It holds true while
     the RESOLUTION is 200, which is the default case, but the
     multiplication by ten should be replaced with a value dependent
     on the current resolution.

#+Name:pelvis_option_panel_wavelength
#+begin_src python

      def getLambdaRange(self):
          """Gives a tuple with the minimum and maximum wavelength indices"""
          try:
              lmin = int(float(self.options["lambdaMin"].GetValue())*10)
          except ValueError:
              lmin = 0
          try:
              lmax = int(float(self.options["lambdaMax"].GetValue())*10)
          except ValueError:
              lmax = RESOLUTION
          return (lmin,lmax)
  
      def setLambdaRange(self,min,max):
          """Set the minimum and maximum wavelengths"""
          self.options["lambdaMin"].SetValue(str(min))
          self.options["lambdaMax"].SetValue(str(max))
#+end_src

*** Intensity Range

     We create similar getters and setters for the minimum and maximum
     intensity.  The values create bounds for both the 2D color plot
     and the spectrum display.  They're also used as part of the mask
     making routines.

#+name:pelvis_option_panel_intensity
#+begin_src python
      def getIntensityRange(self):
          """Return a tuple with the floor and ceilling for intensity
  
          If a value isn't specified, or is not a number, None is returned
          for that part of the range.
  
          """
          try:
              vMin = float(self.options["intMin"].GetValue())
          except ValueError:
              vMin = None
          try:
              vMax = float(self.options["intMax"].GetValue())
          except ValueError:
              vMax = None
          return (vMin,vMax)
  
      def setIntensityRange(self,min,max):
          self.options["intMin"].SetValue(str(min))
          self.options["intMax"].SetValue(str(max))
          self.specDlg.setIntensityRange((min,max))

#+end_src

*** Region of Interest

     Finally, we need getters and setters for our region of interest.
     The getter works pretty much the same as the others, but the
     setter has been split into two functions: one for the upper left
     corner and another for the lower right.  This allows us to set
     the region of interest with two mouse clicks.

#+name:pelvis_option_panel_roi
#+begin_src python
      def getRoi(self):
          """Returns a 4-tuple with the region of interest
  
          Returns (xmin,xmax,ymin,ymax).  Minimum values, if
          unspecified, are set to zero.  Maximum values, if
          unspecified, are set to 512.
  
          """
          try:
              xMin = int(self.options["xMin"].GetValue())
          except ValueError:
              xMin = 0
          try:
              xMax = int(self.options["xMax"].GetValue())
          except ValueError:
              xMax = 512
          try:
              yMin = int(self.options["yMin"].GetValue())
          except ValueError:
              yMin = 0
          try:
              yMax = int(self.options["yMax"].GetValue())
          except ValueError:
              yMax = 512
          return (xMin,xMax,yMin,yMax)
  
      def setPosMin(self,x,y):
          """Takes the x and y coordinates for the NW corner of the ROI."""
          self.options["xMin"].SetValue(str(x))
          self.options["yMin"].SetValue(str(y))
  
      def setPosMax(self,x,y):
          """Takes the x and y coordinates for the SE corner of the ROI."""
          self.options["xMax"].SetValue(str(x))
          self.options["yMax"].SetValue(str(y))
#+end_src

#  LocalWords:  wxWidget SNS numpy


** Graph Panel

   The =GraphPanel= module creates a single filled-line plot that can
   be embedded in a wxWidgets frame.  It's used by PelVis to present
   the detector image integrated along axis.

*** Graph Panel Skeleton

#+begin_src python :tangle GraphPanel.py :noweb tangle :padline no
"""Classes for adding sumlines to frames

This module contains a single class, GraphPanel, which plots two dimensional
data filled along a chosen axis.  This class was originally designed for giving
the summation of a matrix along a given axis, but there's not reason that it
couldn't be expanded for other purposes.

"""

import numpy as np

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx import NavigationToolbar2Wx
from matplotlib.figure import Figure
#import matplotlib.cm as cm

import wx

<<graphpanel_rebin>>

class GraphPanel(wx.Panel):
    """This class creates a panel that displays a filled plot. """

    
    HORIZONTAL = 0 
    INVERTED = 1
    VERTICAL = 2
    <<graphpanel_init>>
    <<graphpanel_setplot>>

#     def SetYLim(self,range):
#         self.axes.set_ylim(range)

#     def SetXLim(self,range):
#         self.axes.set_xlim(range)

    <<graphpanel_setpos>>

    <<graphpanel_onpaint>>

#+end_src


*** rebin function

The rebin function takes an numpy array and an integer of how many
bins to combine.  The result is a new numpy array where each group of
=count= bins have been averaged together.

This is non-intuitive and the =mean= function should be replaced with
a =sum= to make the results more obvious.

This function is no longer in use and should probably be removed.

#+name:graphpanel_rebin
#+begin_src python
# FIXME:  This function is extremely brittle
def rebin(a,count):
    """A quick function to rebin an array

    This function takes an array and rebins it into a smaller array.
    Note that, if the length of the array isn't divisible by the binning
    factor, the end of the array will be truncated.  This is probably
    not a sane default, but I don't have any better ideas.

    Keyword arguments:
    a -- The numpy array to be rebinned.
    count -- The number of bins to be combined.  For instance, if the array
             has a length of 100 and the count is 4, the return value
             will have a length of 25

    """

    return np.array([a[i:i+count].mean() for i in range(0,len(a),count)])
#+end_src

*** Initialization

     A =GraphPanel= object needs four parameters.  The first is the
     =parent=, which holds the container in which the panel will be
     displayed.  The second, =fig=, is a tuple with the relative
     dimensions of the panel.  For instance, if =fig= is =(2,3)=, then
     the panel will be two units wide and three units tall.  The =res=
     parameter gives the number of pixels per unit for the dimensions
     in =fig=.  Finally, the orientation is either
     =GraphPanel.HORIZONTAL=, =GraphPanel.INVERTED=, or
     =GraphPanel.VERTICAL=.  A =HORIZONTAL= gives a graph with the
     x-axis along the bottom and the y-axis pointing up.  =VERTICAL=
     has it's x-axis along the right edge and the y-axis pointing
     left.  Finally, =INVERTED= has it's x-axis along the top and the
     y-axis pointing downward.

     Just as with the =[[Image Panel]]=, the object contains a matplotlib
     =Figure= and a wxAgg =FigureCanvas= to do the actual plotting.

#+name:graphpanel_init
#+begin_src python
    def __init__(self,parent,fig,res,orientation):
        """Create a new panel for plotting.

        Keyword Arguments:
        parent -- the panel in which the new one is to be displayed
        fig -- a tuple representing the relative dimensions of the panel
        res -- the number of pixels per part of the fig tuple.
        orientation -- the rotation of the image

        fig and res combine to produce the total size, in pixels, of the
        panel.  For instance, if fig=(2,8) and res=64, the final panel
        has a size of (128,512)

        The orientation can be one of HORIZONTAL, VERTICAL, or INVERTED,
        as defined as constants in the class definition. Horitzontal uses
        the standard x and y axes, and is best for putting above a 2d image.
        VERTICAL swaps the x and y axes and is best for going to the right
        of an image.  INVERTED plots with x and -y, and is best below the image.

        """
        wx.Panel.__init__(self,parent)
        self.Bind(wx.EVT_PAINT,self.__OnPaint)
        #The actual figure for plotting
        self.figure = Figure(figsize=fig,dpi=res)
        #The space where th figure is drawn
        self.canvas = FigureCanvas(self,-1,self.figure)
        #The rotation of the figure.
        self.orientation=orientation
#+end_src



*** Plotting

     The =SetPlot= function gives the panel its data for plotting.
     The first variable is an array of the x-coordinate and the second
     is the y-coordinates.

#+name:graphpanel_setplot
#+begin_src python
    def SetPlot(self,x,y):
        """Set the x and y coordinates of the data to be plotted."""
        self.figure.clear()
        self.axes = self.figure.add_subplot(111)
        #We rebin the data in steps of four to smooth out the dead PMTs
        #If all of the PMTs have been fixed, this step could be taken out.
        if self.orientation==self.INVERTED:
            self.axes.fill_between(x,y)
            self.SetPos([0,0.1,1,0.9])
            self.axes.set_xlim((0,np.max(x)))
            #Reverse the order of the limits to get an inverted graph
            self.axes.set_ylim((np.max(y),0))
        elif self.orientation==self.HORIZONTAL:
            self.axes.fill_between(x,y)
            self.SetPos([0.1,0.1,0.9,0.9])
            self.axes.set_xlim((0,np.max(x)))
            self.axes.set_ylim((0,np.max(y)))
        else:
            #Notice that we now fill along the x axis
            self.axes.fill_betweenx(x,-y)
            self.SetPos([0.2,0,0.8,1])
            self.axes.set_ylim((0,128))

        self.axes.autoscale_view(True,True,True)
        self.Refresh()
#+end_src

     The =SetPlot= function uses =SetPos= to move the graph around
     within the panel.  We want the graph to extend across the whole
     panel, but, by default, matplotlib takes some space for the
     axes.  We use =SetPos= to tell matplotlib to only use the part of
     the plot that contains the actual graph.

#+name:graphpanel_setpos
#+begin_src python
    def SetPos(self,pos):
        """Set the position of the graph within the panel.

        This function take a four element array which marks the far
        corners of the graph.  The coordinates are given as a fraction
        of the size of the panel.  For instance, pos=[0,0.3333,1,0.6666]
        would produce a graph that stretches across the panel in the x
        direction, but only uses the middle third in the y direction.
        You will probably need to play with these values in order to be 
        able to view the values of the axes on the plot.

        """
        self.axes.set_position(pos)
#+end_src

     We need to override the =OnPaint= event handler to tell the
     =FigureCanvas= to redraw the graph every time the panel is
     redrawn.

#+name: graphpanel_onpaint
#+begin_src python
    def __OnPaint(self,event):
        """An event handler to tell the canvas to draw
        when the panel is redrawn."""
        self.canvas.draw()
        event.Skip()
#+end_src




** Image Panel

   The Image Panel is a custom widget for displaying a 2D array of
   data.  It forms the largest part of the graphical representation
   of the data in PELVis.

*** Image Panel Skeleton

#+begin_src python :tangle ImagePanel.py :noweb tangle :padline no
"""This module contains classes which help in displaying 2D data

This module currently contains one class: ImagePanel.  The imagePanel
takes a 2D array and displays it as a color plot.

"""

import numpy as np

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx import NavigationToolbar2Wx
from matplotlib.figure import Figure
import matplotlib.cm as cm

import wx


if __name__ == "__main__":
    print "Hello World";

class ImagePanel(wx.Panel):
    """This class displays 2D data as a color plot"""
    <<imagepanel_init>>

    <<imagepanel_events>>

    <<imagepanel_update>>


    <<imagepanel_saveImage>>

    <<imagepanel_copytoclipboard>>

#+end_src


*** Initialization

     The panel is constructed with a couple of arguments.  The first
     is simply the parent frame where the image is to be displayed.
     It then takes three callback functions.  The =posFunction=
     callback is called every time the mouse is moved within the
     panel.  The =setMin= function is called every time the user
     performs a left click, which will set the upper left hand corner
     of the region of interest.  Finally, the setMax function is
     called every time the user performs a right click, which should
     set the lower right corner of the region of interest.

#+name:imagepanel_init
#+begin_src python
    def __init__(self,parent,posFunction=None,setMin=None,setMax=None):
        """This creates an ImagePanel
        
        Keyword arguments:
        parent -- The container which will hold the panel
        posFunction -- function to be updated with mouse position
        setMin -- function to be called on left click
        setMax -- function to be called on right click

        """
        wx.Panel.__init__(self,parent)
        self.Bind(wx.EVT_PAINT,self.__OnPaint)
        self.posFunction = posFunction#Function to call on mouse movement
        self.setMin = setMin#Function to call on right click
        self.setMax = setMax#Function to call on left click
#+end_src
     
     The =figure= member is the actual matplotlib graph that displays
     the detector image.  We set it to 512 pixels by 512 pixels, as
     its easier to read than a true 128 pixel by 16 pixel plot. The
     =FigureCanvas= is then the wxWidget which lets us embed the graph
     into the window.  It's provided by the backend_wxagg module from
     matplotlib.

     We bind the mouse events to three private member functions and
     set the default spectrum to =spectral=.

#+name:imagepanel_init
#+begin_src python
    #The figure which holds the graph
        self.figure = Figure(figsize=(1,1),dpi=512)
        #The object where the graph is drawn
        self.canvas = FigureCanvas(self,-1,self.figure)
        self.canvas.Bind(wx.EVT_MOTION,self.__OnMouseMove)
        self.canvas.Bind(wx.EVT_LEFT_UP,self.__OnMouseLeft)
        self.canvas.Bind(wx.EVT_RIGHT_UP,self.__OnMouseRight)
        
        self.cmap = cm.spectral#The color map for the graph
#+end_src

     Finally, the =handlers= member is a dictionary of all of the
     image file formats that wxWidgets knows for file encoding.  If
     wxWidgets adds a new image file format, this dict will need to be
     updated manually, but it's unlikely that they'll add any news
     formats any time soon.

#+name:imagepanel_init
#+begin_src python
    #Known file formats for saving images
        self.handlers={u"BMP":wx.BITMAP_TYPE_BMP,
                        u"JPG":wx.BITMAP_TYPE_JPEG,
                        u"PNG":wx.BITMAP_TYPE_PNG,
                        u"PCX":wx.BITMAP_TYPE_PCX,
                        u"PNM":wx.BITMAP_TYPE_PNM,
                        u"TIF":wx.BITMAP_TYPE_TIF}
#+end_src


*** Event Handling

     When an event occurs, it calls the bound callback function with a
     single =Event= object.  This event contains the information that
     the callback needs to perform its duties (e.g. a mouse click
     event will have the mouse position).  We can either eat the
     event, which is the default, or pass the event on by calling
     =event.Skip=.  This allows the event to trigger multiple
     callbacks.

     There are four events that we need to be able to handle.  The
     simplest one is when the graphics need to be updated.  We force
     the FigureCanvas to draw itself, then pass the event on to any
     other handlers.

#+name:imagepanel_events
#+begin_src python
    def __OnPaint(self,event):
        """Event handler to redraw graph when panel is redrawn."""
        self.canvas.draw()
        event.Skip()
#+end_src

     The =OnMouseMove= function is bound to events triggered by the
     mouse moving through the Image Panel.  The current position on
     the 512 by 512 panel is converted back into the actual pixels in
     the neutron data.

#+name:imagepanel_events
#+begin_src python

    def __OnMouseMove(self,event):
        """Event handler when the mouse moves over the graph"""
        (x,y) = event.GetPosition()
        if self.posFunction is None: return
        self.posFunction(x/32,y/4)
#+end_src

     =OnMouseLeft= is triggered by the user left clicking on the image
     panel.  The position is then converted back to the raw detector
     pixel and passed to the =setMin= function.  =OnMouseRight is
     identical, except the raw position is passed to =setMax=.

#+name:imagepanel_events
#+begin_src python

    def __OnMouseLeft(self,event):
        """Event handler for left clicking on the graph."""
        (x,y) = event.GetPosition()
        if self.setMin is None: 
            None
        else:
            self.setMin(x/32,y/4)
        event.Skip()

    def __OnMouseRight(self,event):
        """Event handler for right clicking on the graph."""
        (x,y) = event.GetPosition()
        if self.setMax is None: 
            None
        else:
            self.setMax(x/32,y/4)
        event.Skip()
#+end_src

     While not strictly an event, the outer PELVis frame has a menu
     event that will call =saveImage= to put the 


*** Data Handling

     The single most important part of the Image Panel is the =update=
     function, which gives the Image Panel the data to display.  It
     expects a 2d array of numbers, as well as a minimum and maximum
     value (i.e. =vmin= and =vmax=) for the range on the numbers.  The
     display is clamped to those values.

     Currently, each pixel is drawn as a solid block of constant
     color.  Changing the =interpolation= parameter of =imshow= from
     ='none'= to ='bicubic'= will create a much smoother transition,
     but it will also be harder to identify the pixel boundaries.

#+name:imagepanel_update
#+begin_src python
    def update(self,data,vmin=10,vmax=20):
        """Change the dataset for the graph

        Keyword arguments:
        data -- 2D numpy array
        vmin -- floor value for graphing
        vmax -- ceiling value for graphing

        """
        self.data=data
        self.figure.clear()
        self.figure.add_axes((0,0,1,1),autoscale_on=True,frameon=False,yticks=[0,1],xticks=[0,1])
        self.figure.get_axes()[-1].get_xaxis().set_visible(False)
        self.figure.get_axes()[-1].get_yaxis().set_visible(False)
        self.figure.get_axes()[-1].imshow(data,cmap=self.cmap,vmin=vmin,vmax=vmax,aspect="auto",interpolation='none')
        self.figure.canvas.draw()
        self.Refresh()
#+end_src


     The =saveImage= function takes the current display of the panel
     and saves it to a file.  As a quick walk through, we begin by
     creating an empty bitmap.  We then create a drawing context on
     top of this bitmap, which allows wxWidgets to treat the bitmap as
     though it were just more pixels on the screen.  We then tell the
     canvas to draw into this context, as opposed to on the screen.
     This buts the actual pixel information into the bitmap.  We then
     take this bitmap, which is hardware dependent on the computer,
     and turn it into a device independent Image.  This image is then
     saved to a file.

#+name:imagepanel_saveImage
#+begin_src python

    def saveImage(self,path):
        """Saves the graph to an image file"""
        bitmap = wx.EmptyBitmap(512,512,24)
        memdc = wx.MemoryDC(bitmap)
        self.figure.canvas.draw(memdc)
        image = wx.Bitmap.ConvertToImage(bitmap)
        image.SaveFile(path,self.handlers[path[-3:].encode('ascii')])
#+end_src

     As similar procedure is used to copy the image into the
     clipboard.  The only difference is that we create a
     =BitmapDataObject= instead of an =Image=, since that's that the
     clipboard expects.

#+name:imagepanel_copytoclipboard
#+begin_src python

    def copyToClipboard(self):
        """Copies the image of the graph to the system Clipboard."""
        if wx.TheClipboard.Open():
            bitmap = wx.EmptyBitmap(512,512,24)
            memdc = wx.MemoryDC(bitmap)
            self.figure.canvas.draw(memdc)
            wx.TheClipboard.Clear()
            wx.TheClipboard.SetData(wx.BitmapDataObject(bitmap))
            wx.TheClipboard.Close()
#+end_src


** Color Bar Panel

   
*** Color Bar Skeleton

    The skeleton for the color bar panel also handles the [[Action Color
    Bar]] and the [[Color Bar Picker]].  All three are used for displaying
    and chosing a maping between an intensity and a color for display
    of the 2D detector data.

#+begin_src python :tangle colorbarpanel.py :noweb tangle :padline no
"""Classes for handling color spectra

This module implements a series of classes for handling the different color
spectra produced by matplot lib.  The basic class is ColorBarPanel, which
simply displays a given color map.  ActionColorbar subclasses ColorBarPanel
to add simple click response abilities.  Finally, ColorBarPicker gives the
user the ability to select any of the color maps that matplotlib is aware of.
Note that ColorBarPicker takes time to render when it first loads, so care
should be taken not to create one unless it's necessary and then to keep
that same on for as long as possible.

"""

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx import NavigationToolbar2Wx
from matplotlib.figure import Figure
from matplotlib.colorbar import ColorbarBase
from matplotlib.colors import Normalize
import matplotlib.cm as cm

import wx

class ColorBarPanel(wx.Panel):
    """Panel to display a ColorBar in a wxWidgets container."""
    <<colorbarpanel_init>>    
    <<colorbarpanel_setrange>>
    <<colorbarpanel_setcmap>>
    <<colorbarpanel_update>>
        
    <<colorbarpanel_onpaint>>

<<actioncolorbar>>

<<colormappicker>>



if __name__ == '__main__':
    def printcmap(cmap):
        print(cmap)

    app=wx.PySimpleApp()
    frame = ColorMapPicker(None,printcmap)
    frame.Show()
    app.MainLoop()

#+end_src

*** Initialization

    The color bar panel takes several parameters

    - parent :: The container for the panel
    - cmap :: A starting color bar for the panel
    - fig :: A tuple containing the dimensions of the panel in
             arbitrary units.  For example, the value of (2,3) would
             make the panel two units tall by three units wide.  The
             default value is (1,10), which fits in with the layout of
             the PELVis frame.
    - res :: The number of pixels per unit in fig.
    - orientation :: The direction along which the color bar's
                     spectrum is encoded.  If the value is the string
                     'vertical', the rainbow will progress from top
                     to bottom.  To have the rainbow move from left to
                     right, set the value to 'horizontal'.
    - size :: By default, matplotlib includes a scale on the color bar
              panel.  This is useful along the axis of the rainbow,
              but rather obviously useless in the other direction.
              The size command picks a subset of the colorbar to
              eliminate the extra axis.

    As with other panels, the general framework is a matplotlib
    =Figure= and a wxAgg =FigureCanvas= to provide the actual graphing
    components. 

#+name:colorbarpanel_init
#+begin_src python
    def __init__(self,parent,cmap,fig=(1,10),
                 res=64,orientation='vertical',
                 size=[0.05,0.025,.25,0.95]):
        """Creates a ColorBarPanel.

        Keyword arguments:
        parent -- container which holds the panel.
        cmap -- the color map to display in the color bar.
                This should be a matplotlib cmap object
        fig -- the relative width to height of the color bar
        res -- the number of pixels per unit in fig
        orientation -- the rotation of the color bar
        size -- the position of the color bar in the panel

        res and size combine to produce the actual size of the
        panel in pixels.  For instance, with fig=(1,10) and res=64,
        the panel will be 64 pixels wide and 640 pixels tall.

        size is a four element array which marks the far
        corners of the graph.  The coordinates are given as a fraction
        of the size of the panel.  For instance, pos=[0,0.3333,1,0.6666]
        would produce a graph that stretches across the panel in the x
        direction, but only uses the middle third in the y direction.
        The default value should allow the axes to be seen.

        """

        wx.Panel.__init__(self,parent)
        self.Bind(wx.EVT_PAINT,self.__OnPaint)

        self.figure = Figure(figsize=fig,dpi=res)#the actual plot
        #the object to display the plot
        self.canvas = FigureCanvas(self,-1,self.figure)
        #the direction of the color bar
        self.orientation=orientation
        #the color map to use
        self.cmap=cmap
        self.vmin=0 #The minimum value on the color bar
        self.vmax=18 #The maximum value on the color bar
        self.size=size #The position of the color bar in the frame
        self.update()

#+end_src

*** Display

    The =update= function replots thecolor bar.  This is necessary
    after any of the parameters have changed.

#+name:colorbarpanel_update
#+begin_src python
    def update(self):
        """Reacts to any changes in the objects members."""
        axes = self.figure.add_axes(self.size)
        norm = Normalize(vmin=self.vmin,vmax=self.vmax)
        colorbar = ColorbarBase(axes,cmap=self.cmap,norm=norm,
                                orientation=self.orientation)
        self.Refresh()
#+end_src

    As with any graphical widget, we need to intercept the OnPaint
    event to ensure that the graph is drawn onto the panel.

#+name:colorbarpanel_onpaint
#+begin_src python
    def __OnPaint(self,event):
        """An event handler to update the graph when the panel is redrawn."""
        self.canvas.draw()
        event.Skip()
#+end_src


*** Configuration

    The =setRange= function choses the domain over which the colarbar
    will map values into colors.

#+name:colorbarpanel_setrange
#+begin_src python
    def setRange(self,vmin,vmax):
        """Set the range for the axes on the colorbar."""
        self.vmin=vmin
        self.vmax=vmax

#+end_src

    The =setCmap= function sets the color map for the panel.

#+name:colorbarpanel_setcmap
#+begin_src python
    def setCmap(self,cmap):
        """Pick the colormap to display."""
        self.cmap = cmap
#+end_src



** Action Color Bar

   The Action Color Bar is a color bar that also functions as a
   button.  The class itself lives in the [[Color Bar Skeleton][colorbar]] module.  It's
   primary purpose is to provide a clickable colorbar for the [[Color Bar Picker][picker]].

#+name:actioncolorbar
#+begin_src python
class ActionColorbar(ColorBarPanel):
    """A simplistic colorbar button

    This class displays a colormap and returns the name of its colormap
    to a given function when clicked on by the user.

    """
#+end_src

   The initialization is much simpler than for the [[Color Bar Panel][Color Bar Panel]].
   - parent :: The container to hold the action color bar
   - cmap :: The actual color map for the color bar
   - command :: The function to be called when the color bar is clicked

#+name:actioncolorbar
#+begin_src python
#
    def __init__(self,parent,cmap,command):
        """Creates an ActionColorbar

        Keyword arguments:
        parent -- the container to hold the panel.
        cmap -- a string naming a colormap.
        command -- the function to run when the colormap is clicked.

        """
        #title attribute is needed by update, which is called by init
        self.title=cmap#The title of the colormap
        ColorBarPanel.__init__(self,parent,cm.get_cmap(cmap),fig=(5,1),orientation='horizontal',size=[0,0,1,0.6])
        self.comm = command#The command to run on clicks
        self.canvas.Bind(wx.EVT_LEFT_UP,self.__OnClick)
#+end_src

   The =update= function is identical to that of the regular Color Bar
   Panel, except that a title has been added to the figure so that
   it's possible to know the name of the color map being clicked.

#+name:actioncolorbar
#+begin_src python
#
    def update(self):
        """Reacts to any changes in the objects members."""
        axes = self.figure.add_axes(self.size,title=self.title)
        norm = Normalize(vmin=self.vmin,vmax=self.vmax)
        colorbar = ColorbarBase(axes,cmap=self.cmap,norm=norm,
                                orientation=self.orientation)
        self.Refresh()
#+end_src

   =__OnClick= is the event handler for when the user left clicks on
   the action bar.  It calls the command using the current color map
   as its only argument.

#+name:actioncolorbar
#+begin_src python
#
    def __OnClick(self,event):
        """Event handler to call self.comm when the panel is clicked."""
        self.comm(self.cmap)
        event.Skip()
#+end_src


** Color Map Picker

   The color map picker is a dialog box which presents all of the
   color maps know to matplotlib and allows the user to chose one by
   clicking on it.

   Since it generates so many graphs (one for each color map), it can
   take quite a while to load.  It's usually only generated the first
   time that the user calls for it and is not regenerated as long as
   the program runs.

#+name:colormappicker
#+begin_src python
class ColorMapPicker(wx.Frame):
    """A window for selecting a color map"""
#+end_src 

   The initialization takes only two parameters.  The first is a
   parent window that the dialog will be attached to.  If the parent
   is =None=, the picker will be the main application window.  The
   second parameter expects a function that takes one string
   argument.  Whenever the user clicks on a color map, this function
   is called on the name of the color map.

   The =cm.datad.keys= function returns a list of all of the color
   maps known to matplotlib.

#+name:colormappicker
#+begin_src python
#
    def __init__(self,parent,command):
        """Creates a ColorMapPicker

        Keyword arguments:
        parent -- parent of this frame or None
        command -- function to be called on the chosen colormap name

        """
        wx.Frame.__init__(self,parent,wx.ID_ANY,"Maps",size=(345,355))
        scroll = wx.ScrolledWindow(self,-1)
        sizer = wx.BoxSizer(wx.VERTICAL)
        keys = cm.datad.keys()
        #Iterate through all of the colormap names
        for key in keys[:]:
            sizer.Add(ActionColorbar(scroll,key,command))
            scroll.SetScrollbars(0,64,0,64)
        sizer.SetSizeHints(scroll)
        scroll.SetSizer(sizer)
        self.Bind(wx.EVT_CLOSE,self.__OnClose)
#+end_src 

   Since the window takes so long to create, we don't want to recreate
   it each time it is called for.  To this end, we're overriding the
   Close event and ignoring it, simply hiding the window instead.

#+name:colormappicker
#+begin_src python
#
    def __OnClose(self,event):
        """Event handler for closing the window

        Since the window takes so long to build and render, we
        don't want to be forces to make a new one each time it's
        closed, so we merely hide it when the user closes it."""
        self.Hide()
#+end_src


** Graph Frame

   The Graph Frame module provides a class for easily displaying 2D
   line plots.  It's used by [[MonFile][MonFile]] and [[Spectrum Dialog]] to give
   information versus wavelength.

   The frame largely serves the same purpose ad
   matplotlib.pyplot.plot, but it works well with the wx backend that
   we're using for the rest of the PelVis application and try to start
   its own main loop.  If you're writing a console application that
   just needs to draw a couple of graphs, you're better off just
   working straight through matplotlib.

*** GraphFrame Skeleton

#+begin_src python :tangle graphframe.py :noweb tangle :padline no
"""Convenience classes for plotting data

This module contains a single class, GraphFrame, which is used for easily
plotting two dimensional data.  If other such convenience classes are
ever to be written, they should be put into this module.

"""

import wx

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx import NavigationToolbar2Wx
from matplotlib.figure import Figure

class GraphFrame(wx.Frame):
    """
    This class merges wxWidgets and matplotlib to produce an 
    independent frame which can display a two dimensional
    plot fo arbitrary data.

    """
    ID_COPY = 500
    <<graphframe_init>>

    def __PanelPaint(self,event):
        """Event handler to tell the canvas to 
        redraw when the window is drawn."""
        self.canvas.draw()
        event.Skip()

    <<graphframe_oncopy>>

    <<graphframe_plot>>

#+end_src

*** Initialization
#+end_src

    The frame begins with two parameters.  The first is a parent
    window, which can be =None= to make this window independent.  The
    second is an optional tital to display in the window's titlebar.

    The constructor begins by performing the basic construction of a
    frame and creating a panel with a custom paint handler. 

#+name:graphframe_init
#+begin_src python
    def __init__(self,parent=None,title=""):
        """Creates a new frame for displaying graphs

        Keyword arguments:
        parent -- the parent frame of the new frame
        title -- the title for the frame.  This is not the title
                 for the graph.

        """
        wx.Frame.__init__(self,parent,wx.ID_ANY,title)

        self.panel = wx.Panel(self)
        self.panel.Bind(wx.EVT_PAINT,self.__PanelPaint)
#+end_src

    We add a menu bar purely to handle the =Copy= command.  We use this
    to allow the user to copy the graph to the clipboard, saving the
    effort of writing the image to a disk and loading it up in another
    application.  Establishing the menu also bounds the copy command
    to the =Ctrl-c= hotkey.

#+name:graphframe_init
#+begin_src python

        menubar = wx.MenuBar()
        editmenu = wx.Menu()
        editmenu.Append(self.ID_COPY,"&Copy\tCtrl-C"," Copy image to the clipboard")
        self.Connect(self.ID_COPY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnCopy)
        menubar.Append(editmenu,"&Edit")
        self.SetMenuBar(menubar)
#+end_src

    We create a matplotlib =Figure= and a wxAgg =FigureCanvas= to
    handle the actual plotting.  The matplotlib wx backend also
    provides a convenient Navigation Toolbar that is identical to the
    one used by =pyplot.plot= and allows the user to scale and
    translate the graph at will.  The toolbar also handles saving the
    image to a file.

#+name:graphframe_init
#+begin_src python
        

        #First, make the plotting figure.
        self.figure = Figure()
        #Then give the figure somewhere to display.
        self.canvas = FigureCanvas(self.panel,-1,self.figure)
        #Finally, make a Toolbar to adjust the canvas at runtime.
        self.toolbar = NavigationToolbar2Wx(self.canvas)
        self.toolbar.Realize()
#+end_src

    Finally, everything is added to the panel and the sizers are set.

#+name:graphframe_init
#+begin_src python

        sizer = wx.GridBagSizer()
        sizer.Add(self.canvas,pos=wx.GBPosition(1,0))
        sizer.Add(self.toolbar,pos=wx.GBPosition(0,0))
        sizer.SetSizeHints(self)
        self.SetSizer(sizer)
#+end_src



*** Image Export

    The =plot= function handles actualling turning data points into a
    graph.

    - x :: An array of the x-coordinates of the data
    - y :: An array of the y-coordinates of the data
    - range :: An optional tuple of the minimum and maximum y values
               to plot.  Useful for handling things like flipping
               ratios, where most of the values will probably be
               around 30, but a low statistics data point out at 18 Å
               will suddenly take the plot up to five million.  If the
               range is =None=, then the graph will auto-scale
    - xerr :: An optional array of the uncertainties on the
              x-coordinates.  If =None=, then no x errorbars are used.
    - yerr :: An optional array of the uncertainties of the
              y-coordinates.  If =None, then no y errorbars are used.

#+name:graphframe_plot
#+begin_src python
    def plot(self,x,y,range=None,xerr=None,yerr=None):
        """Plots 2D data in the frame

        This method is the main workhorse of the class.  It plots
        a line representing the x and y data, with optional errorbars.

        Keyword arguments:
        x -- numpy array of x coordinates
        y -- numpy array of y corrdinates
        range -- either a tuple with the minimum and maximum y values,
                 or None for autoscaling
        xerr -- numpy array of the errors in the x direction
        yerr -- numpy array of errors in the y direction

        """
        self.figure.clear()
        axes = self.figure.add_subplot(111)
        print(x.shape)
        print(y.shape)
        axes.errorbar(x,y,xerr=xerr,yerr=yerr)
        if range==None:
            axes.autoscale_view(True,True,True)
        else:
            (vmin,vmax)=range
            axes.set_ylim(vmin,vmax)
            axes.autoscale_view(True,True,False)
        self.Show()
#+end_src

    The =OnCopy= function is an event handler for the user requesting
    that the graph be copied to the clipboard.  A new bitmap is made
    that is the current size of the canvas.  The figure is then drawn
    onto this bitmap and the bitmap is passed to the clipboard.

#+name:graphframe_oncopy
#+begin_src python
    def OnCopy(self,event):
        """Copies the image of the graph to the system Clipboard"""
        if wx.TheClipboard.Open():
            print(self.canvas.GetSize())
            w,h=self.canvas.GetSize()
            bitmap = wx.EmptyBitmap(w,h,24)
            memdc = wx.MemoryDC(bitmap)
            self.figure.canvas.draw(memdc)
            wx.TheClipboard.Clear()
            wx.TheClipboard.SetData(wx.BitmapDataObject(bitmap))
            wx.TheClipboard.Close()
#+end_src



** Spectrum Dialog

   The Spectrum Dialog presents a dialog box to the user which
   presents the user options on what they would like to do with the
   spectrum information passed by PELVis.  The information can be
   given custom wavelength binning and either plotted to the screen or
   saved in an ASCII file.

*** Spectrum Dialog Skeleton

#+begin_src python :tangle SpectrumDialog.py :noweb tangle :padline no
"""Classes for dealing with neutron spectra

This module contains a single class:  SpectrumDialog.  This dialog
handles all of the options and parameters for creating spectrum
plots of intensities and polarization.  This class also handles
automated rebinning of data.

"""

import wx
import numpy as np
from graphframe import GraphFrame

RESOLUTION = 400

class SpectrumDialog(wx.Dialog):
    """A dialog to set the options on a spectrum plot"""

    <<spectrumdialog_init>>
    <<spectrumdialog_setdata>>
    <<spectrumdialog_setscale>>
    <<spectrumdialog_setintensityrange>>

    <<spectrumdialog_onview>>

    <<spectrumdialog_onsave>>

    <<spectrumdialog_setmode>>

    def autobinset(self):
        """Rebins both up and down data based on the user's chosen error."""
        x=[]
        u=[]
        d=[]
        count=0 #number of channels combined since last binning
        utot=0 #counts in the up state
        dtot=0 #counts in the down state
        #If there's no chosen error bounds, just return the original data.
        if self.nobinrad.GetValue():
            return (np.arange(0.0,RESOLUTION)*20.0/RESOLUTION
                    ,self.up,self.down)
        #If we're going any sort of binning, we'll need raw values
        up=self.up*self.uscale
        down=self.down*self.dscale
        #Check for autobinning
        if self.autobinrad.GetValue():
            #The maximum percentage error in the spin up or spin down state
            emax = float(self.minerr.GetValue())/100.0
            for i in range(len(self.up)):
                utot += up[i]
                dtot += down[i]
                uerr = 1.0/np.sqrt(utot)#error in the up state
                derr = 1.0/np.sqrt(dtot)#error in the down state
                #if the error is below the threshold, add the new data point
                if uerr <= emax and derr <= emax:
                    u.append(utot/self.uscale)
                    d.append(dtot/self.dscale)
                #choose x as the center of the binned data
                    x.append((i-0.5*count)*20.0/RESOLUTION)
                    i = 0
                    utot=0
                    dtot=0
                    count=0
                else:
                    count += 1
            return (np.array(x),
                    np.array(u),
                    np.array(d))
        elif self.setbinrad.GetValue():
            count = int(self.minerr.GetValue())
            x = [np.mean(y) for y in 
                 np.array_split(np.arange(0.0,RESOLUTION)*20.0/RESOLUTION,count)]
            u = [np.sum(y)/self.uscale for y in np.array_split(up,count)]
            d = [np.sum(y)/self.dscale for y in np.array_split(down,count)]
            #print((x,u,d))
            return (np.array(x),
                    np.array(u),
                    np.array(d))
        else:
            raise RuntimeException("Need to Implement bullet choice!")

    def autobin(self,up,scale):
        """Rebins one data array based on the user's chosen error

        Keyword arguments:
        up -- the array to be rebinned
        scale -- the conversion factor used to normalize against monitor

        """
        if self.nobinrad.GetValue():
            return (np.arange(0.0,RESOLUTION)*20.0/RESOLUTION,up/scale)
        elif self.autobinrad.GetValue():
            x=[]
            u=[]
            count=0
            utot=0
            #The maximum percentage error in the spin up or spin down state
            emax = float(self.minerr.GetValue())/100.0
            for i in range(len(self.up)):
                utot += up[i]
                uerr = 1.0/np.sqrt(utot)
                if uerr < emax:
                    u.append(utot/scale/(count+1))
                    x.append((i-0.5*count)*20.0/RESOLUTION)
                    count = 0
                    utot=0
                else:
                    count += 1
            return (np.array(x),np.array(u))
        elif self.setbinrad.GetValue():
            count = int(self.minerr.GetValue())
            x = np.arange(0.0,RESOLUTION)*20.0/RESOLUTION
            x = np.array([np.mean(y) for y in np.array_split(x,count)])
            u = np.array([np.sum(y)/scale for y in np.array_split(up,count)])
            return (x,u)

    def flipping(self):
        """Calculate the flipping ratio"""
        if self.down is not None:
            (x,u,d)=self.autobinset()
            y = u/(d+1e-6)
            uerr = np.sqrt(u*self.uscale)/self.uscale
            derr = np.sqrt(d*self.dscale)/self.dscale
            e = y*np.sqrt((uerr/u)**2+(derr/d)**2)
            #e = y * np.sqrt(1/(u + 1e-6)+1/(d + 1e-6))
            return (x,y,e)

    def polar(self):
        """Calculate the polarization"""
        if self.down is not None:
            print "Polar Spectrum"
            (x,u,d)=self.autobinset()
            #print((x,u,d))
            y = (u-d)/(u+d)
            uerr = np.sqrt(u/self.uscale)
            derr = np.sqrt(d/self.dscale)
            e = 2*np.sqrt(u**2*derr**2+d**2*uerr**2)/(u+d)**2
            #e = nerr/n*(1+abs(y))
            return (x,y,e)

    def spinUp(self):
        """Calculate the spin up intensity"""
        (x,y)=self.autobin(self.up*self.uscale,self.uscale)
        return (x,y,np.sqrt(y*self.uscale)/self.uscale)

    def spinDown(self):
        """Calculate the spin down intensity"""
        if self.down is not None:
            (x,y)=self.autobin(self.down*self.dscale,self.dscale)
            return (x,y,np.sqrt(y*self.dscale)/self.dscale)


#+end_src

*** Initialization

    The only parameter for the constructor on the SpectrumDialog is
    the parent frame for the dialog.  The constructor begins by
    calling the constructor of its superclass to make the actual
    dialog box.

#+name:spectrumdialog_init
#+begin_src python
    def __init__(self,parent=None):
        """Create a SpectrumDialog"""
        wx.Dialog.__init__(self,parent,wx.ID_ANY,"Spectrum Options")
        sizer = wx.GridBagSizer()
#+end_src

    The class has two members for the data.  =up= is the count of the
    neutrons per wavelength bin in the spin up state and and =down= is
    the count of the neutrons per wavelength bin in the spin down state.

#+name:spectrumdialog_init
#+begin_src python
    #
        self.up = None #The spin up data array
        self.down = None #The spin down data array
#+end_src

    The =mode= member is a dictionary to convert between a mode string
    sent by the application and the function which handles that form
    of data.  The =calSpec= function should point to the current
    processing function.

#+name:spectrumdialog_init
#+begin_src python
    #

        #A dictionary of the available manipulations to perform
        #on the data before plotting it.
        self.modes = {"up":self.spinUp,
                      "down":self.spinDown,
                      "polar":self.polar,
                      "flipping":self.flipping}
        self.calcSpec = self.spinUp #The current data manipulation function
#+end_src

    Two buttons are added to the bottom of the dialog to allow the
    user to either view the image on the screen or save the data to an
    ASCII file.

#+name:spectrumdialog_init
#+begin_src python
    #
        
        saveButton = wx.Button(self,-1,"Save Spectrum")
        viewButton = wx.Button(self,-1,"View Spectrum")
        viewButton.Bind(wx.EVT_BUTTON,self.onView)
        saveButton.Bind(wx.EVT_BUTTON,self.onSave)
#+end_src

    A single text box is added with the label "Minimum Percent
    Error".  This label is horribly misleading and should be changed.
    In auto-binning mode, it does allow the user to input the minimum
    percentage error.  However, in fixed binning mode, the value is
    used to the maximum number of bins.

#+name:spectrumdialog_init
#+begin_src python
    #
        
        sizer.Add(wx.StaticText(self,-1,"Minimum Percent Error"),
                  pos=wx.GBPosition(0,0), flag=wx.EXPAND)
        #An input box for the user's chosen percentage error
        self.minerr = wx.TextCtrl(self,-1,"10")
        sizer.Add(self.minerr,pos=wx.GBPosition(0,1), flag=wx.EXPAND)
#+end_src

    Three radio buttons allow the user to pick the binning mode.

#+name:spectrumdialog_init
#+begin_src python
    #    

        #A checkbox for whether the user wants the data autobinned
        self.nobinrad = wx.RadioButton(self,-1,"Raw Data",style=wx.RB_GROUP)
        self.autobinrad = wx.RadioButton(self,-1,"Auto binning")
        self.setbinrad = wx.RadioButton(self,-1,"Fixed Binning")
#+end_src

    Finally, everything needs to be added to the actual panel

#+name:spectrumdialog_init
#+begin_src python
    #
        sizer.Add(self.nobinrad,wx.GBPosition(1,0),flag=wx.EXPAND)
        sizer.Add(self.autobinrad,wx.GBPosition(1,1),flag=wx.EXPAND)
        sizer.Add(self.setbinrad,wx.GBPosition(1,2),flag=wx.EXPAND)
        
        sizer.Add(saveButton,pos=wx.GBPosition(2,0),flag=wx.EXPAND)
        sizer.Add(viewButton,pos=wx.GBPosition(2,1),flag=wx.EXPAND)
        sizer.SetSizeHints(self)
        self.SetSizer(sizer)

#+end_src



*** Configuration

    The =setData= function gives the actual neutron count arrays to
    the Spectrum Dialog.  If there is only one spin state, it is put
    in the =up= member and the =down= member is set to none.  Since
    both arrays are supposed to represent neutron counts, we set any
    data points less than zero equal to zero, since you can't have a
    negative count.  This prevents issues like having the polarization
    go above one or the flipping ratio being negative.

#+name:spectrumdialog_setdata
#+begin_src python
    def setData(self,up,down=None):
        """Sets the spin up and spin down spectra.  Expects two numpys arrays"""
        del self.up
        del self.down
        up[up < 0.0] = 0.0
        if down is not None:
            down[down < 0.0] = 0.0
        self.up=up
        self.down=down
#+end_src

    The array received by =setData= are normalized to monitor count.
    The uscale and dscale variables are the total monitor counts in
    the up and down states, respectively.  This allows us to recover
    the raw counts so that we can calculate the uncertainties from the
    counting statistics.

#+name:spectrumdialog_setscale
#+begin_src python
    def setScale(self,up,down=None):
        """Sets the scaling constants for the spin up and spin down states.

        To calculate error, we need the raw neutron counts, not just the
        monitor normalized ones.  This function accepts the monitor counts
        used to do the initial scaling on the detector data, so that
        the raw counts can be recalculated.

        """
        self.uscale=up
        self.dscale=down
#+end_src

    When the data is being plot, it can be helpful to clamp the range
    of the plot.  The =setIntensityRange= function accepts a tuple
    with the minimum and maximum values for the plot range.

#+name:spectrumdialog_setintensityrange
#+begin_src python
    def setIntensityRange(self,range):
        """Set the minimum and maximum y axis for plotting"""
        self.vmin,self.vmax = range
#+end_src

    Currently, the spectrum dialog supports plotting the spin up
    intensity, the spin down intensity, the polarization, and the
    flipping ratio, all versus wavelength.  The =setmode= function
    choses the mode with one of the keys of the =modes= member and
    adjust =calcSpec= accordingly.

#+name: spectrumdialog_setmode
#+begin_src python
    def setMode(self,mode):
        """Chooses the calculation to perform on the data

        Keyword arguments:
        mode -- a string describing which function out of self.modes
                should be performed on the data.

        """
        self.calcSpec = self.modes[mode]
#+end_src


*** Buttons

    The =onView= function is called when the user clicks on the =View=
    button.  The actual data to plot is calculated by the =calcSpec=
    function and then displayed by a [[Graph Frame][GraphFrame object]].

#+name: spectrumdialog_onview
#+begin_src python
    def onView(self,event):
        """Display a graph of the spectrum."""
        x,y,e = self.calcSpec()
        graph = GraphFrame(self,"Spectrum")
        graph.plot(x,y,range=(self.vmin,self.vmax),yerr=e)
        self.Show(False)
#+end_src


    The =onSave= function is called when the user clicks on the =Save=
    button.  The actual data to plot is calculated by the =calcSpec=
    function and then written to a file of the user's choice.  The
    file writing routine should probably be replaced by a numpy
    savetxt function.

#+name: spectrumdialog_onsave
#+begin_src python
    def onSave(self,event):
        """Save a graph of the spectrum to a file."""
        x,y,e = self.calcSpec()
        dialog=wx.FileDialog(self,"Name the spectm file",
                             wildcard="ASCII (dat)|*.dat",
                             style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
        if dialog.ShowModal()==wx.ID_OK:
            with open(dialog.GetPath(),"w") as stream:
                for i in range(len(x)):
                    stream.write("%f\t%f\t%f\n"%(x[i],y[i],e[i]))
        self.Show(False)
#+end_src


* Utility Classes

  This section is for libraries which are used by more than one part
  of the system.  These are usually the modules which read and write
  data files, as they are needed by both the GUI and command line applications.
** Reader

   The =reader= module handles reading and interpreting neutron event
   files.  It's main purpose is to take a data file, which is a binary
   record of events, and turn it into a histogram of events in space
   and time.

*** Reader Skeleton

#+begin_src python :tangle reader.py :noweb tangle :padline no
"""This module contains classes for reading PEL files

This module contains a single class: PelFile.  This class reads the header
information and neutron data saved in PEL files.  more information about
the format of these files can be found in the Lexitech PAPA Software Manual.

"""

import __future__

import struct
#import re
import numpy as np

from time import clock
from collections import namedtuple

RESOLUTION = 400

<<reader_mapim>>

class PelFile:
        """Handles the data stored in PEL files"""
        data = np.ndarray(shape=(0),dtype=np.int64)#Raw detector data

        <<reader_pelfile_init>>                

        <<reader_pelfile_parseHeader>>
        <<reader_pelfile_convertTime>>
        <<reader_pelfile_make3d>>
        <<reader_pelfile_spectrum>>
                

        <<reader_pelfile_statusfunc>>
        <<reader_pelfile_getgains>>


        <<reader_pelfile_readfileimage>>

        <<reader_pelfile_make1d>>
#+end_src
    
    There's some old test code for running the reader by itself.  This
    code is old, out of date, and should be  removed.
    
#+begin_src python :tangle reader.py :noweb tangle :padline no                

if __name__=="__main__":
        data = PelFile()
        
        data.readfileimage("C:/Documents and Settings/adlwashi/Desktop/20091102101415-AM12.pel")
        print("Read File")
        data.spectrum("spectrum.txt")
        #print("Reverse Grey")
        #data.reverseGrey()
        #temp = set([data.fullGrayCode(i) for i in range(512)])
        #for i in temp:
        #        print "%03o" % i
        #print(len(temp))

#+end_src


*** Image Mapping

    The TOF for each event is given as a count since the T_0 pulse,
    where the each count is 100ns.  The convertTime function takes a
    numpy array of counts and turns it into a wavelength into a
    wavelength bin, where the bins are spaced by =20/RESOLUTION=.  For
    instance, if RESOLUTION is 200 and the neutron has a 2 Angstrom
    wavelength, then the bin is 20.

    The relationship between TOF and wavelength is controlled almost
    completely by the variables =distanceToG4= and
    =distanceToDetector=.  This sum should be the distance, in meters,
    from the neutron moderator to the Helium-3 detector.  The
    =distanceToG4= variable is based on Jak doskow's drawings on how
    far it should be from the neutron moderator to the exit of G4.
    The actual distance to the detector can then be measured with a
    tape measure.

    According to Dave Baxter's measurements, there is an 860us delay
    between the T0 signal and when the neutrons first start coming out
    of the moderator.  This value is subtracted off of the times to
    compensate.  This value should be checked occasionally to make
    sure that it has not changed.  If you are seeing neutrons with
    negative wavelengths, or if the proton pulse is not occuring at
    zero angstroms, then this value needs to be changed.  The best way
    of checking it is via the neutron monitor, as the proton flash is
    quite visible in the output and the results are given in 50
    microsecond bins.

<<convertTime>>
#+name:reader_pelfile_convertTime
#+begin_src python
        #Remember to use in-place operations to save on memory overhead
        def convertTime(self,timearr):
                """Convert an array of TOF data into neutron wavelengths."""
                #convert timearr into microseconds
                timearr *= 0.1 #Convert to microseconds
                #convert timearr into wavelength
                distanceToG4 = 3.7338+2.5297
                distanceToDetector = 3.835 #FIXME
                timearr -= 860
                timearr *= 3.956034e-7/(distanceToDetector+distanceToG4)/1e-10*1e-6*(RESOLUTION/20) #The last term is to handle fractional angstroms
                return timearr
#+end_src


     The SNS software for the Helium-3 detector returns a set of
     events.  Each even has a channel number, the distance along the
     channel, and a time of flight.  However, each channel on our
     detector has two tubes in series.  Thus, we need to convert the
     position on the channel to the position on the tube and assign
     the data to the right tube.

     Paul wrote this code and it has some idiosyncratic behavior.  For
     example, the test of 
: 0.5*ti!=int(0.5*ti)
     is really just a test to see if ti is odd or even.  It should
     probably be replaced with a simple
: ti%2==1
     which returns the same result for all values.  In fact, I have a
     sneaking suspicion that the entire thing can be done through
     numpy, eliminating the need for slow python loops, but I haven't
     proved it yet.

     The function takes a single input value, which is a 2D array of
     neutron counts with dimensions =XDIM= x =YDIM=.  It returns an array
     with dimensions =XDIMM= and =YDIMM=.  The =ZPAD= variable is used
     to account for dead pixels at the top or bottom of the tubes.
     The =maparray= variable gives the order of the tubes on the
     detector.  This has been found by calibration, but it should be
     checked periodically (e.g. biennially) to ensure that it's still accurate.

<<mapim>>
#+name:reader_mapim
#+begin_src python
def mapim(imarray):
    XDIM=8
    YDIM=256
    XDIMIM=16
    YDIMIM=128
    ZPAD=0
#    maparray=[2, 15, 1, 16, 4, 13, 3, 14, 6, 11, 5, 12, 8, 9, 7, 10]
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]#Old July 2013
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 14, 10, 13, 12, 9, 11, 16, 15]# SESANS October 2013
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 14, 10, 13, 12, 9, 11, 16, 15]# SESANS July 2013
    maparray =[4, 3, 1, 2, 6, 5, 15, 16, 8, 13, 7, 14, 10, 11, 9, 12] # From tube mapping October 2013
    #    maparray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
#    maparray = [12, 9, 11, 14, 10, 7, 1, 2, 3, 4, 5, 6, 8, 13, 15, 16]
#    maparray =[2, 1, 4, 3, 6, 15, 5, 16, 8, 7, 13, 14, 11, 12, 9, 10]
#    maparray =[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    newimarray=np.zeros((YDIMIM+ZPAD,XDIMIM))
    for i in range(len(maparray)):
        ti=maparray[i]
        if 0.5*ti!=int(0.5*ti):
           for j in range(YDIMIM):
                tj=j
                if ti<9:
                    newimarray[j+ZPAD,i]=imarray[YDIMIM-1-tj,(ti-1)/2]
                else:
                    newimarray[j,i]=imarray[YDIMIM-1-tj,(ti-1)/2]
        else:
            for j in range(YDIMIM):
                tj=j+YDIMIM
                if ti<9:
                    newimarray[j+ZPAD,i]=imarray[tj,ti/2-1]
                else:
                    newimarray[j,i]=imarray[tj,ti/2-1]
    return newimarray
#+end_src


     The make3D function is the primary function for turning an array
     of neutron events into a histogram of events versus position and
     wavelength.

     The data type is 64 bits per event.  The first 32 bits are the
     TOF information, which can be turned into a wavelength by the
     [[convertTime]] function.  The next 32 bits are the position
     information.

     We begin by setting some default variables.  The =statusfunc= is
     a function that can be called with the current progress on
     loading the file.  It expects a value between 0 and 1000, where 0
     is having just started and 1000 means that the process is
     complete.  The =cube= variable is the actual 3D array of neutron
     events.  If there is no data in the file, we can immediately
     return an empty array.
     
#+name:reader_pelfile_make3d
#+begin_src python
  def make3d(self):
          """Make a 3D histogram from the raw data."""
          start=clock()                
          statusfunc = self.statusfunc
          l = len(self.data)
          sd =self.data
          i=0;
  
          cube = np.zeros([128,16,RESOLUTION],dtype=np.float32)
  
          #If there's no data, return an empty array
          if l==0:
                  return cube
#+end_src

     The 64-bit events are broken down into the 32-bit array of
     position information, =Z=, and the 32-bit array of the time
     information, =timearr=.  The time information is then converted
     into a wavelength bin.

#+name:reader_pelfile_make3d
#+begin_src python
  #
          Z = self.data[1::2] & 0xFFFF#position data
  
          timearr = self.convertTime(np.asarray(self.data[0::2], \
                                                dtype=np.float64))#time data
          timearr = np.asarray(np.floor(timearr),np.uint16)
#+end_src

     a lot of this code used to purely work with integers.  As such,
     numpy was set to [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html][raise an exception on integer overflow]].  This is
     largely unnecessary now and could probably be removed.

#+name:reader_pelfile_make3d
#+begin_src python          
  #
          #Loop over 20 angstroms in steps of 0.1 angstroms
          np.seterr(over='raise')
  #+end_src

     It's possible to run the entire histogram calculation in a single
     numpy call, which would actually be faster than the code below.
     The problem is that the entire application would hang while the
     calculation was performed, which leaves you wondering if
     everything just crashed.  This slower version was implemented,
     since it was easier to put in feedback as to how much time would
     be left.

     The function cycles through each time of flight bin.  The =place=
     variable stores the indexes of events which fall into this time
     of flight bin.  If there are any such events, then their position
     information is histogrammed into a 1D array.  This array can then
     be converted into a 2D array, since we know the number of
     channels and the number of points per channel.  Finally, the
     [[mapim]] function takes the point and channel numbers and returns a
     2D array of position information.  Finally, this array is copied
     into the appropriate wavelength bin in the =cube= array.

#+name:reader_pelfile_make3d
#+begin_src python
  #
          for i in range(RESOLUTION):
                  place = np.where(timearr==i)
                  if len(place[0]) > 0:
                          temp,_ = np.histogram(Z[place],bins = \
                                                np.arange(8*256+1))
                          temp = temp.reshape(256,8,order="F")
                          cube[:,:,i] = mapim(temp)[::-1,:]
                  statusfunc(i*1000.0/RESOLUTION)
                          
  
          stop=clock()
          del timearr
  
          return cube
  
#+end_src

     The =spectrum= member of the =PelFile= class allows the
     wavelength spectrum of the entire file to be export to a text
     file.  This code is old, unused, unmaintened, and poorly
     written.  It should be deleted soon.

#+name:reader_pelfile_spectrum
#+begin_src python
        def spectrum(self,output):
                """Save the neutron spectrum to a text file"""
                with open(output,'w') as of:
                        timearr = (self.data >> 32) & 0x7FFFFFFF
                        timearr = self.convertTime(timearr)
                        timearr /= 10

                        #Get the spectrum and wavelengths
                        (spec,lmbda) = np.histogram(timearr,bins = \
                                                    np.arange(2.0,50.0,0.1))
                        hist = np.column_stack((lmbda[1:],spec))
                        for point in hist:
                                of.write("%f %i\n" % (point[0],point[1]))
                        of.close()
                        return (spec,lmbda)
#+end_src

     Many of the command line applications want to have the wavelength
     spectrum without worrying about the position information.
     =make1d= is the obvious analog of =make3d=.  It takes as
     parameters two tuples of the minimum x and y values as well as
     the maximum x and y values.  It will also take an optional 2D
     array of booleans to indicate which pixels should be ignored.
     The function then returns an array of the total neutron counts
     per wavelength bin over the requested area of the detector.

     Note that this code creates the full 3D histogram, then flattens
     it down to a 1D array.  It'd be far more efficient to just create
     the single array.  If you're looking to speed up make3d, it might
     be a good idea to start with make1D and continue from there.

#+name:reader_pelfile_make1d
#+begin_src python
        def make1d(self,mins,maxs,mask=None):
                """Make a 1D histogram from the spectrum data."""

                c = self.make3d()
                if mask is None:
                    xmin,ymin = mins
                    xmax,ymax = maxs
                    c = c[ymin:ymax,xmin:xmax]
                else:
                    c[np.logical_not(mask)] = 0
                return np.sum(np.sum(c,axis=0,dtype=np.float64()),axis=0)
#+end_src



*** Initialization

    The constructor for the PelFile doesn't need to do much other than
    load a file passed as a parameter.  If there is no file, we don't
    want to do anything.
    
#+name: reader_pelfile_init
#+begin_src python

        def __init__(self,file=""):
                """Create a PelFile"""
                if(file!=""):
                        self.readfileimage(file)

#+end_src

    The PelFile comes with a defautl status function that doesn't do
    anything.  This allows for PelFile to be manipulated without
    needing to hook them into a framework to process the update
    callbacks.

#+name: reader_pelfile_statusfunc
#+begin_src python
        def statusfunc(self,x):
                """Status update function

                This function is called to tell other program components
                the progress in loading the PelFile.  The progress is given
                on a scale of 0 to 1000.  This function should be overwritten
                by whatever function is loading the pel file to do what it
                needs with the load time information.

                """
                return
#+end_src
    

*** File Reading

    The original PEL file format used by the PAPA detector included a
    256 byte header with metadate about the detector status during the
    run.  This function would parse that information into a Python
    [[https://docs.python.org/2/library/collections.html][namedTuple]], which is fairly similar to a standard struct.  With
    the new Helium-3 detector, this code is no longer necessary or
    useful.  It should not be called and could probably be deleted.

#+name:reader_pelfile_parseHeader
#+begin_src python
  
  def parseHeader(self,bytes):
          """Turn the Pel file header into structured data"""
          Header = namedtuple(
                  'Header',
                  "pel endian FileMajVer FileMinVer BytesPerSample " +
                  "SysHealth AppMajVer AppMinVer AppBetaVer LensPos " +
                  "DetectorName ProductNumber BitsPerCoord CanEnergy " +
                  "CanTime ADclockFrequ FirmMajVer FirmMinVer FirmBeta Serial " +
                  "AcquisitionMode CanAcqMode Shutter " +
                  "PAPAPowerSupplyVoltageCommand " +
                  "PAPAPowerSupplyVoltageCommandGain " +
                  "PAPAPowerSupplyVoltageCommandOffset " +
                  "PAPAPowerSupplyControlVoltageCommandGain " +
                  "PAPAPowerSupplyControlVoltageCommandOffset " +
                  "PAPAPowerSupplyVoltageEnable " +
                  "EnergyPowerSupplyVoltageCommand " +
                  "EnergyPowerSupplyVoltageCommandGain " +
                  "EnergyPowerSupplyVoltageCommandOffset " +
                  "EnergyPowerSupplyControlVoltageCommandGain " +
                  "EnergyPowerSupplyControlVoltageCommandOffset " +
                  "EnergyPowerSupplyVoltageEnable " +
                  "MCPPowerSupplyVoltageCommand " +
                  "MCPPowerSupplyVoltageCommandGain " +
                  "MCPPowerSupplyVoltageCommandOffset " +
                  "MCPPowerSupplyControlVoltageCommandGain " +
                  "MCPPowerSupplyControlVoltageCommandOffset " +
                  "MCPPowerSupplyVoltageEnable " +
                  "x1Gain x2Gain x3Gain x4Gain x5Gain x6Gain x7Gain x8Gain x9Gain x10Gain " +
                  "y1Gain y2Gain y3Gain y4Gain y5Gain y6Gain y7Gain y8Gain y9Gain y10Gain " +
                  "strobeGain EnergyGain ThresholdGain "+
                  "ADVoltageOffset ADAOffset ADBOffset ADCOffset ADDOffset "+
                  "StrobeTriggerMin StrobeTriggerMax StrobeEndEventFrac " +
                  "EnergyTriggerMin EnergyTriggerMax EnergyEndEventFrac " +
                  "ADAFillSampleIntervalLength ADDFillSampleIntervalLength " +
                  "GateCapturePolarity TimerResetEdgePolarity " +
                  "LeadTimer LagTimer Gray BitShift " +
                  "TemperatureSetPoint1 TemperatureSetPoint2 " +
                  "KP1 KP2 KI1 KI2 KD1 KD2 Temperature1 Temperature2 " +
                  "StrobePulseWidth " +
                  "Year Month Day Hour Minute Second")
  
  
          format = "4s" #header
          format += " ?" #endian  Note that this is currently ignored
          (pelstring,endian) = struct.unpack(format,bytes[0:5])
  
          if endian:
                  format = ">" #big endian
          else:
                  format = "<" #little endian
          format += "4s ?" #header and endian
          format += "B" #Major version
          format += "B" #Minor Version
          format += "B" #Bytes per sample
          format += "B" #System Health
          format += "B" #Application Software Major Version
          format += "B" #Application Software Minor Version
          format += "B" #Application Software Beta Version
          format += "H" #Lens focus position
          format += " 40s " # Detector Name
          format += "H" # Product Number
          format += "B" # Bits per coordinate
          format += "B" #Detector Energy Capability
          format += "B" #Detector Timing Capability
          format += "H" #AD Clock Frequency
          format += "B" #Firmware Major Version
          format += "B" #Firmware Minor Version
          format += "B" #Firmware Beta Version
          format += "H" #Serial Number
          format += "B" #Acquisition Mode
          format += "I" #Acquisition Mode Capability
          format += "B" #Shutter State
          format += "H" #PAPA PMT power supply voltage command
          format += "H" #PAPA PMT power supply voltage gain
          format += "H" #PAPA PMT power supply voltage command offset
          format += "H" #PAPA PMT power supply control voltage command gain
          format += "H" #PAPA PMT power supply control voltage command offsert
          format += "B" #PAPA PMT power supply voltage enable
  
          format += "H" #Energy PMT power supply voltage command
          format += "H" #Energy PMT power supply voltage gain
          format += "H" #Energy PMT power supply voltage command offset
          format += "H" #Energy PMT power supply control voltage command gain
          format += "H" #Energy PMT power supply control voltage command offsert
          format += "B" #Energy PMT power supply voltage enable
          format += "H" #Intensifier MCP power supply voltage command
          format += "H" #Intensifier MCP power supply voltage gain
          format += "H" #Intensifier MCP power supply voltage command offset
          format += "H" #Intensifier MCP power supply control voltage command gain
          format += "H" #Intensifier MCP power supply control voltage command offsert
          format += "B" #Intensifier MCP power supply voltage enable
          format += " 10H " #X Channel gains
          format += " 10H " #Y Channel gains
          format += "H" #Strobe PMT Channel Gain
          format += "H" #Energy PMT Channel Gain
          format += "H" #Threshold Channel Gain
          format += "H" #AD Voltage Offset
          format += "H" #AD Channel A Offset
          format += "H" #AD Channel B Offset
          format += "H" #AD Channel C Offset
          format += "H" #AD Channel D Offset
          format += "H" #PAPA Strobe Trigger min
          format += "H" #PAPA Strobe Trigger max
          format += "H" #PAPA Strobe end event fraction
          format += "H" #Energy Trigger min
          format += "H" #Energy Trigger max
          format += "H" #Energy end event fraction
          format += "B" #AD A filter sample interval length
          format += "B" #AD D filter sample interval length
          format += "B" #Gate Capture Polarity
          format += "B" #Timer reset edge Polarity
          format += "H" #Coincidence lead timer
          format += "H" #Coincidence lag timer
          format += "B" #Gray to binary conversion adder
          format += "B" #Binary big shift
          format += " 2H " #Zone temperature set point
          format += " 2H " #Zone KP Gain
          format += " 2H " #Zone KI Gain
          format += " 2H " #Zone KD Gain
          format += " 2H " #Zone temperature
          format += "H" #strobe pulse width
          format += "39x" #unused
          format += "H" #Year
          format += "H" #Month
          format += "H" #Day
          format += "H" #Hour
          format += "H" #Minute
          format += "H" #Second
          header = Header._make(struct.unpack(format,bytes))
          return header
  
#+end_src

    The =getgains= function returns the signal amplification on the
    photomultiplier tubes used to position detection on the PAPA
    detector.  This is useful for trying to set the gains on the PMTs
    automatically. If the data is coming from the Helium-3 detector, then
    this function is worthless.

#+name:reader_pelfile_getgains
#+begin_src python
        def getgains(self,h):
                """Pulls the PMT gains information into a numpy array"""
                return np.array([h.x1Gain,h.x2Gain,h.x3Gain,h.x4Gain,h.x5Gain,h.x6Gain,h.x7Gain,h.x8Gain,h.x9Gain,h.x10Gain,
                        h.y1Gain,h.y2Gain,h.y3Gain,h.y4Gain,h.y5Gain,h.y6Gain,h.y7Gain,h.y8Gain,h.y9Gain,h.y10Gain],np.double)
#+end_src

    The =readfileimage= member loads the raw events from the data file
    straight into memory.

#+name:reader_pelfile_readfileimage
#+begin_src python
        def readfileimage(self,path):
                """Reads a raw Pel File into memory."""
                start=clock()
                statusfunc = self.statusfunc
                with open(path,"rb") as infile:
                    #self.header = self.parseHeader(infile.read(256))
                    #Raw File has no header
                    #point = infile.read(8)
                    self.data = np.fromfile(infile,np.int32,-1)
                infile.close()
                stop=clock()
#+end_src

** MonFile

   The =MonFile= class is used to read the files produced by the SNS
   beam monitor software.

*** MonFile Skeleton

    The monfile package mostly consists of the MonFile class.  There
    are, however, a couple of notes which are non-intuitive.  First,
    monfile imports graphframe, so it's not suited for use on a
    headless system.  In practice, that's not a big deal, but you
    should be aware of it.  Also, monfile is one of the oldest parts
    of PELVis and has quite a bit of cruft.  For instance, it imports
    pylab, but it never uses it.  (That's probably a good thing, as you
    shouldn't use pylab.)  I'll try to comment on the cruft as I pass
    through, but you should pay attention.

#+begin_src python :tangle monfile.py :noweb tangle :padline no
"""Classes for dealing with neutron monitor data

This module contains a single class: MonFile.  This class is used to read
the time, intensity, and spectrum information out of a file produced
by the SNS's BMM_server

"""

import numpy as np
import re
import scipy.interpolate as ip
import scipy.optimize as op
import matplotlib.pyplot as pyplot
from graphframe import GraphFrame
import pylab as pl
import math

class MonFile:
    """Manages a file which holds neutron monitor data."""
    KbT = 2.0e-3
    
    <<monfile_init>>

    <<monfile_converttime>>

    def func(self, x, A, b, k, c):
        return A*x**2 * np.exp(-(x-k)**2*b) + c

    <<monfile_load>>
#+end_src

*** Initialization

    The constructor has two, optional parameters.  The first is a file
    name, which can cause that file to be loaded into memory.  The
    second is a boolean which declares whether we want a graph of the
    monitor spectrum to be displayed on the screen.

    The constructor declares two members.  The first is =time=, which
    is no longer used.  Under the old PAPA data collection system, the
    monitor files were stored in ASCII format and included the run
    time in microseconds.  This information could then be used for certain kinds
    of background subtraction and normalization.  However, the monitor
    files produces by the SNS software are binary arrays of floating
    points and do not have the time information, so it is no longer
    included.

    The other member, =spec=, stores an array of the monitor counts
    per TOF bin.  This array is the primary purpose of the class.

#+name:monfile_init
#+begin_src python
    def __init__(self,file=None,plot=True):
        """Creates a MonFile object"""
        self.time = None #The amount of time that the monitor ran.
        self.spec = None #The neutron spectrum detected on the monitor.
        if file is not None:
            self.load(file,plot)
#+end_src


*** File Loading

    The SNS software saves an array of 50,000 32 bit integers
    representing the counts in each time of flight bin.  Each bin
    represents 1μs, so the 50,000 bins give 50ms, which corresponds to
    our 20Hz pulse rate.

    The main parts of the code are at the beginning of the class.
    numpy loads the neutron spectrum from the SNS data file with the
    =fromfile= function.  With the exception of the last line, every
    other part of the function is dedicated to displaying the graph
    and has no result on the actual data analysis.

    The =x= variable is used to store the wavelenghts for the neutron
    counts in =y=.
#+name:monfile_load
#+begin_src python
    def load(self,file,plot=True):
        """Load data from the file given in the path string."""
        self.time = -1
        base = 0.1
        count = 0
        uplim = 31
        
        y = np.fromfile(file,np.int32,-1)
        x = np.arange(0,50001,1,dtype=np.float32)
        x = self.convertTime(x)
#+end_src

    The =xs= and =ys= arrays are made to rebin the data from x and y.
    The code cycles through each data point and adds the data from =y=
    into the corresponding bin in =ys=.  The =base= variable is used
    to keep track of the current position in ys.

    Note that this binning algorithm is incredibly slow and should
    probably be replaced.

#+name:monfile_load
#+begin_src python
    #
        #f = ip.interp1d(x,y)
        #p0 = [10., 0.0001, 10000., 2.]
        #p1, cov = op.curve_fit(self.func, x, y, p0)
        #print(p1)
        #p1f = self.func(x, *p1) #Fit of neutron monitor
        #xs = range(200)
        #xs = np.arange(0,35,0.1)
        #ys = np.zeros(350,dtype=np.uint32)

        xs = np.arange(0,uplim,base)
        ys = np.zeros(uplim/base,dtype=np.uint32)

        for (i,j) in zip(x,y):
            if i > base:
                ys[int(10*base-1)]=count
                base += 0.1
                count = 0
            count += j
        base = 0.1
        count = 0
        uplim = 31
#+end_src

    ymean is supposed to find the background level by looking at the
    count rate of the neutron between 25 Å and 30 Å, but it only seems
    to be used in =ynew=, which is never used again.  In practice, the
    noise on the neutron monitor is low enough that this really
    shouldn't be necessary.

#+name:monfile_load
#+begin_src python            
    #
        ymean = np.mean(ys[250:300])
        ynew = np.array([float(yo)-ymean*(uplim/base)/50001 for yo in y])
#+end_src

    The results are rebinned again for reasons that I honestly cannot
    fathom at this point.

#+name:monfile_load
#+begin_src python        
    #
        ysnew = np.zeros(uplim/base,dtype=np.float32)
        for (i,j) in zip(x,ynew):
            if i > base:
                ysnew[int(10*base-1)]=count
                base += 0.1
                count = 0
            count += j
#+end_src

    Finally, the results are plotted.

#+name:monfile_load
#+begin_src python
    #
        if plot:
            graph = GraphFrame(None,"Monitor")
            graph2 = GraphFrame(None,"Monitor Adjusted")
        #        graph.plot(np.arange(0.0,20.0,0.1),f(xs))
        #    graph.plot(xs,ys)
            graph2.plot(xs,ysnew)          
#+end_src

    The final, but most important step, is to store the monitor
    spectrum in the class.  The =expand_dims= function is used to turn
    a 1D array with fifty thousand elements into a 3d arry with
    dimensions (1,1,50000).  The reasoning is that the time
    information is now stored on the same array axis by both the
    monitor file and the detector reader.

#+name:monfile_load
#+begin_src python
    #
        self.spec = np.expand_dims(np.expand_dims(y,axis=0),axis=0)

#+end_src

    The convert time function takes an array of μs and returns their
    corresponding wavelengths in Angstroms.  Most of this has already
    been covered in the [[convertTime][similar function]] for the neutron data

#+name:monfile_converttime
#+begin_src python
    def convertTime(self,t):
        """Converts a numpy array of time bins into neutron wavelengths"""
        distanceToG4 = 3.7338+2.5297
        #The distance between the end of G4 and the Helium 3 monitor.
        distanceToMonitor = 0.02 #FIXME
        t -= 860
        t *= 3.956034e-7/(distanceToMonitor+distanceToG4)/1e-10*1e-6
        return t
#+end_src

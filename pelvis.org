#+TITLE: PELVis: The PEL Visualizer
#+AUTHOR: Adam Washington
#+OPTIONS: toc:4


#+BEGIN_LATEX
\lstset{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=Python,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{cyan},
  commentstyle=\itshape\color{olive},
  identifierstyle=\color{black},
  stringstyle=\color{orange},
}
#+END_LATEX

* Introduction

  This docment is a [[http://www.literateprogramming.com/index.html][literate]] program for analyzing data collected on
  the SESAME beamline. The document itself was written in
  [[http://orgmode.org/][Org Mode]] while the majority of the source is intended to be run
  through python.

  If your primary goal is to simply use PELVis, then the
  [[file:readme.org][user documentation]] would be the best place to start.

* PELVis application

  The main user application is the pelvis.py script that the user runs
  to view neutron data.

** Application skeleton

   Below is the rough layout of the PELVis application.  More details can be found in the individual sections

#+begin_src python :tangle pelvis.py :noweb tangle :padline no
  """A GUI for handling polarization data generated by a PAPA detector.
  
  This program was written to help with analyzing polarization data produced
  by the PAPA detector.  The general workflow is:
  1)Load Neutron Data
  2)Subtract Background
  3)Select Region of Interest
  4)Plot Spectrum data
  
  The primary class is PelvisFrame, which controls the whole program.
  PelvisFrame contains a PositionPanel, to examine single pixels, and
  a PelvisOptionPanel, which accepts user parameters.
  
  """
  
  <<pelvis_imports>>
  
  RESOLUTION = 400

  <<position_panel>>
  <<pelvis_option_panel>>
  <<pelvis_frame>>
  if __name__=="__main__":
      app=wx.PySimpleApp()
      pelvisframe = PelvisFrame(app.Yield)
      app.MainLoop()
  
#+end_src
** Imports

   The PELVis application uses a large number of packages to handle
   the work. 


   This code was originally written for Python 2.5.  This version of
   Python did not have the =with= statement and needed it imported
   from the future.  If PELVis is run on version 2.6 or later, this
   should not be an issue.  As such, it should be possible to remove
   this import, but it has not been tested.
#+name:pelvis_imports
#+begin_src python
  import __future__
#+end_src

   The [[Reader][PelFile]] class handles all of the data loading from the neutron
   event files.

#+name:pelvis_imports
#+begin_src python
  
  from reader import PelFile
#+end_src

   [[Image Panel][ImagePanel]] is a custom widget for displaying 2D graph data in a
   wxPython frame.

#+name:pelvis_imports
#+begin_src python
  from ImagePanel import ImagePanel
#+end_src

   [[GraphPanel][GraphPanel]] is a custom widget for displayed 1D graphs in a wxPython
   Frame.

#+name:pelvis_imports
#+begin_src python
  from GraphPanel import GraphPanel
#+end_src

   The [[ColorBarPanel]] is a custom widget for displaying a legended
   color bar for 2D color maps.  The [[ColorMapPicker]] is a custom dialog
   for chosing a color bar.

#+name:pelvis_imports
#+begin_src python
  from colorbarpanel import ColorBarPanel, ColorMapPicker
#+end_src

   The [[MonFile]] class handles reading the SNS monitor count files.

#+name:pelvis_imports
#+begin_src python
  from monfile import MonFile
#+end_src

   [[SpectrumDialog]] is a custom dialog which handles viewing and
   exporting 1D spectral data from the Pelvis application.

#+name:pelvis_imports
#+begin_src python
  from SpectrumDialog import SpectrumDialog
#+end_src

   The Python built-in TemporaryFile class is used to cache Flat
   Files, since they can use a large amount of memory.  If the Flat
   File functionality is removed, this import can be dropped.

#+name:pelvis_imports
#+begin_src python
  
  from tempfile import TemporaryFile
#+end_src

   =math= is not used, as it has been essentially superseded by
   numpy.  This import should be dropped.

#+name:pelvis_imports
#+begin_src python
  
  import math
#+end_src

   =time= is used for sleeping in a couple of functions.  This is
   almost never truly necessary and probably should be dropped.

#+name:pelvis_imports
#+begin_src python
  import time
#+end_src

   [[http://docs.numpy.org][=numpy=]] is a Python library for handling multidimensional arrays.
   It is many orders of magnitude faster and smaller than using Python
   Lists, plus easier to read, once you're used to it.  By local
   convention, =numpy= is always imported as =np=, just because it's
   called so often.

#+name:pelvis_imports
#+begin_src python
  
  import numpy as np
#+end_src

   [[http://matplotlib.org][=matplotlib=]] is a plotting library for python.  It handles all of
   the plots within the application.

#+name:pelvis_imports
#+begin_src python
  from matplotlib import pyplot as plt
#+end_src

   The =cm= submodule of matplotlib handles color maps and is needed for
   controlling the display of the 2D detector data.

#+name:pelvis_imports
#+begin_src python
  import matplotlib.cm as cm
#+end_src

   [[http://www.wxpython.org][wx]] is the GUI toolkit used to make the user interface for PelVis

#+name:pelvis_imports
#+begin_src python
  
  import wx
#+end_src


* GUI Controls

  We're using [[https://www.wxwidgets.org/][wxWidgets]] as our GUI toolkit through the [[http://www.wxpython.org][wxPython]]
  binding library.  wxWidgets was chosen as it is cross platform and
  provided a more complete toolkit than the default Tk toolkit that
  comes with Python.  The largest disadvantage to this decision is
  that wxPython has not yet been officially ported to Python 3.

** Pelvis Frame

    The Pelvis Frame is the main UI for the application.
    Unfortunately, it also contains a large amount of application
    logic, which should be extracted out into its own class.  That
    would certainly make working on the Reduction programs easier.
    If you're looking for a good improvement to make to the code.
    This would be it.

    The class starts off with a large number of constant definitions.
    These constants are identifiers for menu commands, which are
    needed for the wxWidget menu system.

#+name:pelvis_frame
#+begin_src python
  class PelvisFrame(wx.Frame):
      """The main application window for PELvis"""
  
      #Menu ID constants
      ID_OPEN = 100
      ID_OPENTWO = 110
      ID_SAVE = 130
      ID_SPECTRUM=140
      ID_IMAGE_ARRAY=160
      ID_EXIT = 190
  
      ID_GREY = 200
      ID_HUEVAL = 220
      ID_SPECTRAL = 230
      ID_PICKER = 290
      ID_POLAR = 300
      ID_FLIPPING = 310
      ID_SPIN_UP = 320
      ID_SPIN_DOWN = 330
  
      ID_FLAT = 420
      ID_FAKEFLAT = 430
      ID_ROD = 440
      ID_EXPORT_ROI = 450
      ID_IMPORT_ROI = 460
  
      ID_COPY = 500
  
      def __init__(self,Yield):
          <<pelvis_frame_init>>
  
      <<pelvis_handle_pels>>
  
      <<pelvis_on_image_array>>
  
      <<pelvis_load_norm_pel>>
                  
  #    def getLambdaRange(self):
  #        try:
  #            lmin = int(float(self.lambdaMin.GetValue())*10)
  #        except ValueError:
  #            lmin = 0
  #        try:
  #            lmax = int(float(self.lambdaMax.GetValue())*10)
  #        except ValueError:
  #            lmax = 200 
  #        return (lmin,lmax)
  
      <<pelvis_updaters>>
  
      <<pelvis_on_update_button>>
  
      <<pelvis_on_open>>
  
      <<pelvis_on_open_set>>
  
      <<pelvis_flat_files>>
  
      <<pelvis_menu_commands>>  
      def setColorMap(self,cmap):
          """Changes to the given colormap"""
          self.imPanel.cmap = cmap
          self.colorbar.setCmap(cmap)
          self.update()
  
  
      <<pelvis_on_exit>>
      <<pelvis_load_up_and_down>>
  
      <<pelvis_menu_commands_2>>
                  
  
  
  
#+end_src

*** Initialization

     The frame is created with a single parameter: =Yield=.  This points
     to a function which allows Pelvis to temporarily return control
     back to the GUI.  This is necessary to amintain responsiveness
     of the user interface while performing long calculations
     (e.g. loading a file).

     We start by creating a wxFrame.  We also set the initial data to
     an empty file, store the =Yield= command, and create a default
     data mask that accepts all pixels.

#+name:pelvis_frame_init
#+begin_src python
          """Create a PELvis frame
  
          Keyword arguments:
          Yield -- A function to give control back to the main event loop
  
          """
          wx.Frame.__init__(self,None,wx.ID_ANY,"PEL Visualizer")
          self.data = PelFile()
          self.Yield = Yield
          self.mask = np.ones((128,16),dtype=np.bool)
#+end_src


     Now we can create the actual components of the GUI.  The =xPanel=
     and =yPanel= are [[Graph Panel][graphs]] which display the integrated intensity
     along an axis.  =imPanel= displays the actual, 2D detector [[ImagePanel][image]].
     =colorbar= gives the current scale of the color scheme on the
     imPanel.  =opPanel= is a generic [[Option Panel][panel]] for the user to input data
     about the current region of interest.  =posPanel= displays
     position information to the user.  =cmp= stores the current color
     map for use on the =imPanel=. =specDlg= is a [[SpectrumDialog][dialog box]]
     which handles displaying and saving wavelength spectrums.
     Finally, =imageSaveDialog= is a custom file saving dialog for
     handling saving the current detector image to a file.

#+name:pelvis_frame_init
#+begin_src python  
          #Create items in the frame
          self.yPanel = GraphPanel(self,(2,8),64,GraphPanel.VERTICAL)
          self.xPanel = GraphPanel(self,(8,2),64,GraphPanel.INVERTED)
          self.colorbar = ColorBarPanel(self,cm.jet)
          self.opPanel = PelvisOptionPanel(self)
          self.posPanel = PositionPanel(self)
          self.imPanel = ImagePanel(self,self.posPanel.set,
                                    self.opPanel.setPosMin,self.opPanel.setPosMax)
          self.specDlg = SpectrumDialog(self)
  
          self.cmp = None #color map
          self.imageSaveDialog=wx.FileDialog(self,"Choose graphics file",wildcard="Portable Network Graphic (png)|*.PNG|Windows Bitmap (bmp)|*.BMP|Joint Photographic Experts Group (jpg)|*.JPG|Portable Network Monocrome (pnm)|*.PNM|Tagged Image File Format (tif)|*.TIF|Archaic, useless format (pcx)|*.PCX",style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
#+end_src

     The Pelvis Frame class has two dynamic member functions.  The
     first is =update=, which is responsible for setting the image in
     the image panel.  The function assumes that the 3D array of data
     that has been displayed hasn't changed, but that some of the
     parameters for the display (e.g. wavelength range, intensity
     caps) may have changed.  The other member function, =updateData=,
     is used whenever the underlying 3D array may have changed.

#+name:pelvis_frame_init
#+begin_src python  
  
          self.update = self.updateSingle#update the image
          self.updateData = self.updateSingleData#update the data in the image
#+end_src

     Below is the creation and layout of the menu for the PELVis
     application.  To add an entry to a menu, we need to append both a
     message code (e.g. =ID_EXIT=) and a title.  If the title contains
     a tab character, a hotkey can follow that tab character to allow
     for a more keyboard oriented interaction with the program.
     Additionally, if there is an ampersand in front of a character,
     then that character will serve as the hotkey for that command
     when accessing the menu through the keyboard.  The =Append=
     function will also accept tooltext for the menu, but the current
     version of wxpython seems to be ignoring it.

#+name:pelvis_frame_init
#+begin_src python  
  
          #Create the menu
          menubar = wx.MenuBar()
          filemenu = wx.Menu()
          editmenu = wx.Menu()
          scalemenu = wx.Menu()
          analysismenu = wx.Menu()
          noisemenu = wx.Menu()
  
          #populate the menu
          filemenu.Append(self.ID_OPEN,"&Open\tCtrl-O"," Open a PEL file")
          filemenu.Append(self.ID_OPENTWO,"&Polarized Set"," Open two PEL files")
          filemenu.Append(self.ID_SAVE,"&Save\tCtrl-S"," Save an image file")
          filemenu.Append(self.ID_SPECTRUM,"Spectrum"," View the TOF spectrum")
          filemenu.Append(self.ID_IMAGE_ARRAY,"&Export Images..."," Save a series of TOF snapshots")
          filemenu.Append(self.ID_EXIT,"&Quit\tCtrl-Q"," Quit")
  
          editmenu.Append(self.ID_COPY,"&Copy\tCtrl-c","Copy the current image to the clipboard")
  
          scalemenu.Append(self.ID_GREY,"Greyscale\tCtrl-G","Monochrome images")
          scalemenu.Append(self.ID_HUEVAL,"Hue and Value\tCtrl-H","Scaled Rainbow Images")
          scalemenu.Append(self.ID_SPECTRAL,"spectral","Uses spectrum of light")
          scalemenu.Append(self.ID_PICKER,"Map Picker..."," Select from the full list of colormaps")
  
          analysismenu.Append(self.ID_POLAR,"Check Polarization\tCtrl-P","2d plot of polarization data")
          analysismenu.Append(self.ID_FLIPPING,"Check Flipping Ratio\tCtrl-F","2d plot of  spin up over spin down")
          analysismenu.Append(self.ID_SPIN_UP,"View Spin Up State\tCtrl-U","2d plot of  spin up")
          analysismenu.Append(self.ID_SPIN_DOWN,"View Spin Down State\tCtrl-D","2d plot of  spin down")
  
          noisemenu.Append(self.ID_FLAT,"&Load Flat"," Load a blank run for background subtraction")
          noisemenu.Append(self.ID_FAKEFLAT,"Si&mulate Flat"," Drop out background within the same image")
          noisemenu.Append(self.ID_ROD,"Region of &Disinterest"," Drop out background within the same image")
          noisemenu.Append(self.ID_EXPORT_ROI,"Export ROI"," Export a binary file corresponding to where the data is above the minimum intensity.")
          noisemenu.Append(self.ID_IMPORT_ROI,"Import ROI"," Add another exclusion mask.")
#+end_src

     Each menu item needs to be bound to a function.  This is
     performed by connecting the menu signal (e.g. =ID_EXIT=) to the
     corresponding function (e.g. =OnExit=).  There's probably a
     better way of doing this through some config file, but that will
     be left as an exercise to the reader.

#+name:pelvis_frame_init
#+begin_src python  
  
  
          #Bind events to the menu
          self.Connect(self.ID_EXIT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnExit)
          self.Connect(self.ID_OPEN,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnOpen)
          self.Connect(self.ID_OPENTWO,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnOpenSet)
          self.Connect(self.ID_SAVE,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSave)
          self.Connect(self.ID_SPECTRUM,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSpectrum)
          self.Connect(self.ID_IMAGE_ARRAY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnImageArray)
          self.Connect(self.ID_GREY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnGrey)
          self.Connect(self.ID_HUEVAL,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnHueVal)
          self.Connect(self.ID_SPECTRAL,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSpectral)
          self.Connect(self.ID_PICKER,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnPicker)
          self.Connect(self.ID_POLAR,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnPolar)
          self.Connect(self.ID_FLIPPING,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFlipping)
          self.Connect(self.ID_SPIN_UP,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnAnalysisSpinUp)
          self.Connect(self.ID_SPIN_DOWN,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnAnalysisSpinDown)
  
          self.Connect(self.ID_FLAT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFlat)
          self.Connect(self.ID_FAKEFLAT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFakeFlat)
          self.Connect(self.ID_ROD,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnROD)
          self.Connect(self.ID_EXPORT_ROI,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnExportROI)
          self.Connect(self.ID_IMPORT_ROI,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnImportROI)
          self.Connect(self.ID_COPY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnCopy)
#+end_src

     We can now add the menus into the menubar and assign that menubar
     to the application.  Adding an ampersand into the title of a
     menu assigns an Alt hotkey to that menu (e.g. pressing Alt+F
     will open the =&File= menu).

#+name:pelvis_frame_init
#+begin_src python  

  
          menubar.Append(filemenu,"&File")
          menubar.Append(editmenu,"&Edit")
          menubar.Append(scalemenu,"&Color")
          menubar.Append(analysismenu,"&Analysis")
          menubar.Append(noisemenu,"&Noise")
          self.SetMenuBar(menubar)
#+end_src

     We can now add all of the GUI components to the window.  A
     progress bar is added to the bottom of the window to give
     feedback on the loading of files.

#+name:pelvis_frame_init
#+begin_src python  
  
          #arrange window
          sizer = wx.GridBagSizer()
          sizer.Add(self.colorbar,pos=wx.GBPosition(0,9),span=wx.GBSpan(9,1))
          sizer.Add(self.imPanel,pos=wx.GBPosition(0,1),span=wx.GBSpan(8,8))
          sizer.Add(self.yPanel,pos=wx.GBPosition(0,0),span=wx.GBSpan(8,1))
          sizer.Add(self.xPanel,pos=wx.GBPosition(8,1),span=wx.GBSpan(1,8))
          sizer.Add(self.opPanel,pos=wx.GBPosition(0,10),span=wx.GBSpan(8,1),flag=wx.EXPAND)
          sizer.Add(self.posPanel,pos=wx.GBPosition(8,0),flag=wx.EXPAND)
          self.progress = wx.Gauge(self,range=1000)
          sizer.Add(self.progress,pos=wx.GBPosition(9,0),span=wx.GBSpan(1,11),flag=wx.EXPAND)
#+end_src

     A button to force the image display to update is added and bound
     to the [[pelvis_on_update_button_link][OnUpdateButton]] function.

#+name:pelvis_frame_init
#+begin_src python  
  
          updateButton = wx.Button(self,-1,"Update")
          updateButton.Bind(wx.EVT_BUTTON,self.OnUpdateButton)
          sizer.Add(updateButton,flag=wx.EXPAND,pos=wx.GBPosition(8,10))
#+end_src

     All that remains is some final cleanup.  The data is set to an
     empty file, the background is set to empty, as the window
     undergoes stanard intialization.

#+name:pelvis_frame_init
#+begin_src python  
  
          self.data = self.makePel()
          self.flatrun = None#background data
          
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Show(True)
#+end_src

     


*** Handling Pel Files

     There's a large amount of references to Pel files in this
     section, which might be confusing, since you will almost never
     encounter an actual Pel file.  The PELVis program was originally
     written to view neutron data comes of off the PAPA detector.  The
     data off of the PAPA was saved in a binary format called the PAPA
     Electronic Log, or PEL for short.  

     The software which came with the detector was written in
     Labview 5.  [[http://ni.com/labview][Labview]] files are stored in a proprietary format
     which can only be read by Labview itself.  Modern versions of
     Labview are not backwards compatible enough to read Labview 5
     code.  Versions of Labview old enough to read the code are
     generally unavailable and difficult to install on modern
     operating systems.  Thus, while the vendor's supplied code could
     open the files, we could not extended it to perform the sorts of
     calulcations that we would like.  Thus, it was necessary to write
     a new program from scratch to read these files.  This is that
     application.

     Once we obtained the Helium-3 detector, we replaced the PAPA
     detector, as the PAPA had terrible noise issues.  However, PELVis
     had grown to the point where the reading of the data file was
     only a small part of the functionality.  By changing the [[reader]]
     code to handle the SNS file format (which was quite similar to
     the Pel format), we were able to continue using the same suite.

     The =makePel= function creates a blank neutron run.  It's just a
     default for when the user hasn't loaded any data yet.

#+name: pelvis_handle_pels
#+begin_src python
  def makePel(self):
      """Create a blank Pel object for loading detector data"""
      data = PelFile()
      def statusfunc(x):
          self.progress.SetValue(x)
          self.Yield()
      data.statusfunc = statusfunc
      return data
#+end_src

     The =loadPel= command reads in a neutron data file.  It takes as
     a single parameter a message to display to the user about what
     sort of file should be loaded.  There is also the ability to load
     a pre-histogrammed version of the neutron data, stored in the
     [[http://docs.numpy.org][numpy's]] native binary format.  In practice, this hasn't been that
     useful and may be dropped.  The numpy files do read far faster,
     but they also take up huge amounts of disk space compared to the
     event files, plus they need preprocessing from said event files
     to be created in the first place.

     This function also loads the monitor file that corresponds to the
     data set.

#+name: pelvis_handle_pels
#+begin_src python  
  def loadPel(self,message):
      """Load a .pel file and its monitor data.
      
      Keyword arguments:
      message -- The title for the load file dialog.
      
      """
      dlg=wx.FileDialog(self,message,wildcard="He3 data|*neutron_event.dat|Preformatted Histograms|*.npy",style=wx.FD_OPEN)
      if dlg.ShowModal()==wx.ID_OK:
      #            self.SetCursor(wx.CURSOR_WAIT)
          path = dlg.GetPath()
          if path[-3:] == "dat":
              data = self.makePel()
              data.readfileimage(path)
          elif path[-3:] == "npy":
              data = np.load(path)
      #            self.SetCursor(wx.CURSOR_ARROW)
      else:
          return (None,None)
      mon = MonFile(path[:-17]+"bmon_histo.dat")
      return (data,mon)
#+end_src

     The =loadNormPel= function loads a neutron data set and a set of
     counts from the beam monitor.  In the unlikely event that there
     is a [[flat run]], the flat is subtracted out of the data set.  The
     neutron data is then normalized to the monitor count.

#+name: pelvis_load_norm_pel
#+begin_src python

      def loadNormPel(self,message):
          """Load a .pel file, normalize it by monitor, and subtract background"""
          (data,mon) = self.loadPel(message)
          if isinstance(data,PelFile):
              data = np.asarray(data.make3d(),np.float32)
          if mon is None:
              return (data,1)
          if self.flatrun != None:
              flatrun = np.load(self.flatrun)
              self.flatrun.seek(0)
              flatrun *= mon.time
              data -= flatrun
          spec = mon.spec
          monsum = np.sum(spec)
          print("Integrated monitor counts: " + str(monsum))
          data /= monsum
          return (data,np.sum(mon.spec))
#+end_src

     The =loadUpAndDown= function is a helper function to load both
     spin states of a flipping measurement.

#+name:pelvis_load_up_and_down
#+begin_src python
      def loadUpAndDown(self):
          """Read in spin flip data"""
          u3d,uscale = self.loadNormPel("Spin Up State")
          if u3d is None:
              return False
          del self.data
          d3d,dscale = self.loadNormPel("Spin Down State")
          self.data = (u3d,d3d)
          self.scale = (uscale,dscale)
          return True
#+end_src



*** Menu Commands

     The Image Array command causes Pelvis to export the detector
     image, one wavelength bin at a time.  It can be useful to find
     effects which are sensitive to both position and wavelength, but
     it honestly hasn't seen much use.

     The =path= and =ext= variables are used to get the file name that
     the user chose and then sandwich the wavelength between them.

#+name: pelvis_on_image_array
#+begin_src python

      def OnImageArray(self,event):
          """Exports the 2d detector image by wavelength"""
          dlg = self.imageSaveDialog
          if dlg.ShowModal()==wx.ID_OK:
              path=dlg.GetPath()
              ext = path[-4:]
              path = path[:-4]
              (lmin,lmax) = self.opPanel.getLambdaRange()
              for i in range(lmin,lmax):
                  file=path+("%03i"%i)+ext
                  self.opPanel.setLambdaRange(0.1*i,0.1*(i+1))
                  self.updateData()
                  self.update()
                  self.imPanel.saveImage(file)
                  self.progress.SetValue(1000*(i-lmin)/(lmax-lmin))
                  self.Yield()
              self.opPanel.setLambdaRange(lmin*0.1,lmax*0.1)
              self.updateData()
              self.progress.SetValue(0)
#+end_src

     The =OnUpdateButton= isn't really a menu command, but is rather
     the calback for when the user clicks the update button.  All it
     does is call the current value of the =updateData= function.
     This function exists mostly because wxWidgets won't follow the
     dynamically changing definition for =updateData= and needs a
     static location for the callback.

<<pelvis_on_update_button_link>>
#+name: pelvis_on_update_button
#+begin_src python
      def OnUpdateButton(self,event):
          """Refresh the data when the user pushes the "Update" button"""
          #This function is needed for wxWidgets to allow
          #for dynamically changing the bound function
          self.updateData(event)
#+end_src

     The =OnOpen= function handles opening a single data set.
     [[*Handling%20Pel%20Files][loadNormPel]] does all of the actual file loading.  The =data= and
     =scale= values are set to the actual neutron data and monitor
     counts, respectively.  The =updateData= and =update= functions
     are also set to single data file mode.

#+name:pelvis_on_open
#+begin_src python
      def OnOpen(self,event):
          """Load a single .pel file for display"""
          data,scale = self.loadNormPel("Choose the Pel File to Open")
          if data is None:
              return
          self.data = data
          self.scale = scale
          self.progress.SetValue(0)
          self.specDlg.setMode("up")
          self.updateData = self.updateSingleData
          self.update = self.updateSingle
          self.updateData()
#+end_src

     Similarly to =OnOpen=, =OnOpenSet= loads two data files for
     examining a polarization measurement.  The actual file loading is
     handled by [[*Handling%20Pel%20Files][loadUpAndDown]].  Should the files load, the application
     switches to presenting polarization information.

#+name:pelvis_on_open_set
#+begin_src python
      def OnOpenSet(self,event):
          """Load a spin flip measurement for display"""
          if self.loadUpAndDown():
              self.OnPolar(event)
#+end_src

     Back when the PAPA detector first arrived, there was a light leak
     that caused an enormous noise signal across the detector.  The
     flat files were an attempt to eliminate that.  The flat files are
     essentiall a position sensitive calculation of the detector noise
     per unit time.  In practice, this functionality is almost never
     used and should probably be removed, as it may be out of date or
     inaccurate. 

     =OnFlat= starts by having the user load in a background run.
     This run is then flattened into a 3D positional map (the
     background is assumed to be wavelength independent).  This 2D map
     is normalized to the time of the measurement.

     The =OnFakeFlat= function tries to use the background to simulate
     having performed a flat measurement.  Honestly, this is probably
     better perofrmed by simple background subtraction and should be
     removed from the program.

#+name:pelvis_flat_files
#+begin_src python
      def OnFlat(self,event):
          """Load a blank run for background subtraction"""
          (data,mon) = self.loadPel("Choose a Blank Run")
          if data == None:
              return
          if isinstance(data,PelFile):
              flatrun = data.make3d()
          elif isinstance(data,np.ndarray):
              flatrun = data
          flatrun = np.sum(flatrun,axis=2)
          flatrun /= RESOLUTION
          flatrun /= float(mon.time)
          flatrun = np.expand_dims(flatrun,2)
          self.flatrun = TemporaryFile()
          np.save(self.flatrun,flatrun)
          self.flatrun.seek(0)
          self.progress.SetValue(0)
  
      def OnFakeFlat(self,event):
          """Create a fake background run from outside the region of interest."""
          (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
          totarea = 512*512
          centarea = (yMax-yMin)*(xMax-xMin)
          backgroundarea = totarea-centarea
          if type(self.data) is tuple:
              (u,d)=self.data
  
              totu = np.sum(u)
              totd = np.sum(d)
              centu = np.sum(u[yMin:yMax,xMin:xMax,:])
              centd = np.sum(d[yMin:yMax,xMin:xMax,:])
  
              backgroundu = totu-centu
              backgroundd = totd-centd
              backgroundrateu = backgroundu/backgroundarea
              backgroundrated = backgroundd/backgroundarea
              backgroundrateu /= (RESOLUTION + 1) #normalize against the wavelengths
              backgroundrated /= (RESOLUTION + 1) #normalize against the wavelengths
              ###Stupid Memory Errors
              del self.data
              u -= backgroundrateu
              d -= backgroundrated
              ###
              self.data=(u,d)
          else:
              d=self.data
              tot = np.sum(d)
              cent = np.sum(d[yMin:yMax,xMin:xMax,:])
              background = tot-cent
              backgroundrate = background/backgroundarea
              backgroundrate /= (RESOLUTION + 1) #normalize against the wavelengths
              self.data-=backgroundrate
          self.updateData()
#+end_src

     The =OnROD= command is really just the background subtraction
     function.  The =ROD= standards for "Region of Disinterest", which
     is a play on the phrase "Region of Interest".

     The code simply finds the average per pixel count rate in the current
     selected region of interest and subtracts it from all the pixel.
     Note that the background subtraction is performed per wavelength
     bin, so wavelength specific backgrounds are handled appropriately.

#+name:pelvis_menu_commands
#+begin_src python
  #Subtract out the region of disinterest
  def OnROD(self,event):
      """Take the region of interest as background noise"""
      (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
      area = (yMax-yMin)*(xMax-xMin)
      if type(self.data) is tuple:
          u,d=self.data
          del self.data
          totu = np.sum(np.sum(u[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          totd = np.sum(np.sum(d[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          totu /= area
          totd /= area
          u -= totu
          d -= totd
          self.data=(u,d)
      else:
          d=self.data
          totd = np.sum(np.sum(d[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          #totd = np.atleast_3d(totd)
          totd /= area
          #print(totd.shape)
          #print(self.data.shape)
          self.data -= totd
      self.updateData()
#+end_src

     The =OnExportROI= function creates a 2D binary map of all of the
     pixels where the intensity is less that the minimum intensity and
     saves the map to a file.  The map can either be a text file for
     readability or a binary file in numpy format for speed and
     compactness.  Not that =OnExportROI= does *not* change the
     current mask for the application. 

<<OnExportROI>>
#+name:pelvis_menu_commands
#+begin_src python 
  
  def OnExportROI(self,event):
      """Save a file containing a map of where the current data
      image is greater than vmin"""
      vMin,_ = self.opPanel.getIntensityRange()
      mask = self.flatdata > vMin
      # (vMin,vMax) = self.opPanel.getIntensityRange()#
      # (xMin,xMax,yMin,yMax) = self.opPanel.getRoi()#
      # (lMin,lMax) = self.opPanel.getLambdaRange()#
      # (lMin,lMax) = (lMin/10,lMax/10)#
      # mask = [["xMin",xMin], ["xMax",xMax], ["yMin",yMin], ["yMax",yMax], \
      #         ["lMin",lMin], ["lMax",lMax], ["vMin",vMin], ["vMax",vMax]]#
      dlg = wx.FileDialog(self,
                          "Where to save the mask file?",
                          wildcard="Numpy dump (npy)|*.npy|Text (dat)|*.dat",
                          style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
      if dlg.ShowModal()==wx.ID_OK:
          path=dlg.GetPath()
          ext = path[-4:]
          if ext == ".dat":
              np.savetxt(path,mask,fmt="%d")
          else:
              np.save(path,mask)
#+end_src

     The =OnImportROI= sets the detector mask used for specifying the
     region of interest.  It can load either of the mask formats
     exported by =OnExportROI=.  A mask is loaded additively - if a
     pixel is masked in either the current mask or in the loaded mask
     file, it will be masked in the final mask.  Currently, the only
     way to remove a pixel from the mask is to restart the
     application.  Obviously, this is suboptimal and a simple
     =RemoveMask= function should be written to return to an unmasked
     state.

#+name:pelvis_menu_commands
#+begin_src python 
  
  def OnImportROI(self,event):
      """Adds another mask to the current system mask"""
      dlg = wx.FileDialog(self,
                          "Which Mask File?",
                          wildcard="Numpy dump (npy)|*.npy|Text (dat)|*.dat",
                          style=wx.FD_OPEN)
      time.sleep(.1)
      if dlg.ShowModal()==wx.ID_OK:
          path = dlg.GetPath()
          ext = path[-4:]
          if ext == ".dat":
              newmask = np.loadtxt(path,dtype=np.bool)
              newmask=dict(newmask)#
          else:
              newmask = np.load(path)
          self.mask = np.logical_and(self.mask,newmask)
          #self.opPanel.setPosMin(newmask["xMin"],newmask["yMin"])#
          #self.opPanel.setPosMax(newmask["xMax"],newmask["yMax"])#
          #self.opPanel.setLambdaRange(newmask["lMin"],newmask["lMax"])#
          #self.opPanel.setIntensityRange(newmask["vMin"],newmask["vMax"])#
          self.updateData()
  
#+end_src

     =OnSave= save the current detector image to a graphics file.  The
     actual image saving is handled by the [[ImagePanel]] class.

#+name:pelvis_menu_commands
#+begin_src python   
  
  def OnSave(self,event):
      """Save the current 2D image to a file"""
      print("OnSave")
  #        dlg=wx.FileDialog(self,"Choose graphics file",wildcard="Windows Bitmap (bmp)|*.BMP|Portable Network Graphic (png)|*.PNG|Joint Photographic Experts Group (jpg)|*.JPG|Portable Network Monocrome (pnm)|*.PNM|Tagged Image File Format (tif)|*.TIF|Archaic, useless format (pcx)|*.PCX",style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
      dlg = self.imageSaveDialog
      if dlg.ShowModal()==wx.ID_OK:
          self.imPanel.saveImage(dlg.GetPath())
#+end_src

     The =OnSpectrum= function formats the data into a 1D format for
     use by the [[SpectrumDialog]] in actually giving the spectral
     information.  The data is masked by both the mask generated by
     =OnImportROI= and by the user's chosen region of interest.  The
     total counts per wavelength bin are then sent to the
     SpectrumDialog, along with the scale from the monitor count. 

     The user's chosen intensity range display is also sent to the
     spectrum dialog.  This is helpful in getting proper bounds for
     graphing the polarization and flipping ratio, since dividing by
     small numbers can give strange boundary ranges.  Unfortunately,
     this is NOT useful with raw intensity rates, since the intensity
     range per pixel on the detector doesn't necessarily correspond to
     what we're interested in with  the intensity per wavelength bin.

#+name:pelvis_menu_commands
#+begin_src python   
  
  def OnSpectrum(self,event):
      """Display a plot of the region of interest versus wavelength"""
      print("OnSpectrum")
      (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
      if type(self.data) is tuple:
          u3d,d3d = self.data
          u3d = u3d[:,:,:]
          d3d = d3d[:,:,:]
          u3d[np.logical_not(self.mask)] = 0
          d3d[np.logical_not(self.mask)] = 0
          u = np.sum(np.sum(u3d[yMin:yMax,xMin:xMax],0),0)
          d = np.sum(np.sum(d3d[yMin:yMax,xMin:xMax],0),0)
          uscale,dscale = self.scale
          self.specDlg.setScale(uscale,dscale)            
          self.specDlg.setData(u,d)
      else:
          copy = self.data[:,:,:]
          copy[np.logical_not(self.mask)] = 0
          u = np.sum(np.sum(copy[yMin:yMax,xMin:xMax],0),0)
          #            u *= self.scale
          self.specDlg.setScale(self.scale)
          self.specDlg.setData(u)
      self.specDlg.setIntensityRange(self.opPanel.getIntensityRange())
      self.specDlg.Show()
#+end_src
     
     There are a couple of menu functions for setting the color scheme
     of the detector image.  =OnGrey= gives a greyscale image, as one
     would expect.  =OnHueVal= gives an image where the intensity if
     encoded into the Hue, with the saturation and Value both pegged
     at the maximum.  Finally, =OnSpectral= is the default, with a
     color scheme that starts at zero and passes through the range of
     hues before arriving at white.

     If the user wants a different color map, they can use the
     [[ColorMapPicker]] to chose from any of the installed color maps.
     PELVis currently does not support creating custom color spectra.

#+name:pelvis_menu_commands
#+begin_src python   
    
  def OnGrey(self,event):
      """Set the colormap to gray"""
      self.imPanel.cmap = cm.gray
      self.colorbar.setCmap(cm.gray)
      self.update()
  
  def OnHueVal(self,event):
      """Set the colormap to a rainbow"""
      self.imPanel.cmap = cm.jet
      self.colorbar.setCmap(cm.jet)
      self.update()
  
  def OnSpectral(self,event):
      """Set the colormap to the spectral map"""
      self.imPanel.cmap = cm.spectral
      self.colorbar.setCmap(cm.spectral)
      self.update()
  
  def OnPicker(self,event):
      """Let the user pick a color map from a list"""
      if self.cmp is None:
          self.cmp = ColorMapPicker(self,self.setColorMap)
      self.cmp.Show()
  
#+end_src

     The =OnExit= function is run when the user closes the program
     from the menu.  It's not that interesting.
     
#+name:pelvis_on_exit
#+begin_src python
    
  def OnExit(self,event):
        """Quit the program"""
        self.Close()
#+end_src

     There are four functions to set the current data interpretation
     mode for the application.  Each one sets the =update= and
     =updateData= functions to the [[*Updaters][proper function]] to handle the data
     type, then sets the mode of the spectrum dialog.

     It currently looks like the update function is always set to
     updateSingle.  If this is the case, then the code can be
     simplified.  This is worth investigation.

#+name:pelvis_menu_commands_2
#+begin_src python
  def OnPolar(self,event):
      """Display neutron polarization"""
      print("OnPolar")
      self.specDlg.setMode("polar")
      self.updateData = self.updateDataPolar
      self.update = self.updateSingle
      self.updateData()
    
  def OnFlipping(self,event):
      """Display the flipping ratio"""
      print("OnFlip")
      self.specDlg.setMode("flipping")
      self.updateData = self.updateDataFlip
      self.update = self.updateSingle
      self.updateData()
    
  def OnAnalysisSpinUp(self,event):
      """Display the Spin Up data"""
      print("OnSpinUp")
      self.specDlg.setMode("up")
      self.updateData = self.updateDataUp
      self.update = self.updateSingle
      self.updateData()
    
  def OnAnalysisSpinDown(self,event):
      """Display the Spin Down data"""
      print("OnSpinDown")
      self.specDlg.setMode("down")
      self.updateData = self.updateDataDown
      self.update = self.updateSingle
      self.updateData()
#+end_src

     =OnCopy= is called when a user selects the Copy command from the
     Edit menu.  This copies the current detector image to the
     clipboard, though everything is really handled by the [[ImagePanel]] class.

#+name:pelvis_menu_commands_2
#+begin_src python   
      
  def OnCopy(self,event):
      """Copy the image to a clipboard"""
      self.imPanel.copyToClipboard()
#+end_src


     

*** Updaters

     There are two updates which need to be performed.  The first is
     updating the data, which involves taking the 3D arrays of neutron
     data and turning them into a single, 2D map.  The second is using
     that 2D data to update the other parts of the application.  All
     of the function with data in the name handle converting the 3D
     data into the 2D map, while the remaining functions pass the 2D
     data to the rest of the application.

     =updateSingleData= is used when only a single file is loaded.  As
     the only thing we can do is give intensity per pixel, a simple
     sum is performed along the wavelength axis.

#+name: pelvis_updaters
#+begin_src python
      def updateSingleData(self,event=None):
          """Update changes in wavelength on a single file"""
          print("Make 2d")
          (lmin,lmax) = self.opPanel.getLambdaRange()
          self.flatdata = np.sum(self.data[:,:,lmin:lmax],2)
          self.update()
#+end_src

     =updateDataFlip= and =updateDataPolar= require both an up and
     down state from a polarization measurement.  They then calculate
     the per pixel neutron flipping ratio and polarization,
     respectively.  a value of 10^{-9} is added to the denominator to
     prevent divide by zero errors.

#+name:pelvis_updaters
#+begin_src python
  
      def updateDataFlip(self,event=None):
          """Update changes in wavelength for flipping ratios"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,d3d)=self.data
          u = np.sum(u3d[:,:,lmin:lmax],2)
          d = np.sum(d3d[:,:,lmin:lmax],2)
          self.flatdata = u/(d+1e-6)
          self.update()
  
      def updateDataPolar(self,event=None):
          """Update changes in wavelength for polarizations"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,d3d)=self.data
          u = np.sum(u3d[:,:,lmin:lmax],2)
          d = np.sum(d3d[:,:,lmin:lmax],2)
          self.flatdata = (u-d)/(u+d+1e-6)
          self.update()
#+end_src

     The =updateDataUp= and =updateDataDown= commands display the
     neutron intensity per pixel in a single spin state.  They are
     largely identical to =updateSingleData=, except for the line
     which selects the spin state.

#+name:pelvis_updaters
#+begin_src python

      def updateDataUp(self,event=None):
          """Update changes in wavelength for the spin up state"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,_)=self.data
          self.flatdata = np.sum(u3d[:,:,lmin:lmax],2)
          self.update()
  
      def updateDataDown(self,event=None):
          """Update changes in wavelength for the spin down state"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (_,d3d)=self.data
          self.flatdata = np.sum(d3d[:,:,lmin:lmax],2)
          self.update()
#+end_src

     The =updateSingle= function takes the current 2D data, performs
     the appropriate masking, and updates the data in the [[GraphPanel][GraphPanels]].
     It also updates the range on the color bar and forces the
     [[ImagePanel][detector image]] to update.

#+name:pelvis_updaters
#+begin_src python
  
      def updateSingle(self,event=None):
          """Update the 2D data for the region of interest and intensity"""
          (vMin,vMax) = self.opPanel.getIntensityRange()
          (xMin,xMax,yMin,yMax) = self.opPanel.getRoi()
          data = self.flatdata[:,:]
  
          #Mask to zero during the summing parts
          data[np.logical_not(self.mask)] = 0
          self.posPanel.data = data
          self.posPanel.setRange(xMin,yMin,xMax,yMax)
          x=np.arange(128,0,-1)
          y=np.sum(data[:,xMin:xMax],axis=1)
          self.yPanel.SetPlot(x,y)
          #handle the x-plot
          x=np.arange(0,16,1)
          y=np.sum(data[yMin:yMax,:],axis=0)
          self.xPanel.SetPlot(x,y)
          if vMin is None:
              vMin = np.min(data)
          if vMax is None:
              vMax = np.max(data)
          self.colorbar.setRange(vMin,vMax)
          self.colorbar.update()
          #mask to vmin for the plotting
          data[np.logical_not(self.mask)] = vMin
          self.imPanel.update(self.flatdata,vMin,vMax)

#+end_src


** Position Panel

   This is a class to provide a small panel which provides
   information about single pixels of detector data via the cursor
   position.  It also provides aggregate information over the region
   of interest.

*** Position Panel Class Skeleton

#+Name:position_panel
#+begin_src python :noweb tangle
  class PositionPanel(wx.Panel):
      """A panel with pixel information
  
      The intent of this panel is to provide information about
      single pixels of detector data via cursor position.  It
      also provides aggregate information over the region of
      interest.
  
      """

      def __init__(self,parent):
          """Create a PositionPanel"""
          <<position_panel_init>>
      <<position_panel_updating>>
#+end_src

*** Initialization of the PositionPanel

     Creating a new PositionPanel requires only a single parameter:
     the parent frame which will hold the panel.  The constructor
     begins by creating the text controls that display the X and Y
     position of the cursor, as well as the value under the cursor (Z)
     and the integrated value over the region of interest (ROI).

#+name: position_panel_init
#+begin_src python
          wx.Panel.__init__(self,parent)
          sizer=wx.GridBagSizer(3,2)
          sizer.Add(wx.StaticText(self,-1,"X:"),pos=wx.GBPosition(0,0))
          self.x = wx.TextCtrl(self,-1,"")   
          sizer.Add(self.x,pos=wx.GBPosition(0,1))
          sizer.Add(wx.StaticText(self,-1,"Y:"),pos=wx.GBPosition(1,0))
          self.y = wx.TextCtrl(self,-1,"")
          sizer.Add(self.y,pos=wx.GBPosition(1,1))
          sizer.Add(wx.StaticText(self,-1,"Z:"),pos=wx.GBPosition(2,0))
          self.intensity = wx.TextCtrl(self,-1,"")
          sizer.Add(self.intensity,pos=wx.GBPosition(2,1))
          self.integrate = wx.TextCtrl(self,-1,"")
          sizer.Add(wx.StaticText(self,-1,"ROI:"),pos=wx.GBPosition(3,0))
          sizer.Add(self.integrate,pos=wx.GBPosition(3,1))

#+end_src
  
     We give a default region of interest that covers the entire detector.

#+name: position_panel_init
#+begin_src python
          #Set the starting region of interest
          self.minX = 0
          self.minY = 0
          self.maxX = 16
          self.maxY = 128

#+end_src

     The text controls are for display purposes only, so we'll ensure
     that they aren't editable.

#+name: position_panel_init
#+begin_src python  
          self.x.SetEditable(False)
          self.y.SetEditable(False)
          self.intensity.SetEditable(False)
#+end_src

     The class member =self.data= is a pointer to the actual data
     being examined.  We'll initialize it to =None= to begin with.

#+name: position_panel_init
#+begin_src python
          self.data = None #A 2D numpy array of the data being examined.

#+end_src

Finally, we need to do the standard GUI layout code.

#+name: position_panel_init
#+begin_src python
          self.SetAutoLayout(True)
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Layout()
#+end_src

*** Update position data

     As implied by the name, the primary function of the position
     panel is to provide the direct numbers for the value under the
     user's cursor.  To do that, it must know where the mouse is.  The
     =set= function takes the x and y position of the cursor and
     updates the panel accordingly.

#+Name:position_panel_updating
#+begin_src python
      def set(self,x,y):
          """Updates the position being examined"""
          self.x.SetValue(str(x))
          self.y.SetValue(str(y))
          if self.data is None:
              return
          self.intensity.SetValue(str(self.data[y,x]))
#+end_src

     Obviously, this is of no use if the panel doesn't know the
     detector values.  The =setData= function provides a 2D array of
     values for the Panel to report on.

#+Name:position_panel_updating
#+begin_src python
      def setData(self,data):
          """Updates the data being examined"""
          self.data=data
#+end_src

     The remaining functions deal with the region of interest
     integration.  The =setRange= function controls the region of
     interest while the =updateIntegration= function handles
     calculating 

#+Name:position_panel_updating
#+begin_src python
      def setRange(self,minX,minY,maxX,maxY):
          """Updates the region of interest for integration"""
          self.minX = minX
          self.minY = minY
          self.maxX = maxX
          self.maxY = maxY
          self.updateIntegration()
      def updateIntegration(self):
          """Calculates the sum of the data over the region of interest"""
          self.integrate.SetValue(
              str(np.sum(self.data[self.minY:self.maxY,self.minX:self.maxX])))
#+end_src


** Option Panel

    The class PelvisOptionPanel creates a panel of labeled text boxes
    for user entry.  This is used to control values such as the
    wavelength range, region of interest, and intensity values.

    As an experiment in software architecture, the class generates the
    layout of the panel from a list of configurations.  Each list item
    is a tuple of four values

    | Position | 0           |                      1 | 2                    | 3             |
    | Value    | Name        | Relative list position | Label                | Default Value |
    | Type     | string      |                    int | string               | string        |
    | Example  | "lambdaMax" |                     30 | "Maximum Wavelength" | "19.7"        |

    The panel generates a set of text controls with the given labels
    and default values.  The text controls are arranged from top to
    bottom by the order of the relative list position from smallest to
    largest.

    The advantage to this setup is that adding new options onto the
    panel is trivial.  Putting a new item into the list adds a new
    option onto the panel.  The disadvantage is that the data is a
    little more cumbersome to access as the values are not members of
    the class.  This could be fixed with Python accessors and
    properties, but I have not done so yet.  As this design decision
    was made to ease life for future maintainers and, seeing as you're
    reading this, you are the future maintainer, feel free to return
    to hard coded values if you find it easier to handle.
    
#+name:pelvis_option_panel
#+begin_src python :noweb tangle
  class PelvisOptionPanel(wx.Panel):
      """A panel for user parameters
  
      The panel gets it's parameters and appearance from the built in
      DEFAULTS variable.  This was designed to allow the easy addition
      of more parameters in the future.
  
      """
      #Each parameter is a tuple
      #0 - variable name
      #1 - position in list
      #2 - label
      #3 - default value
      DEFAULTS = [("lambdaMax",0,"Maximum Wavelength","20"),
                  ("lambdaMin",10,"Minimum Wavelength","0"),
                  ("intMax",20,"Maximum Intensity",""),
                  ("intMin",30,"Minimum Intensity",""),
                  ("xMin",40,"Minimun X","0"),
                  ("xMax",50,"Maximum X","16"),
                  ("yMin",60,"Minimun Y","0"),
                  ("yMax",70,"Maximum Y","128")]
  
      def __init__(self,parent):
          """Creates a PelvisOptionPanel"""
          <<pelvis_option_panel_init>>
  
      <<pelvis_option_panel_wavelength>>
  
      <<pelvis_option_panel_intensity>>
  
      <<pelvis_option_panel_roi>>
  
  
#+end_src

*** Initialization

     We begin by initializing the superclass and creating a sizer for
     the panel
#+name:pelvis_option_panel_init
#+begin_src python
          wx.Panel.__init__(self,parent)
          sizer=wx.BoxSizer(wx.VERTICAL)
#+end_src   

     We then create the text controls.  The controls are held in the
     local dictionary =options=, which will need to be used every time
     we want to access one of the values.
#+name:pelvis_option_panel_init
#+begin_src python
          self.options={}#member which holds the created text controls
  
          self.DEFAULTS.sort(lambda x,y: x[1]-y[1])
          for option in self.DEFAULTS:
              (key,_,title,val) = option
              sizer.Add(wx.StaticText(self,-1,title))
              self.options[key] = wx.TextCtrl(self,-1,val)
              sizer.Add(self.options[key])
#+end_src

     Finally, we perform the standard cleanup for a wxPanel
  
#+name:pelvis_option_panel_init
#+begin_src python
          self.SetAutoLayout(True)
          self.specDlg = SpectrumDialog(self)
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Layout()
#+end_src

*** Wavelength Range

     When a set of parameters is added, it's useful to put in a
     standard getter and setter.  The setters are fairly standard, but
     the getter can be a little tricky, since the user might add a
     non-standard value.  It's good to provide default values if the
     user's input cannot be parsed.

     Note that the code below is *wrong*.  It holds true while
     the RESOLUTION is 200, which is the default case, but the
     multiplication by ten should be replaced with a value dependent
     on the current resolution.

#+Name:pelvis_option_panel_wavelength
#+begin_src python

      def getLambdaRange(self):
          """Gives a tuple with the minimum and maximum wavelength indices"""
          try:
              lmin = int(float(self.options["lambdaMin"].GetValue())*10)
          except ValueError:
              lmin = 0
          try:
              lmax = int(float(self.options["lambdaMax"].GetValue())*10)
          except ValueError:
              lmax = RESOLUTION
          return (lmin,lmax)
  
      def setLambdaRange(self,min,max):
          """Set the minimum and maximum wavelengths"""
          self.options["lambdaMin"].SetValue(str(min))
          self.options["lambdaMax"].SetValue(str(max))
#+end_src

*** Intensity Range

     We create similar getters and setters for the minimum and maximum
     intensity.  The values create bounds for both the 2D color plot
     and the spectrum display.  They're also used as part of the mask
     making routines.

#+name:pelvis_option_panel_intensity
#+begin_src python
      def getIntensityRange(self):
          """Return a tuple with the floor and ceilling for intensity
  
          If a value isn't specified, or is not a number, None is returned
          for that part of the range.
  
          """
          try:
              vMin = float(self.options["intMin"].GetValue())
          except ValueError:
              vMin = None
          try:
              vMax = float(self.options["intMax"].GetValue())
          except ValueError:
              vMax = None
          return (vMin,vMax)
  
      def setIntensityRange(self,min,max):
          self.options["intMin"].SetValue(str(min))
          self.options["intMax"].SetValue(str(max))
          self.specDlg.setIntensityRange((min,max))

#+end_src

*** Region of Interest

     Finally, we need getters and setters for our region of interest.
     The getter works pretty much the same as the others, but the
     setter has been split into two functions: one for the upper left
     corner and another for the lower right.  This allows us to set
     the region of interest with two mouse clicks.

#+name:pelvis_option_panel_roi
#+begin_src python
      def getRoi(self):
          """Returns a 4-tuple with the region of interest
  
          Returns (xmin,xmax,ymin,ymax).  Minimum values, if
          unspecified, are set to zero.  Maximum values, if
          unspecified, are set to 512.
  
          """
          try:
              xMin = int(self.options["xMin"].GetValue())
          except ValueError:
              xMin = 0
          try:
              xMax = int(self.options["xMax"].GetValue())
          except ValueError:
              xMax = 512
          try:
              yMin = int(self.options["yMin"].GetValue())
          except ValueError:
              yMin = 0
          try:
              yMax = int(self.options["yMax"].GetValue())
          except ValueError:
              yMax = 512
          return (xMin,xMax,yMin,yMax)
  
      def setPosMin(self,x,y):
          """Takes the x and y coordinates for the NW corner of the ROI."""
          self.options["xMin"].SetValue(str(x))
          self.options["yMin"].SetValue(str(y))
  
      def setPosMax(self,x,y):
          """Takes the x and y coordinates for the SE corner of the ROI."""
          self.options["xMax"].SetValue(str(x))
          self.options["yMax"].SetValue(str(y))
#+end_src

#  LocalWords:  wxWidget SNS numpy DAQmx DAC XMLRPC PowerSupply


** Graph Panel

   The =GraphPanel= module creates a single filled-line plot that can
   be embedded in a wxWidgets frame.  It's used by PelVis to present
   the detector image integrated along axis.

*** Graph Panel Skeleton

#+begin_src python :tangle GraphPanel.py :noweb tangle :padline no
"""Classes for adding sumlines to frames

This module contains a single class, GraphPanel, which plots two dimensional
data filled along a chosen axis.  This class was originally designed for giving
the summation of a matrix along a given axis, but there's not reason that it
couldn't be expanded for other purposes.

"""

import numpy as np

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx import NavigationToolbar2Wx
from matplotlib.figure import Figure
#import matplotlib.cm as cm

import wx

<<graphpanel_rebin>>

class GraphPanel(wx.Panel):
    """This class creates a panel that displays a filled plot. """

    
    HORIZONTAL = 0 
    INVERTED = 1
    VERTICAL = 2
    <<graphpanel_init>>
    <<graphpanel_setplot>>

#     def SetYLim(self,range):
#         self.axes.set_ylim(range)

#     def SetXLim(self,range):
#         self.axes.set_xlim(range)

    <<graphpanel_setpos>>

    <<graphpanel_onpaint>>

#+end_src


*** rebin function

The rebin function takes an numpy array and an integer of how many
bins to combine.  The result is a new numpy array where each group of
=count= bins have been averaged together.

This is non-intuitive and the =mean= function should be replaced with
a =sum= to make the results more obvious.

This function is no longer in use and should probably be removed.

#+name:graphpanel_rebin
#+begin_src python
# FIXME:  This function is extremely brittle
def rebin(a,count):
    """A quick function to rebin an array

    This function takes an array and rebins it into a smaller array.
    Note that, if the length of the array isn't divisible by the binning
    factor, the end of the array will be truncated.  This is probably
    not a sane default, but I don't have any better ideas.

    Keyword arguments:
    a -- The numpy array to be rebinned.
    count -- The number of bins to be combined.  For instance, if the array
             has a length of 100 and the count is 4, the return value
             will have a length of 25

    """

    return np.array([a[i:i+count].mean() for i in range(0,len(a),count)])
#+end_src

*** Initialization

     A =GraphPanel= object needs four parameters.  The first is the
     =parent=, which holds the container in which the panel will be
     displayed.  The second, =fig=, is a tuple with the relative
     dimensions of the panel.  For instance, if =fig= is =(2,3)=, then
     the panel will be two units wide and three units tall.  The =res=
     parameter gives the number of pixels per unit for the dimensions
     in =fig=.  Finally, the orientation is either
     =GraphPanel.HORIZONTAL=, =GraphPanel.INVERTED=, or
     =GraphPanel.VERTICAL=.  A =HORIZONTAL= gives a graph with the
     x-axis along the bottom and the y-axis pointing up.  =VERTICAL=
     has it's x-axis along the right edge and the y-axis pointing
     left.  Finally, =INVERTED= has it's x-axis along the top and the
     y-axis pointing downward.

     Just as with the =[[Image Panel]]=, the object contains a matplotlib
     =Figure= and a wxAgg =FigureCanvas= to do the actual plotting.

#+name:graphpanel_init
#+begin_src python
    def __init__(self,parent,fig,res,orientation):
        """Create a new panel for plotting.

        Keyword Arguments:
        parent -- the panel in which the new one is to be displayed
        fig -- a tuple representing the relative dimensions of the panel
        res -- the number of pixels per part of the fig tuple.
        orientation -- the rotation of the image

        fig and res combine to produce the total size, in pixels, of the
        panel.  For instance, if fig=(2,8) and res=64, the final panel
        has a size of (128,512)

        The orientation can be one of HORIZONTAL, VERTICAL, or INVERTED,
        as defined as constants in the class definition. Horitzontal uses
        the standard x and y axes, and is best for putting above a 2d image.
        VERTICAL swaps the x and y axes and is best for going to the right
        of an image.  INVERTED plots with x and -y, and is best below the image.

        """
        wx.Panel.__init__(self,parent)
        self.Bind(wx.EVT_PAINT,self.__OnPaint)
        #The actual figure for plotting
        self.figure = Figure(figsize=fig,dpi=res)
        #The space where th figure is drawn
        self.canvas = FigureCanvas(self,-1,self.figure)
        #The rotation of the figure.
        self.orientation=orientation
#+end_src



*** Plotting

     The =SetPlot= function gives the panel its data for plotting.
     The first variable is an array of the x-coordinate and the second
     is the y-coordinates.

#+name:graphpanel_setplot
#+begin_src python
    def SetPlot(self,x,y):
        """Set the x and y coordinates of the data to be plotted."""
        self.figure.clear()
        self.axes = self.figure.add_subplot(111)
        #We rebin the data in steps of four to smooth out the dead PMTs
        #If all of the PMTs have been fixed, this step could be taken out.
        if self.orientation==self.INVERTED:
            self.axes.fill_between(x,y)
            self.SetPos([0,0.1,1,0.9])
            self.axes.set_xlim((0,np.max(x)))
            #Reverse the order of the limits to get an inverted graph
            self.axes.set_ylim((np.max(y),0))
        elif self.orientation==self.HORIZONTAL:
            self.axes.fill_between(x,y)
            self.SetPos([0.1,0.1,0.9,0.9])
            self.axes.set_xlim((0,np.max(x)))
            self.axes.set_ylim((0,np.max(y)))
        else:
            #Notice that we now fill along the x axis
            self.axes.fill_betweenx(x,-y)
            self.SetPos([0.2,0,0.8,1])
            self.axes.set_ylim((0,128))

        self.axes.autoscale_view(True,True,True)
        self.Refresh()
#+end_src

     The =SetPlot= function uses =SetPos= to move the graph around
     within the panel.  We want the graph to extend across the whole
     panel, but, by default, matplotlib takes some space for the
     axes.  We use =SetPos= to tell matplotlib to only use the part of
     the plot that contains the actual graph.

#+name:graphpanel_setpos
#+begin_src python
    def SetPos(self,pos):
        """Set the position of the graph within the panel.

        This function take a four element array which marks the far
        corners of the graph.  The coordinates are given as a fraction
        of the size of the panel.  For instance, pos=[0,0.3333,1,0.6666]
        would produce a graph that stretches across the panel in the x
        direction, but only uses the middle third in the y direction.
        You will probably need to play with these values in order to be 
        able to view the values of the axes on the plot.

        """
        self.axes.set_position(pos)
#+end_src

     We need to override the =OnPaint= event handler to tell the
     =FigureCanvas= to redraw the graph every time the panel is
     redrawn.

#+name: graphpanel_onpaint
#+begin_src python
    def __OnPaint(self,event):
        """An event handler to tell the canvas to draw
        when the panel is redrawn."""
        self.canvas.draw()
        event.Skip()
#+end_src




** Image Panel

   The Image Panel is a custom widget for displaying a 2D array of
   data.  It forms the largest part of the graphical representation
   of the data in PELVis.

*** Image Panel Skeleton

#+begin_src python :tangle ImagePanel.py :noweb tangle :padline no
"""This module contains classes which help in displaying 2D data

This module currently contains one class: ImagePanel.  The imagePanel
takes a 2D array and displays it as a color plot.

"""

import numpy as np

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx import NavigationToolbar2Wx
from matplotlib.figure import Figure
import matplotlib.cm as cm

import wx


if __name__ == "__main__":
    print "Hello World";

class ImagePanel(wx.Panel):
    """This class displays 2D data as a color plot"""
    <<imagepanel_init>>

    <<imagepanel_events>>

    <<imagepanel_update>>


    <<imagepanel_saveImage>>

    <<imagepanel_copytoclipboard>>

#+end_src


*** Initialization

     The panel is constructed with a couple of arguments.  The first
     is simply the parent frame where the image is to be displayed.
     It then takes three callback functions.  The =posFunction=
     callback is called every time the mouse is moved within the
     panel.  The =setMin= function is called every time the user
     performs a left click, which will set the upper left hand corner
     of the region of interest.  Finally, the setMax function is
     called every time the user performs a right click, which should
     set the lower right corner of the region of interest.

#+name:imagepanel_init
#+begin_src python
    def __init__(self,parent,posFunction=None,setMin=None,setMax=None):
        """This creates an ImagePanel
        
        Keyword arguments:
        parent -- The container which will hold the panel
        posFunction -- function to be updated with mouse position
        setMin -- function to be called on left click
        setMax -- function to be called on right click

        """
        wx.Panel.__init__(self,parent)
        self.Bind(wx.EVT_PAINT,self.__OnPaint)
        self.posFunction = posFunction#Function to call on mouse movement
        self.setMin = setMin#Function to call on right click
        self.setMax = setMax#Function to call on left click
#+end_src
     
     The =figure= member is the actual matplotlib graph that displays
     the detector image.  We set it to 512 pixels by 512 pixels, as
     its easier to read than a true 128 pixel by 16 pixel plot. The
     =FigureCanvas= is then the wxWidget which lets us embed the graph
     into the window.  It's provided by the backend_wxagg module from
     matplotlib.

     We bind the mouse events to three private member functions and
     set the default spectrum to =spectral=.

#+name:imagepanel_init
#+begin_src python
    #The figure which holds the graph
        self.figure = Figure(figsize=(1,1),dpi=512)
        #The object where the graph is drawn
        self.canvas = FigureCanvas(self,-1,self.figure)
        self.canvas.Bind(wx.EVT_MOTION,self.__OnMouseMove)
        self.canvas.Bind(wx.EVT_LEFT_UP,self.__OnMouseLeft)
        self.canvas.Bind(wx.EVT_RIGHT_UP,self.__OnMouseRight)
        
        self.cmap = cm.spectral#The color map for the graph
#+end_src

     Finally, the =handlers= member is a dictionary of all of the
     image file formats that wxWidgets knows for file encoding.  If
     wxWidgets adds a new image file format, this dict will need to be
     updated manually, but it's unlikely that they'll add any news
     formats any time soon.

#+name:imagepanel_init
#+begin_src python
    #Known file formats for saving images
        self.handlers={u"BMP":wx.BITMAP_TYPE_BMP,
                        u"JPG":wx.BITMAP_TYPE_JPEG,
                        u"PNG":wx.BITMAP_TYPE_PNG,
                        u"PCX":wx.BITMAP_TYPE_PCX,
                        u"PNM":wx.BITMAP_TYPE_PNM,
                        u"TIF":wx.BITMAP_TYPE_TIF}
#+end_src


*** Event Handling

     When an event occurs, it calls the bound callback function with a
     single =Event= object.  This event contains the information that
     the callback needs to perform its duties (e.g. a mouse click
     event will have the mouse position).  We can either eat the
     event, which is the default, or pass the event on by calling
     =event.Skip=.  This allows the event to trigger multiple
     callbacks.

     There are four events that we need to be able to handle.  The
     simplest one is when the graphics need to be updated.  We force
     the FigureCanvas to draw itself, then pass the event on to any
     other handlers.

#+name:imagepanel_events
#+begin_src python
    def __OnPaint(self,event):
        """Event handler to redraw graph when panel is redrawn."""
        self.canvas.draw()
        event.Skip()
#+end_src

     The =OnMouseMove= function is bound to events triggered by the
     mouse moving through the Image Panel.  The current position on
     the 512 by 512 panel is converted back into the actual pixels in
     the neutron data.

#+name:imagepanel_events
#+begin_src python

    def __OnMouseMove(self,event):
        """Event handler when the mouse moves over the graph"""
        (x,y) = event.GetPosition()
        if self.posFunction is None: return
        self.posFunction(x/32,y/4)
#+end_src

     =OnMouseLeft= is triggered by the user left clicking on the image
     panel.  The position is then converted back to the raw detector
     pixel and passed to the =setMin= function.  =OnMouseRight is
     identical, except the raw position is passed to =setMax=.

#+name:imagepanel_events
#+begin_src python

    def __OnMouseLeft(self,event):
        """Event handler for left clicking on the graph."""
        (x,y) = event.GetPosition()
        if self.setMin is None: 
            None
        else:
            self.setMin(x/32,y/4)
        event.Skip()

    def __OnMouseRight(self,event):
        """Event handler for right clicking on the graph."""
        (x,y) = event.GetPosition()
        if self.setMax is None: 
            None
        else:
            self.setMax(x/32,y/4)
        event.Skip()
#+end_src

     While not strictly an event, the outer PELVis frame has a menu
     event that will call =saveImage= to put the 


*** Data Handling

     The single most important part of the Image Panel is the =update=
     function, which gives the Image Panel the data to display.  It
     expects a 2d array of numbers, as well as a minimum and maximum
     value (i.e. =vmin= and =vmax=) for the range on the numbers.  The
     display is clamped to those values.

     Currently, each pixel is drawn as a solid block of constant
     color.  Changing the =interpolation= parameter of =imshow= from
     ='none'= to ='bicubic'= will create a much smoother transition,
     but it will also be harder to identify the pixel boundaries.

#+name:imagepanel_update
#+begin_src python
    def update(self,data,vmin=10,vmax=20):
        """Change the dataset for the graph

        Keyword arguments:
        data -- 2D numpy array
        vmin -- floor value for graphing
        vmax -- ceiling value for graphing

        """
        self.data=data
        self.figure.clear()
        self.figure.add_axes((0,0,1,1),autoscale_on=True,frameon=False,yticks=[0,1],xticks=[0,1])
        self.figure.get_axes()[-1].get_xaxis().set_visible(False)
        self.figure.get_axes()[-1].get_yaxis().set_visible(False)
        self.figure.get_axes()[-1].imshow(data,cmap=self.cmap,vmin=vmin,vmax=vmax,aspect="auto",interpolation='none')
        self.figure.canvas.draw()
        self.Refresh()
#+end_src


     The =saveImage= function takes the current display of the panel
     and saves it to a file.  As a quick walk through, we begin by
     creating an empty bitmap.  We then create a drawing context on
     top of this bitmap, which allows wxWidgets to treat the bitmap as
     though it were just more pixels on the screen.  We then tell the
     canvas to draw into this context, as opposed to on the screen.
     This buts the actual pixel information into the bitmap.  We then
     take this bitmap, which is hardware dependent on the computer,
     and turn it into a device independent Image.  This image is then
     saved to a file.

#+name:imagepanel_saveImage
#+begin_src python

    def saveImage(self,path):
        """Saves the graph to an image file"""
        bitmap = wx.EmptyBitmap(512,512,24)
        memdc = wx.MemoryDC(bitmap)
        self.figure.canvas.draw(memdc)
        image = wx.Bitmap.ConvertToImage(bitmap)
        image.SaveFile(path,self.handlers[path[-3:].encode('ascii')])
#+end_src

     As similar procedure is used to copy the image into the
     clipboard.  The only difference is that we create a
     =BitmapDataObject= instead of an =Image=, since that's that the
     clipboard expects.

#+name:imagepanel_copytoclipboard
#+begin_src python

    def copyToClipboard(self):
        """Copies the image of the graph to the system Clipboard."""
        if wx.TheClipboard.Open():
            bitmap = wx.EmptyBitmap(512,512,24)
            memdc = wx.MemoryDC(bitmap)
            self.figure.canvas.draw(memdc)
            wx.TheClipboard.Clear()
            wx.TheClipboard.SetData(wx.BitmapDataObject(bitmap))
            wx.TheClipboard.Close()
#+end_src


** Color Bar Panel

   
*** Color Bar Skeleton

    The skeleton for the color bar panel also handles the [[Action Color
    Bar]] and the [[Color Bar Picker]].  All three are used for displaying
    and chosing a maping between an intensity and a color for display
    of the 2D detector data.

#+begin_src python :tangle colorbarpanel.py :noweb tangle :padline no
"""Classes for handling color spectra

This module implements a series of classes for handling the different color
spectra produced by matplot lib.  The basic class is ColorBarPanel, which
simply displays a given color map.  ActionColorbar subclasses ColorBarPanel
to add simple click response abilities.  Finally, ColorBarPicker gives the
user the ability to select any of the color maps that matplotlib is aware of.
Note that ColorBarPicker takes time to render when it first loads, so care
should be taken not to create one unless it's necessary and then to keep
that same on for as long as possible.

"""

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx import NavigationToolbar2Wx
from matplotlib.figure import Figure
from matplotlib.colorbar import ColorbarBase
from matplotlib.colors import Normalize
import matplotlib.cm as cm

import wx

class ColorBarPanel(wx.Panel):
    """Panel to display a ColorBar in a wxWidgets container."""
    <<colorbarpanel_init>>    
    <<colorbarpanel_setrange>>
    <<colorbarpanel_setcmap>>
    <<colorbarpanel_update>>
        
    <<colorbarpanel_onpaint>>

<<actioncolorbar>>

<<colormappicker>>



if __name__ == '__main__':
    def printcmap(cmap):
        print(cmap)

    app=wx.PySimpleApp()
    frame = ColorMapPicker(None,printcmap)
    frame.Show()
    app.MainLoop()

#+end_src

*** Initialization

    The color bar panel takes several parameters

    - parent :: The container for the panel
    - cmap :: A starting color bar for the panel
    - fig :: A tuple containing the dimensions of the panel in
             arbitrary units.  For example, the value of (2,3) would
             make the panel two units tall by three units wide.  The
             default value is (1,10), which fits in with the layout of
             the PELVis frame.
    - res :: The number of pixels per unit in fig.
    - orientation :: The direction along which the color bar's
                     spectrum is encoded.  If the value is the string
                     'vertical', the rainbow will progress from top
                     to bottom.  To have the rainbow move from left to
                     right, set the value to 'horizontal'.
    - size :: By default, matplotlib includes a scale on the color bar
              panel.  This is useful along the axis of the rainbow,
              but rather obviously useless in the other direction.
              The size command picks a subset of the colorbar to
              eliminate the extra axis.

    As with other panels, the general framework is a matplotlib
    =Figure= and a wxAgg =FigureCanvas= to provide the actual graphing
    components. 

#+name:colorbarpanel_init
#+begin_src python
    def __init__(self,parent,cmap,fig=(1,10),
                 res=64,orientation='vertical',
                 size=[0.05,0.025,.25,0.95]):
        """Creates a ColorBarPanel.

        Keyword arguments:
        parent -- container which holds the panel.
        cmap -- the color map to display in the color bar.
                This should be a matplotlib cmap object
        fig -- the relative width to height of the color bar
        res -- the number of pixels per unit in fig
        orientation -- the rotation of the color bar
        size -- the position of the color bar in the panel

        res and size combine to produce the actual size of the
        panel in pixels.  For instance, with fig=(1,10) and res=64,
        the panel will be 64 pixels wide and 640 pixels tall.

        size is a four element array which marks the far
        corners of the graph.  The coordinates are given as a fraction
        of the size of the panel.  For instance, pos=[0,0.3333,1,0.6666]
        would produce a graph that stretches across the panel in the x
        direction, but only uses the middle third in the y direction.
        The default value should allow the axes to be seen.

        """

        wx.Panel.__init__(self,parent)
        self.Bind(wx.EVT_PAINT,self.__OnPaint)

        self.figure = Figure(figsize=fig,dpi=res)#the actual plot
        #the object to display the plot
        self.canvas = FigureCanvas(self,-1,self.figure)
        #the direction of the color bar
        self.orientation=orientation
        #the color map to use
        self.cmap=cmap
        self.vmin=0 #The minimum value on the color bar
        self.vmax=18 #The maximum value on the color bar
        self.size=size #The position of the color bar in the frame
        self.update()

#+end_src

*** Display

    The =update= function replots thecolor bar.  This is necessary
    after any of the parameters have changed.

#+name:colorbarpanel_update
#+begin_src python
    def update(self):
        """Reacts to any changes in the objects members."""
        axes = self.figure.add_axes(self.size)
        norm = Normalize(vmin=self.vmin,vmax=self.vmax)
        colorbar = ColorbarBase(axes,cmap=self.cmap,norm=norm,
                                orientation=self.orientation)
        self.Refresh()
#+end_src

    As with any graphical widget, we need to intercept the OnPaint
    event to ensure that the graph is drawn onto the panel.

#+name:colorbarpanel_onpaint
#+begin_src python
    def __OnPaint(self,event):
        """An event handler to update the graph when the panel is redrawn."""
        self.canvas.draw()
        event.Skip()
#+end_src


*** Configuration

    The =setRange= function choses the domain over which the colarbar
    will map values into colors.

#+name:colorbarpanel_setrange
#+begin_src python
    def setRange(self,vmin,vmax):
        """Set the range for the axes on the colorbar."""
        self.vmin=vmin
        self.vmax=vmax

#+end_src

    The =setCmap= function sets the color map for the panel.

#+name:colorbarpanel_setcmap
#+begin_src python
    def setCmap(self,cmap):
        """Pick the colormap to display."""
        self.cmap = cmap
#+end_src



** Action Color Bar

   The Action Color Bar is a color bar that also functions as a
   button.  The class itself lives in the [[Color Bar Skeleton][colorbar]] module.  It's
   primary purpose is to provide a clickable colorbar for the [[Color Bar Picker][picker]].

#+name:actioncolorbar
#+begin_src python
class ActionColorbar(ColorBarPanel):
    """A simplistic colorbar button

    This class displays a colormap and returns the name of its colormap
    to a given function when clicked on by the user.

    """
#+end_src

   The initialization is much simpler than for the [[Color Bar Panel][Color Bar Panel]].
   - parent :: The container to hold the action color bar
   - cmap :: The actual color map for the color bar
   - command :: The function to be called when the color bar is clicked

#+name:actioncolorbar
#+begin_src python
#
    def __init__(self,parent,cmap,command):
        """Creates an ActionColorbar

        Keyword arguments:
        parent -- the container to hold the panel.
        cmap -- a string naming a colormap.
        command -- the function to run when the colormap is clicked.

        """
        #title attribute is needed by update, which is called by init
        self.title=cmap#The title of the colormap
        ColorBarPanel.__init__(self,parent,cm.get_cmap(cmap),fig=(5,1),orientation='horizontal',size=[0,0,1,0.6])
        self.comm = command#The command to run on clicks
        self.canvas.Bind(wx.EVT_LEFT_UP,self.__OnClick)
#+end_src

   The =update= function is identical to that of the regular Color Bar
   Panel, except that a title has been added to the figure so that
   it's possible to know the name of the color map being clicked.

#+name:actioncolorbar
#+begin_src python
#
    def update(self):
        """Reacts to any changes in the objects members."""
        axes = self.figure.add_axes(self.size,title=self.title)
        norm = Normalize(vmin=self.vmin,vmax=self.vmax)
        colorbar = ColorbarBase(axes,cmap=self.cmap,norm=norm,
                                orientation=self.orientation)
        self.Refresh()
#+end_src

   =__OnClick= is the event handler for when the user left clicks on
   the action bar.  It calls the command using the current color map
   as its only argument.

#+name:actioncolorbar
#+begin_src python
#
    def __OnClick(self,event):
        """Event handler to call self.comm when the panel is clicked."""
        self.comm(self.cmap)
        event.Skip()
#+end_src


** Color Map Picker

   The color map picker is a dialog box which presents all of the
   color maps know to matplotlib and allows the user to chose one by
   clicking on it.

   Since it generates so many graphs (one for each color map), it can
   take quite a while to load.  It's usually only generated the first
   time that the user calls for it and is not regenerated as long as
   the program runs.

#+name:colormappicker
#+begin_src python
class ColorMapPicker(wx.Frame):
    """A window for selecting a color map"""
#+end_src 

   The initialization takes only two parameters.  The first is a
   parent window that the dialog will be attached to.  If the parent
   is =None=, the picker will be the main application window.  The
   second parameter expects a function that takes one string
   argument.  Whenever the user clicks on a color map, this function
   is called on the name of the color map.

   The =cm.datad.keys= function returns a list of all of the color
   maps known to matplotlib.

#+name:colormappicker
#+begin_src python
#
    def __init__(self,parent,command):
        """Creates a ColorMapPicker

        Keyword arguments:
        parent -- parent of this frame or None
        command -- function to be called on the chosen colormap name

        """
        wx.Frame.__init__(self,parent,wx.ID_ANY,"Maps",size=(345,355))
        scroll = wx.ScrolledWindow(self,-1)
        sizer = wx.BoxSizer(wx.VERTICAL)
        keys = cm.datad.keys()
        #Iterate through all of the colormap names
        for key in keys[:]:
            sizer.Add(ActionColorbar(scroll,key,command))
            scroll.SetScrollbars(0,64,0,64)
        sizer.SetSizeHints(scroll)
        scroll.SetSizer(sizer)
        self.Bind(wx.EVT_CLOSE,self.__OnClose)
#+end_src 

   Since the window takes so long to create, we don't want to recreate
   it each time it is called for.  To this end, we're overriding the
   Close event and ignoring it, simply hiding the window instead.

#+name:colormappicker
#+begin_src python
#
    def __OnClose(self,event):
        """Event handler for closing the window

        Since the window takes so long to build and render, we
        don't want to be forces to make a new one each time it's
        closed, so we merely hide it when the user closes it."""
        self.Hide()
#+end_src


** Graph Frame

   The Graph Frame module provides a class for easily displaying 2D
   line plots.  It's used by [[MonFile][MonFile]] and [[Spectrum Dialog]] to give
   information versus wavelength.

   The frame largely serves the same purpose ad
   matplotlib.pyplot.plot, but it works well with the wx backend that
   we're using for the rest of the PelVis application and try to start
   its own main loop.  If you're writing a console application that
   just needs to draw a couple of graphs, you're better off just
   working straight through matplotlib.

*** GraphFrame Skeleton

#+begin_src python :tangle graphframe.py :noweb tangle :padline no
"""Convenience classes for plotting data

This module contains a single class, GraphFrame, which is used for easily
plotting two dimensional data.  If other such convenience classes are
ever to be written, they should be put into this module.

"""

import wx

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx import NavigationToolbar2Wx
from matplotlib.figure import Figure

class GraphFrame(wx.Frame):
    """
    This class merges wxWidgets and matplotlib to produce an 
    independent frame which can display a two dimensional
    plot fo arbitrary data.

    """
    ID_COPY = 500
    <<graphframe_init>>

    def __PanelPaint(self,event):
        """Event handler to tell the canvas to 
        redraw when the window is drawn."""
        self.canvas.draw()
        event.Skip()

    <<graphframe_oncopy>>

    <<graphframe_plot>>

#+end_src

*** Initialization
#+end_src

    The frame begins with two parameters.  The first is a parent
    window, which can be =None= to make this window independent.  The
    second is an optional tital to display in the window's titlebar.

    The constructor begins by performing the basic construction of a
    frame and creating a panel with a custom paint handler. 

#+name:graphframe_init
#+begin_src python
    def __init__(self,parent=None,title=""):
        """Creates a new frame for displaying graphs

        Keyword arguments:
        parent -- the parent frame of the new frame
        title -- the title for the frame.  This is not the title
                 for the graph.

        """
        wx.Frame.__init__(self,parent,wx.ID_ANY,title)

        self.panel = wx.Panel(self)
        self.panel.Bind(wx.EVT_PAINT,self.__PanelPaint)
#+end_src

    We add a menu bar purely to handle the =Copy= command.  We use this
    to allow the user to copy the graph to the clipboard, saving the
    effort of writing the image to a disk and loading it up in another
    application.  Establishing the menu also bounds the copy command
    to the =Ctrl-c= hotkey.

#+name:graphframe_init
#+begin_src python
    #
        menubar = wx.MenuBar()
        editmenu = wx.Menu()
        editmenu.Append(self.ID_COPY,"&Copy\tCtrl-C"," Copy image to the clipboard")
        self.Connect(self.ID_COPY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnCopy)
        menubar.Append(editmenu,"&Edit")
        self.SetMenuBar(menubar)
#+end_src

    We create a matplotlib =Figure= and a wxAgg =FigureCanvas= to
    handle the actual plotting.  The matplotlib wx backend also
    provides a convenient Navigation Toolbar that is identical to the
    one used by =pyplot.plot= and allows the user to scale and
    translate the graph at will.  The toolbar also handles saving the
    image to a file.

#+name:graphframe_init
#+begin_src python
    #   

        #First, make the plotting figure.
        self.figure = Figure()
        #Then give the figure somewhere to display.
        self.canvas = FigureCanvas(self.panel,-1,self.figure)
        #Finally, make a Toolbar to adjust the canvas at runtime.
        self.toolbar = NavigationToolbar2Wx(self.canvas)
        self.toolbar.Realize()
#+end_src

    Finally, everything is added to the panel and the sizers are set.

#+name:graphframe_init
#+begin_src python
    #
        sizer = wx.GridBagSizer()
        sizer.Add(self.canvas,pos=wx.GBPosition(1,0))
        sizer.Add(self.toolbar,pos=wx.GBPosition(0,0))
        sizer.SetSizeHints(self)
        self.SetSizer(sizer)
#+end_src



*** Image Export

    The =plot= function handles actualling turning data points into a
    graph.

    - x :: An array of the x-coordinates of the data
    - y :: An array of the y-coordinates of the data
    - range :: An optional tuple of the minimum and maximum y values
               to plot.  Useful for handling things like flipping
               ratios, where most of the values will probably be
               around 30, but a low statistics data point out at 18 
               will suddenly take the plot up to five million.  If the
               range is =None=, then the graph will auto-scale
    - xerr :: An optional array of the uncertainties on the
              x-coordinates.  If =None=, then no x errorbars are used.
    - yerr :: An optional array of the uncertainties of the
              y-coordinates.  If =None, then no y errorbars are used.

#+name:graphframe_plot
#+begin_src python
    def plot(self,x,y,range=None,xerr=None,yerr=None):
        """Plots 2D data in the frame

        This method is the main workhorse of the class.  It plots
        a line representing the x and y data, with optional errorbars.

        Keyword arguments:
        x -- numpy array of x coordinates
        y -- numpy array of y corrdinates
        range -- either a tuple with the minimum and maximum y values,
                 or None for autoscaling
        xerr -- numpy array of the errors in the x direction
        yerr -- numpy array of errors in the y direction

        """
        self.figure.clear()
        axes = self.figure.add_subplot(111)
        print(x.shape)
        print(y.shape)
        axes.errorbar(x,y,xerr=xerr,yerr=yerr)
        if range==None:
            axes.autoscale_view(True,True,True)
        else:
            (vmin,vmax)=range
            axes.set_ylim(vmin,vmax)
            axes.autoscale_view(True,True,False)
        self.Show()
#+end_src

    The =OnCopy= function is an event handler for the user requesting
    that the graph be copied to the clipboard.  A new bitmap is made
    that is the current size of the canvas.  The figure is then drawn
    onto this bitmap and the bitmap is passed to the clipboard.

#+name:graphframe_oncopy
#+begin_src python
    def OnCopy(self,event):
        """Copies the image of the graph to the system Clipboard"""
        if wx.TheClipboard.Open():
            print(self.canvas.GetSize())
            w,h=self.canvas.GetSize()
            bitmap = wx.EmptyBitmap(w,h,24)
            memdc = wx.MemoryDC(bitmap)
            self.figure.canvas.draw(memdc)
            wx.TheClipboard.Clear()
            wx.TheClipboard.SetData(wx.BitmapDataObject(bitmap))
            wx.TheClipboard.Close()
#+end_src



** Spectrum Dialog

   The Spectrum Dialog presents a dialog box to the user which
   presents the user options on what they would like to do with the
   spectrum information passed by PELVis.  The information can be
   given custom wavelength binning and either plotted to the screen or
   saved in an ASCII file.

*** Spectrum Dialog Skeleton

#+begin_src python :tangle SpectrumDialog.py :noweb tangle :padline no
"""Classes for dealing with neutron spectra

This module contains a single class:  SpectrumDialog.  This dialog
handles all of the options and parameters for creating spectrum
plots of intensities and polarization.  This class also handles
automated rebinning of data.

"""

import wx
import numpy as np
from graphframe import GraphFrame

RESOLUTION = 400

class SpectrumDialog(wx.Dialog):
    """A dialog to set the options on a spectrum plot"""

    <<spectrumdialog_init>>
    <<spectrumdialog_setdata>>
    <<spectrumdialog_setscale>>
    <<spectrumdialog_setintensityrange>>

    <<spectrumdialog_onview>>

    <<spectrumdialog_onsave>>

    <<spectrumdialog_setmode>>

    <<spectrumdialog_autobinset>>

    <<spectrumdialog_autobin>>
    <<spectrumdialog_modefunctions>>
#+end_src

*** Initialization

    The only parameter for the constructor on the SpectrumDialog is
    the parent frame for the dialog.  The constructor begins by
    calling the constructor of its superclass to make the actual
    dialog box.

#+name:spectrumdialog_init
#+begin_src python
    def __init__(self,parent=None):
        """Create a SpectrumDialog"""
        wx.Dialog.__init__(self,parent,wx.ID_ANY,"Spectrum Options")
        sizer = wx.GridBagSizer()
#+end_src

    The class has two members for the data.  =up= is the count of the
    neutrons per wavelength bin in the spin up state and and =down= is
    the count of the neutrons per wavelength bin in the spin down state.

#+name:spectrumdialog_init
#+begin_src python
    #
        self.up = None #The spin up data array
        self.down = None #The spin down data array
#+end_src

    The =mode= member is a dictionary to convert between a mode string
    sent by the application and the function which handles that form
    of data.  The =calSpec= function should point to the current
    processing function.

#+name:spectrumdialog_init
#+begin_src python
    #

        #A dictionary of the available manipulations to perform
        #on the data before plotting it.
        self.modes = {"up":self.spinUp,
                      "down":self.spinDown,
                      "polar":self.polar,
                      "flipping":self.flipping}
        self.calcSpec = self.spinUp #The current data manipulation function
#+end_src

    Two buttons are added to the bottom of the dialog to allow the
    user to either view the image on the screen or save the data to an
    ASCII file.

#+name:spectrumdialog_init
#+begin_src python
    #
        
        saveButton = wx.Button(self,-1,"Save Spectrum")
        viewButton = wx.Button(self,-1,"View Spectrum")
        viewButton.Bind(wx.EVT_BUTTON,self.onView)
        saveButton.Bind(wx.EVT_BUTTON,self.onSave)
#+end_src

    A single text box is added with the label "Minimum Percent
    Error".  This label is horribly misleading and should be changed.
    In auto-binning mode, it does allow the user to input the minimum
    percentage error.  However, in fixed binning mode, the value is
    used to the maximum number of bins.

#+name:spectrumdialog_init
#+begin_src python
    #
        
        sizer.Add(wx.StaticText(self,-1,"Minimum Percent Error"),
                  pos=wx.GBPosition(0,0), flag=wx.EXPAND)
        #An input box for the user's chosen percentage error
        self.minerr = wx.TextCtrl(self,-1,"10")
        sizer.Add(self.minerr,pos=wx.GBPosition(0,1), flag=wx.EXPAND)
#+end_src

    Three radio buttons allow the user to pick the binning mode.

#+name:spectrumdialog_init
#+begin_src python
    #    

        #A checkbox for whether the user wants the data autobinned
        self.nobinrad = wx.RadioButton(self,-1,"Raw Data",style=wx.RB_GROUP)
        self.autobinrad = wx.RadioButton(self,-1,"Auto binning")
        self.setbinrad = wx.RadioButton(self,-1,"Fixed Binning")
#+end_src

    Finally, everything needs to be added to the actual panel

#+name:spectrumdialog_init
#+begin_src python
    #
        sizer.Add(self.nobinrad,wx.GBPosition(1,0),flag=wx.EXPAND)
        sizer.Add(self.autobinrad,wx.GBPosition(1,1),flag=wx.EXPAND)
        sizer.Add(self.setbinrad,wx.GBPosition(1,2),flag=wx.EXPAND)
        
        sizer.Add(saveButton,pos=wx.GBPosition(2,0),flag=wx.EXPAND)
        sizer.Add(viewButton,pos=wx.GBPosition(2,1),flag=wx.EXPAND)
        sizer.SetSizeHints(self)
        self.SetSizer(sizer)

#+end_src



*** Configuration

    The =setData= function gives the actual neutron count arrays to
    the Spectrum Dialog.  If there is only one spin state, it is put
    in the =up= member and the =down= member is set to none.  Since
    both arrays are supposed to represent neutron counts, we set any
    data points less than zero equal to zero, since you can't have a
    negative count.  This prevents issues like having the polarization
    go above one or the flipping ratio being negative.

#+name:spectrumdialog_setdata
#+begin_src python
    def setData(self,up,down=None):
        """Sets the spin up and spin down spectra.  Expects two numpys arrays"""
        del self.up
        del self.down
        up[up < 0.0] = 0.0
        if down is not None:
            down[down < 0.0] = 0.0
        self.up=up
        self.down=down
#+end_src

    The array received by =setData= are normalized to monitor count.
    The uscale and dscale variables are the total monitor counts in
    the up and down states, respectively.  This allows us to recover
    the raw counts so that we can calculate the uncertainties from the
    counting statistics.

#+name:spectrumdialog_setscale
#+begin_src python
    def setScale(self,up,down=None):
        """Sets the scaling constants for the spin up and spin down states.

        To calculate error, we need the raw neutron counts, not just the
        monitor normalized ones.  This function accepts the monitor counts
        used to do the initial scaling on the detector data, so that
        the raw counts can be recalculated.

        """
        self.uscale=up
        self.dscale=down
#+end_src

    When the data is being plot, it can be helpful to clamp the range
    of the plot.  The =setIntensityRange= function accepts a tuple
    with the minimum and maximum values for the plot range.

#+name:spectrumdialog_setintensityrange
#+begin_src python
    def setIntensityRange(self,range):
        """Set the minimum and maximum y axis for plotting"""
        self.vmin,self.vmax = range
#+end_src

    Currently, the spectrum dialog supports plotting the spin up
    intensity, the spin down intensity, the polarization, and the
    flipping ratio, all versus wavelength.  The =setmode= function
    choses the mode with one of the keys of the =modes= member and
    adjust =calcSpec= accordingly.

#+name: spectrumdialog_setmode
#+begin_src python
    def setMode(self,mode):
        """Chooses the calculation to perform on the data

        Keyword arguments:
        mode -- a string describing which function out of self.modes
                should be performed on the data.

        """
        self.calcSpec = self.modes[mode]
#+end_src


*** Buttons

    The =onView= function is called when the user clicks on the =View=
    button.  The actual data to plot is calculated by the =calcSpec=
    function and then displayed by a [[Graph Frame][GraphFrame object]].

#+name: spectrumdialog_onview
#+begin_src python
    def onView(self,event):
        """Display a graph of the spectrum."""
        x,y,e = self.calcSpec()
        graph = GraphFrame(self,"Spectrum")
        graph.plot(x,y,range=(self.vmin,self.vmax),yerr=e)
        self.Show(False)
#+end_src


    The =onSave= function is called when the user clicks on the =Save=
    button.  The actual data to plot is calculated by the =calcSpec=
    function and then written to a file of the user's choice.  The
    file writing routine should probably be replaced by a numpy
    savetxt function.

#+name: spectrumdialog_onsave
#+begin_src python
    def onSave(self,event):
        """Save a graph of the spectrum to a file."""
        x,y,e = self.calcSpec()
        dialog=wx.FileDialog(self,"Name the spectm file",
                             wildcard="ASCII (dat)|*.dat",
                             style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
        if dialog.ShowModal()==wx.ID_OK:
            with open(dialog.GetPath(),"w") as stream:
                for i in range(len(x)):
                    stream.write("%f\t%f\t%f\n"%(x[i],y[i],e[i]))
        self.Show(False)
#+end_src


*** Spectrum Modes
    
    The =flipping= function presents the two spin states as a flipping
    ration.  It begins by getting the binned data from autobinset.
    Note that this means that, for auto-binned graphs, it is the
    individual spin states who error have been minimized, not the
    final flipping ratio.

    With the binned data, the flipping ratio and error are
    calculated.  Note that a small value is added to the denominator
    of the flipping ratio to prevent divide by zero errors.
#+end_src

#+name:    spectrumdialog_modefunctions
#+begin_src python
    def flipping(self):
        """Calculate the flipping ratio"""
        if self.down is not None:
            (x,u,d)=self.autobinset()
            y = u/(d+1e-6)
            uerr = np.sqrt(u*self.uscale)/self.uscale
            derr = np.sqrt(d*self.dscale)/self.dscale
            e = y*np.sqrt((uerr/u)**2+(derr/d)**2)
            #e = y * np.sqrt(1/(u + 1e-6)+1/(d + 1e-6))
            return (x,y,e)
#+end_src

    The =polar= function is similar to =flipping=, except that the
    polarization is calculated, instead of the flipping ratio.  In
    this case, no value is added to the denominator.

#+name:    spectrumdialog_modefunctions
#+begin_src python
    def polar(self):
        """Calculate the polarization"""
        if self.down is not None:
            print "Polar Spectrum"
            (x,u,d)=self.autobinset()
            #print((x,u,d))
            y = (u-d)/(u+d)
            uerr = np.sqrt(u/self.uscale)
            derr = np.sqrt(d/self.dscale)
            e = 2*np.sqrt(u**2*derr**2+d**2*uerr**2)/(u+d)**2
            #e = nerr/n*(1+abs(y))
            return (x,y,e)
#+end_src

    The =spinUp= returns just the rebinned intensity of the spin up
    state.  If there is only one spin state, then this is the mode
    which should be used.

#+name:    spectrumdialog_modefunctions
#+begin_src python
    def spinUp(self):
        """Calculate the spin up intensity"""
        (x,y)=self.autobin(self.up*self.uscale,self.uscale)
        return (x,y,np.sqrt(y*self.uscale)/self.uscale)
#+end_src

    Finally, the =spinDown= function returns the rebinned intensity of
    the spin down state.

#+name:    spectrumdialog_modefunctions
#+begin_src python
    def spinDown(self):
        """Calculate the spin down intensity"""
        if self.down is not None:
            (x,y)=self.autobin(self.down*self.dscale,self.dscale)
            return (x,y,np.sqrt(y*self.dscale)/self.dscale)



#+end_src


*** Binning

    There are currently two binning functions.  =autobin= handles the
    binning of a single spin state and autobinset handles the binning
    of two spin states.  Each function then uses conditionals to
    handle the exact form of binning the user requested.  Honestly,
    it's a terrible design and should be improved.

**** Autobin

     The function takes two parameters

     - up :: The raw neutron count to be rebinned
     - scale :: The monitor counts for normalization

     The function begins by checking if any binning has even been
     requested.  If not, then it returns the normalized counts along
     with a wavelength spectrum.
#+end_src

#+name: spectrumdialog_autobin
#+begin_src python
    def autobin(self,up,scale):
        """Rebins one data array based on the user's chosen error

        Keyword arguments:
        up -- the array to be rebinned
        scale -- the conversion factor used to normalize against monitor

        """
        if self.nobinrad.GetValue():
            return (np.arange(0.0,RESOLUTION)*20.0/RESOLUTION,up/scale)
#+end_src

    The next case tested for is auto-binning.  It iterates through the
    count array, adding the neutron events into =utot= and
    incrementing the =count= since the last data point.  Once the
    relative uncertainty on =utot= is less that the requested value,
    the monitor normalized value of utot and the average of the
    positions are added appended to the y and x axes, respectively.

#+name: spectrumdialog_autobin
#+begin_src python
    #
        elif self.autobinrad.GetValue():
            x=[]
            u=[]
            count=0
            utot=0
            #The maximum percentage error in the spin up or spin down state
            emax = float(self.minerr.GetValue())/100.0
            for i in range(len(self.up)):
                utot += up[i]
                uerr = 1.0/np.sqrt(utot)
                if uerr < emax:
                    u.append(utot/scale/(count+1))
                    x.append((i-0.5*count)*20.0/RESOLUTION)
                    count = 0
                    utot=0
                else:
                    count += 1
            return (np.array(x),np.array(u))
#+end_src

    Finally, if the user has selected fixed binning, then the numpy
    [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html][array_split]] function is used to split the neutron data into the
    desired number of bins.  These subs arrays are then summed and
    normalized to make the final, binned array.

#+name: spectrumdialog_autobin
#+begin_src python
    #
        elif self.setbinrad.GetValue():
            count = int(self.minerr.GetValue())
            x = np.arange(0.0,RESOLUTION)*20.0/RESOLUTION
            x = np.array([np.mean(y) for y in np.array_split(x,count)])
            u = np.array([np.sum(y)/scale for y in np.array_split(up,count)])
            return (x,u)


#+end_src


**** Autobinset

     =autobinset= is similar to =autobin=, except that it handles
     having two spin states.  For the raw and fixed binning, this
     doesn't have any effect, but it requires special handling for the
     automated binning, since both data sets need to hxave the same
     bins.


     Again, the function begins by simply returning the values if the
     raw binning has been request, since there is no actual
     calculations to perform.
#+end_src

#+name: spectrumdialog_autobinset
#+begin_src python
    def autobinset(self):
        """Rebins both up and down data based on the user's chosen error."""
        x=[]
        u=[]
        d=[]
        count=0 #number of channels combined since last binning
        utot=0 #counts in the up state
        dtot=0 #counts in the down state
        #If there's no chosen error bounds, just return the original data.
        if self.nobinrad.GetValue():
            return (np.arange(0.0,RESOLUTION)*20.0/RESOLUTION
                    ,self.up,self.down)
#+end_src

    If actual calculations are to be involved, then the raw =up= and
    =down= spin state counts are needed to find the uncertainties.

#+name: spectrumdialog_autobinset
#+begin_src python
    #
        #If we're going any sort of binning, we'll need raw values
        up=self.up*self.uscale
        down=self.down*self.dscale
#+end_src

    The handling of the automatic binning is similar to how it was in
    =autobin=.  The only difference is that the uncertainties of both
    the up and down states must be beneath the request relative value
    before the bin gets added to the main list.

#+name: spectrumdialog_autobinset
#+begin_src python
    #
        #Check for autobinning
        if self.autobinrad.GetValue():
            #The maximum percentage error in the spin up or spin down state
            emax = float(self.minerr.GetValue())/100.0
            for i in range(len(self.up)):
                utot += up[i]
                dtot += down[i]
                uerr = 1.0/np.sqrt(utot)#error in the up state
                derr = 1.0/np.sqrt(dtot)#error in the down state
                #if the error is below the threshold, add the new data point
                if uerr <= emax and derr <= emax:
                    u.append(utot/self.uscale)
                    d.append(dtot/self.dscale)
                #choose x as the center of the binned data
                    x.append((i-0.5*count)*20.0/RESOLUTION)
                    i = 0
                    utot=0
                    dtot=0
                    count=0
                else:
                    count += 1
            return (np.array(x),
                    np.array(u),
                    np.array(d))
#+end_src

    The handling of raw values is exactly identical to how it was
    performed in =autobin=.

#+name: spectrumdialog_autobinset
#+begin_src python
    #
        elif self.setbinrad.GetValue():
            count = int(self.minerr.GetValue())
            x = [np.mean(y) for y in 
                 np.array_split(np.arange(0.0,RESOLUTION)*20.0/RESOLUTION,count)]
            u = [np.sum(y)/self.uscale for y in np.array_split(up,count)]
            d = [np.sum(y)/self.dscale for y in np.array_split(down,count)]
            #print((x,u,d))
            return (np.array(x),
                    np.array(u),
                    np.array(d))
#+end_src

    Finally, there is an exception in case some future programmer has
    added a radio button to the Spectrum Dialog without implementing
    the binning option here.  It's not likely that this code will ever
    be called, but it should exist for completeness.

#+name: spectrumdialog_autobinset
#+begin_src python
    #
        else:
            raise RuntimeException("Need to Implement bullet choice!")
#+end_src


** Livewatch

   =Livewatch.py= is a utility to display the polarization as it comes
   in.  It takes two parameters at the command line.  The first is the
   run number for the run.  The second is the current in triangle 1
   for the runs which we wish to analyze.

*** Livewatch skeleton

#+begin_src python :tangle livewatch.py :noweb tangle :padline no
import numpy as np
from matplotlib import pyplot as plt
import matplotlib as mpl
import time
from reader import PelFile
from monfile import MonFile
import sys
import os.path
import xml.etree.ElementTree as ET
import HTMLParser
import json

RUN = 32725
basedir = "C:/userfiles/EXP011/"
XMLNS = "{http://neutrons.ornl.gov/SNS/DAS/runinfo_v4_3}"
REBIN = 4

plt.ion()

<<livewatch_spectrum>>
mpl.rcParams['interactive'] = True

<<livewatch_manifestly>>
def spectra(gen):
    while True:
        next = gen.next()
        if next is None:
            yield None
            continue
        i,_=next
        s = spectrum(i)
        if s is None:
            yield None
        else:
            data,counts,manifest = s
            yield data,counts,manifest
            print i
            print(manifest)
            i += 1

def filter(gen,f):
    next = gen.next()
    while True:
        if next is None:
            yield None
        else:
            if f(next):
                yield next
        next = gen.next()

def integrator(gen):
    data = np.zeros(400/REBIN)
    counts = 0
    while True:
        next = gen.next()
        if next is not None:
            data += rebin(next[0],REBIN)
            counts += next[1]
        yield data/counts,np.sqrt(data)/counts
        

def joiner(gens):
    while True:
        streams = [g.next() for g in gens]
        yield streams

def plotter(source,count=1):
    xs = np.arange(0,20,0.05*REBIN) 
    plt.figure("Live Update")
    plt.ylim([-1,1])
    graphs = [plt.errorbar(xs,np.zeros(400/REBIN),np.zeros(400/REBIN),marker="o") for i in range(count)]
    while True:
        data=source.next()
        for g,d in zip(graphs,data):
            if d is not None:
                g[0].set_ydata(d)
        plt.draw()
        plt.pause(5)

def polarization(up,down):
    up = integrator(up)
    down = integrator(down)
    while True:
        u = up.next()[0]
        d = down.next()[0]
        yield -1*(u-d)/(u+d)
        #yield d/u

def fullpol(i,f):
    upstate = lambda x: x[1]['Flipper'] < 0
    downstate = lambda x: x[1]['Flipper'] > 0

    ups = spectra(filter(filter(manifestly(i),upstate),f))
    downs = spectra(filter(filter(manifestly(i),downstate),f))
    return polarization(ups,downs)

<<livewatch_rebin>>

if __name__=="__main__":

    lowcur = lambda x: x[1]['Triangle1'] ==3
    midcur = lambda x: x[1]['Triangle1'] ==9
    hicur = lambda x: x[1]['Triangle1'] ==15

    start = int(sys.argv[1])

    filters = [lambda x: x[1]['Triangle1'] == float(i) for i in sys.argv[2:]]

    polarizers = [fullpol(start,f) for f in filters]

    p = plotter(joiner(polarizers),count=len(polarizers))
    plotter(p)

#+end_src


*** Low Level Functions

The livewatch_spectrum function loads in the intensity spectrum and
uncertainty of a single run from its run number.  This code was copied
almost verbatim from [[Reduction]].  The only major change is that a
dictionary containing the current values is also returned, allowing
for other functions to sort the data.

#+name: livewatch_spectrum
#+begin_src python
def spectrum(run,mins=(0,0),maxs=(16,128),mask=None):
    eventfile = basedir+"SESAME_%i/SESAME_%i" % (run,run) + "_neutron_event.dat"
    if not os.path.isfile(eventfile):
        return None
    p = PelFile(eventfile)
    mon = MonFile(basedir+"SESAME_%i/SESAME_%i" % (run,run) +"_bmon_histo.dat",False)
    up = p.make1d(mins,maxs,mask)

    manifestFile = basedir+"SESAME_%i/SESAME_%i" % (run,run) + "_runinfo.xml"

    text = ET.parse(manifestFile).getroot().find(".//"+XMLNS+"Notes").text
    text = HTMLParser.HTMLParser().unescape(text)
    manifest = json.loads(text)

    return up,np.sum(mon.spec),manifest


#+end_src

Livewatch has a function for rebinning numpy arrays.  It takes the
original arrays and a number giving how many of the original array
elements should be combined together in the new array.

#+name: livewatch_rebin
#+begin_src python
def rebin(x,bins):
    result=np.zeros(len(x)/bins,dtype=np.float64)
    for b in range(bins):
        result += x[b::bins]
    return result
#+end_src



*** Generators

The main structure of livewatch is based around python
generators. Generators tend to come in three kinds

- Sources :: A generator which produces a continuously updating list
             of data.
- Pipes :: A generator which reads from another generator, performs
           some transformations on the results, and yields that
           result.

There's another related kind of function that isn't a generator.
- Sinks :: A function that reads through a generator and performs
           actions based on the results, but doesn't perform pass data
           to any higher level generators.

**** Sources

Manifestly starts with a single run number.  It then continuously
scans that directory, waiting for a monitor file to be written.  If
the monitor file exists, we know that the data acquisition system has
finished then run and we can continue.  If there is no new run, we
signal that information up the chain with a =None=.

Once the monitor file has been written, we read the runinfo file to
get the current data from the =Notes= heading.  This is turned into a
dictionary via json parsing.  The run number and manifest can then be
passed up the chain.  Finally, we increment the run number and return
to waiting for the new run to finish.

I also apologize for the stupid name.

#+name: livewatch_manifestly
#+begin_src python
def manifestly(start):
    i = start
    while True:
        manifestFile = basedir+"SESAME_%i/SESAME_%i" % (i,i) + "_runinfo.xml"
        monitorFile = basedir+"SESAME_%i/SESAME_%i" % (i,i) + "_bmon_histo.dat"
        if not os.path.isfile(monitorFile):
            #If the monitor file hasn't been written, the run isn't
            #done yet and we shouldnt' read it
            yield None
        else:
            try:
                manifestFile = basedir+"SESAME_%i/SESAME_%i" % (i,i) + "_runinfo.xml"

                text = ET.parse(manifestFile).getroot().find(".//"+XMLNS+"Notes").text
                text = HTMLParser.HTMLParser().unescape(text)
                manifest = json.loads(text)
                yield i,manifest
                i += 1
            except ValueError:
                yield None



#+end_src


* Utility Classes

  This section is for libraries which are used by more than one part
  of the system.  These are usually the modules which read and write
  data files, as they are needed by both the GUI and command line applications.
** Reader

   The =reader= module handles reading and interpreting neutron event
   files.  It's main purpose is to take a data file, which is a binary
   record of events, and turn it into a histogram of events in space
   and time.

*** Reader Skeleton

#+begin_src python :tangle reader.py :noweb tangle :padline no
"""This module contains classes for reading PEL files

This module contains a single class: PelFile.  This class reads the header
information and neutron data saved in PEL files.  more information about
the format of these files can be found in the Lexitech PAPA Software Manual.

"""

import __future__

import struct
#import re
import numpy as np

from time import clock
from collections import namedtuple

RESOLUTION = 400

<<reader_mapim>>

class PelFile:
        """Handles the data stored in PEL files"""
        data = np.ndarray(shape=(0),dtype=np.int64)#Raw detector data

        <<reader_pelfile_init>>                

        <<reader_pelfile_parseHeader>>
        <<reader_pelfile_convertTime>>
        <<reader_pelfile_make3d>>
        <<reader_pelfile_spectrum>>
                

        <<reader_pelfile_statusfunc>>
        <<reader_pelfile_getgains>>


        <<reader_pelfile_readfileimage>>

        <<reader_pelfile_make1d>>
#+end_src
    
    There's some old test code for running the reader by itself.  This
    code is old, out of date, and should be  removed.
    
#+begin_src python :tangle reader.py :noweb tangle :padline no                

if __name__=="__main__":
        data = PelFile()
        
        data.readfileimage("C:/Documents and Settings/adlwashi/Desktop/20091102101415-AM12.pel")
        print("Read File")
        data.spectrum("spectrum.txt")
        #print("Reverse Grey")
        #data.reverseGrey()
        #temp = set([data.fullGrayCode(i) for i in range(512)])
        #for i in temp:
        #        print "%03o" % i
        #print(len(temp))

#+end_src


*** Image Mapping

    The TOF for each event is given as a count since the T_0 pulse,
    where the each count is 100ns.  The convertTime function takes a
    numpy array of counts and turns it into a wavelength into a
    wavelength bin, where the bins are spaced by =20/RESOLUTION=.  For
    instance, if RESOLUTION is 200 and the neutron has a 2 Angstrom
    wavelength, then the bin is 20.

    The relationship between TOF and wavelength is controlled almost
    completely by the variables =distanceToG4= and
    =distanceToDetector=.  This sum should be the distance, in meters,
    from the neutron moderator to the Helium-3 detector.  The
    =distanceToG4= variable is based on Jak doskow's drawings on how
    far it should be from the neutron moderator to the exit of G4.
    The actual distance to the detector can then be measured with a
    tape measure.

    According to Dave Baxter's measurements, there is an 860us delay
    between the T0 signal and when the neutrons first start coming out
    of the moderator.  This value is subtracted off of the times to
    compensate.  This value should be checked occasionally to make
    sure that it has not changed.  If you are seeing neutrons with
    negative wavelengths, or if the proton pulse is not occuring at
    zero angstroms, then this value needs to be changed.  The best way
    of checking it is via the neutron monitor, as the proton flash is
    quite visible in the output and the results are given in 50
    microsecond bins.

<<convertTime>>
#+name:reader_pelfile_convertTime
#+begin_src python
        #Remember to use in-place operations to save on memory overhead
        def convertTime(self,timearr):
                """Convert an array of TOF data into neutron wavelengths."""
                #convert timearr into microseconds
                timearr *= 0.1 #Convert to microseconds
                #convert timearr into wavelength
                distanceToG4 = 3.7338+2.5297
                distanceToDetector = 3.835 #FIXME
                timearr -= 860
                timearr *= 3.956034e-7/(distanceToDetector+distanceToG4)/1e-10*1e-6*(RESOLUTION/20) #The last term is to handle fractional angstroms
                return timearr
#+end_src


     The SNS software for the Helium-3 detector returns a set of
     events.  Each even has a channel number, the distance along the
     channel, and a time of flight.  However, each channel on our
     detector has two tubes in series.  Thus, we need to convert the
     position on the channel to the position on the tube and assign
     the data to the right tube.

     Paul wrote this code and it has some idiosyncratic behavior.  For
     example, the test of 
: 0.5*ti!=int(0.5*ti)
     is really just a test to see if ti is odd or even.  It should
     probably be replaced with a simple
: ti%2==1
     which returns the same result for all values.  In fact, I have a
     sneaking suspicion that the entire thing can be done through
     numpy, eliminating the need for slow python loops, but I haven't
     proved it yet.

     The function takes a single input value, which is a 2D array of
     neutron counts with dimensions =XDIM= x =YDIM=.  It returns an array
     with dimensions =XDIMM= and =YDIMM=.  The =ZPAD= variable is used
     to account for dead pixels at the top or bottom of the tubes.
     The =maparray= variable gives the order of the tubes on the
     detector.  This has been found by calibration, but it should be
     checked periodically (e.g. biennially) to ensure that it's still accurate.

<<mapim>>
#+name:reader_mapim
#+begin_src python
def mapim(imarray):
    XDIM=8
    YDIM=256
    XDIMIM=16
    YDIMIM=128
    ZPAD=0
#    maparray=[2, 15, 1, 16, 4, 13, 3, 14, 6, 11, 5, 12, 8, 9, 7, 10]
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]#Old July 2013
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 14, 10, 13, 12, 9, 11, 16, 15]# SESANS October 2013
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 14, 10, 13, 12, 9, 11, 16, 15]# SESANS July 2013
    maparray =[4, 3, 1, 2, 6, 5, 15, 16, 8, 13, 7, 14, 10, 11, 9, 12] # From tube mapping October 2013
    #    maparray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
#    maparray = [12, 9, 11, 14, 10, 7, 1, 2, 3, 4, 5, 6, 8, 13, 15, 16]
#    maparray =[2, 1, 4, 3, 6, 15, 5, 16, 8, 7, 13, 14, 11, 12, 9, 10]
#    maparray =[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    newimarray=np.zeros((YDIMIM+ZPAD,XDIMIM))
    for i in range(len(maparray)):
        ti=maparray[i]
        if 0.5*ti!=int(0.5*ti):
           for j in range(YDIMIM):
                tj=j
                if ti<9:
                    newimarray[j+ZPAD,i]=imarray[YDIMIM-1-tj,(ti-1)/2]
                else:
                    newimarray[j,i]=imarray[YDIMIM-1-tj,(ti-1)/2]
        else:
            for j in range(YDIMIM):
                tj=j+YDIMIM
                if ti<9:
                    newimarray[j+ZPAD,i]=imarray[tj,ti/2-1]
                else:
                    newimarray[j,i]=imarray[tj,ti/2-1]
    return newimarray
#+end_src


     The make3D function is the primary function for turning an array
     of neutron events into a histogram of events versus position and
     wavelength.

     The data type is 64 bits per event.  The first 32 bits are the
     TOF information, which can be turned into a wavelength by the
     [[convertTime]] function.  The next 32 bits are the position
     information.

     We begin by setting some default variables.  The =statusfunc= is
     a function that can be called with the current progress on
     loading the file.  It expects a value between 0 and 1000, where 0
     is having just started and 1000 means that the process is
     complete.  The =cube= variable is the actual 3D array of neutron
     events.  If there is no data in the file, we can immediately
     return an empty array.
     
#+name:reader_pelfile_make3d
#+begin_src python
  def make3d(self):
          """Make a 3D histogram from the raw data."""
          start=clock()                
          statusfunc = self.statusfunc
          l = len(self.data)
          sd =self.data
          i=0;
  
          cube = np.zeros([128,16,RESOLUTION],dtype=np.float32)
  
          #If there's no data, return an empty array
          if l==0:
                  return cube
#+end_src

     The 64-bit events are broken down into the 32-bit array of
     position information, =Z=, and the 32-bit array of the time
     information, =timearr=.  The time information is then converted
     into a wavelength bin.

#+name:reader_pelfile_make3d
#+begin_src python
  #
          Z = self.data[1::2] & 0xFFFF#position data
  
          timearr = self.convertTime(np.asarray(self.data[0::2], \
                                                dtype=np.float64))#time data
          timearr = np.asarray(np.floor(timearr),np.uint16)
#+end_src

     a lot of this code used to purely work with integers.  As such,
     numpy was set to [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html][raise an exception on integer overflow]].  This is
     largely unnecessary now and could probably be removed.

#+name:reader_pelfile_make3d
#+begin_src python          
  #
          #Loop over 20 angstroms in steps of 0.1 angstroms
          np.seterr(over='raise')
  #+end_src

     It's possible to run the entire histogram calculation in a single
     numpy call, which would actually be faster than the code below.
     The problem is that the entire application would hang while the
     calculation was performed, which leaves you wondering if
     everything just crashed.  This slower version was implemented,
     since it was easier to put in feedback as to how much time would
     be left.

     The function cycles through each time of flight bin.  The =place=
     variable stores the indexes of events which fall into this time
     of flight bin.  If there are any such events, then their position
     information is histogrammed into a 1D array.  This array can then
     be converted into a 2D array, since we know the number of
     channels and the number of points per channel.  Finally, the
     [[mapim]] function takes the point and channel numbers and returns a
     2D array of position information.  Finally, this array is copied
     into the appropriate wavelength bin in the =cube= array.

#+name:reader_pelfile_make3d
#+begin_src python
  #
          for i in range(RESOLUTION):
                  place = np.where(timearr==i)
                  if len(place[0]) > 0:
                          temp,_ = np.histogram(Z[place],bins = \
                                                np.arange(8*256+1))
                          temp = temp.reshape(256,8,order="F")
                          cube[:,:,i] = mapim(temp)[::-1,:]
                  statusfunc(i*1000.0/RESOLUTION)
                          
  
          stop=clock()
          del timearr
  
          return cube
  
#+end_src

     The =spectrum= member of the =PelFile= class allows the
     wavelength spectrum of the entire file to be export to a text
     file.  This code is old, unused, unmaintened, and poorly
     written.  It should be deleted soon.

#+name:reader_pelfile_spectrum
#+begin_src python
        def spectrum(self,output):
                """Save the neutron spectrum to a text file"""
                with open(output,'w') as of:
                        timearr = (self.data >> 32) & 0x7FFFFFFF
                        timearr = self.convertTime(timearr)
                        timearr /= 10

                        #Get the spectrum and wavelengths
                        (spec,lmbda) = np.histogram(timearr,bins = \
                                                    np.arange(2.0,50.0,0.1))
                        hist = np.column_stack((lmbda[1:],spec))
                        for point in hist:
                                of.write("%f %i\n" % (point[0],point[1]))
                        of.close()
                        return (spec,lmbda)
#+end_src

     Many of the command line applications want to have the wavelength
     spectrum without worrying about the position information.
     =make1d= is the obvious analog of =make3d=.  It takes as
     parameters two tuples of the minimum x and y values as well as
     the maximum x and y values.  It will also take an optional 2D
     array of booleans to indicate which pixels should be ignored.
     The function then returns an array of the total neutron counts
     per wavelength bin over the requested area of the detector.

     Note that this code creates the full 3D histogram, then flattens
     it down to a 1D array.  It'd be far more efficient to just create
     the single array.  If you're looking to speed up make3d, it might
     be a good idea to start with make1D and continue from there.

#+name:reader_pelfile_make1d
#+begin_src python
        def make1d(self,mins,maxs,mask=None):
                """Make a 1D histogram from the spectrum data."""

                c = self.make3d()
                if mask is None:
                    xmin,ymin = mins
                    xmax,ymax = maxs
                    c = c[ymin:ymax,xmin:xmax]
                else:
                    c[np.logical_not(mask)] = 0
                return np.sum(np.sum(c,axis=0,dtype=np.float64()),axis=0)
#+end_src



*** Initialization

    The constructor for the PelFile doesn't need to do much other than
    load a file passed as a parameter.  If there is no file, we don't
    want to do anything.
    
#+name: reader_pelfile_init
#+begin_src python

        def __init__(self,file=""):
                """Create a PelFile"""
                if(file!=""):
                        self.readfileimage(file)

#+end_src

    The PelFile comes with a defautl status function that doesn't do
    anything.  This allows for PelFile to be manipulated without
    needing to hook them into a framework to process the update
    callbacks.

#+name: reader_pelfile_statusfunc
#+begin_src python
        def statusfunc(self,x):
                """Status update function

                This function is called to tell other program components
                the progress in loading the PelFile.  The progress is given
                on a scale of 0 to 1000.  This function should be overwritten
                by whatever function is loading the pel file to do what it
                needs with the load time information.

                """
                return
#+end_src
    

*** File Reading

    The original PEL file format used by the PAPA detector included a
    256 byte header with metadate about the detector status during the
    run.  This function would parse that information into a Python
    [[https://docs.python.org/2/library/collections.html][namedTuple]], which is fairly similar to a standard struct.  With
    the new Helium-3 detector, this code is no longer necessary or
    useful.  It should not be called and could probably be deleted.

#+name:reader_pelfile_parseHeader
#+begin_src python
  
  def parseHeader(self,bytes):
          """Turn the Pel file header into structured data"""
          Header = namedtuple(
                  'Header',
                  "pel endian FileMajVer FileMinVer BytesPerSample " +
                  "SysHealth AppMajVer AppMinVer AppBetaVer LensPos " +
                  "DetectorName ProductNumber BitsPerCoord CanEnergy " +
                  "CanTime ADclockFrequ FirmMajVer FirmMinVer FirmBeta Serial " +
                  "AcquisitionMode CanAcqMode Shutter " +
                  "PAPAPowerSupplyVoltageCommand " +
                  "PAPAPowerSupplyVoltageCommandGain " +
                  "PAPAPowerSupplyVoltageCommandOffset " +
                  "PAPAPowerSupplyControlVoltageCommandGain " +
                  "PAPAPowerSupplyControlVoltageCommandOffset " +
                  "PAPAPowerSupplyVoltageEnable " +
                  "EnergyPowerSupplyVoltageCommand " +
                  "EnergyPowerSupplyVoltageCommandGain " +
                  "EnergyPowerSupplyVoltageCommandOffset " +
                  "EnergyPowerSupplyControlVoltageCommandGain " +
                  "EnergyPowerSupplyControlVoltageCommandOffset " +
                  "EnergyPowerSupplyVoltageEnable " +
                  "MCPPowerSupplyVoltageCommand " +
                  "MCPPowerSupplyVoltageCommandGain " +
                  "MCPPowerSupplyVoltageCommandOffset " +
                  "MCPPowerSupplyControlVoltageCommandGain " +
                  "MCPPowerSupplyControlVoltageCommandOffset " +
                  "MCPPowerSupplyVoltageEnable " +
                  "x1Gain x2Gain x3Gain x4Gain x5Gain x6Gain x7Gain x8Gain x9Gain x10Gain " +
                  "y1Gain y2Gain y3Gain y4Gain y5Gain y6Gain y7Gain y8Gain y9Gain y10Gain " +
                  "strobeGain EnergyGain ThresholdGain "+
                  "ADVoltageOffset ADAOffset ADBOffset ADCOffset ADDOffset "+
                  "StrobeTriggerMin StrobeTriggerMax StrobeEndEventFrac " +
                  "EnergyTriggerMin EnergyTriggerMax EnergyEndEventFrac " +
                  "ADAFillSampleIntervalLength ADDFillSampleIntervalLength " +
                  "GateCapturePolarity TimerResetEdgePolarity " +
                  "LeadTimer LagTimer Gray BitShift " +
                  "TemperatureSetPoint1 TemperatureSetPoint2 " +
                  "KP1 KP2 KI1 KI2 KD1 KD2 Temperature1 Temperature2 " +
                  "StrobePulseWidth " +
                  "Year Month Day Hour Minute Second")
  
  
          format = "4s" #header
          format += " ?" #endian  Note that this is currently ignored
          (pelstring,endian) = struct.unpack(format,bytes[0:5])
  
          if endian:
                  format = ">" #big endian
          else:
                  format = "<" #little endian
          format += "4s ?" #header and endian
          format += "B" #Major version
          format += "B" #Minor Version
          format += "B" #Bytes per sample
          format += "B" #System Health
          format += "B" #Application Software Major Version
          format += "B" #Application Software Minor Version
          format += "B" #Application Software Beta Version
          format += "H" #Lens focus position
          format += " 40s " # Detector Name
          format += "H" # Product Number
          format += "B" # Bits per coordinate
          format += "B" #Detector Energy Capability
          format += "B" #Detector Timing Capability
          format += "H" #AD Clock Frequency
          format += "B" #Firmware Major Version
          format += "B" #Firmware Minor Version
          format += "B" #Firmware Beta Version
          format += "H" #Serial Number
          format += "B" #Acquisition Mode
          format += "I" #Acquisition Mode Capability
          format += "B" #Shutter State
          format += "H" #PAPA PMT power supply voltage command
          format += "H" #PAPA PMT power supply voltage gain
          format += "H" #PAPA PMT power supply voltage command offset
          format += "H" #PAPA PMT power supply control voltage command gain
          format += "H" #PAPA PMT power supply control voltage command offsert
          format += "B" #PAPA PMT power supply voltage enable
  
          format += "H" #Energy PMT power supply voltage command
          format += "H" #Energy PMT power supply voltage gain
          format += "H" #Energy PMT power supply voltage command offset
          format += "H" #Energy PMT power supply control voltage command gain
          format += "H" #Energy PMT power supply control voltage command offsert
          format += "B" #Energy PMT power supply voltage enable
          format += "H" #Intensifier MCP power supply voltage command
          format += "H" #Intensifier MCP power supply voltage gain
          format += "H" #Intensifier MCP power supply voltage command offset
          format += "H" #Intensifier MCP power supply control voltage command gain
          format += "H" #Intensifier MCP power supply control voltage command offsert
          format += "B" #Intensifier MCP power supply voltage enable
          format += " 10H " #X Channel gains
          format += " 10H " #Y Channel gains
          format += "H" #Strobe PMT Channel Gain
          format += "H" #Energy PMT Channel Gain
          format += "H" #Threshold Channel Gain
          format += "H" #AD Voltage Offset
          format += "H" #AD Channel A Offset
          format += "H" #AD Channel B Offset
          format += "H" #AD Channel C Offset
          format += "H" #AD Channel D Offset
          format += "H" #PAPA Strobe Trigger min
          format += "H" #PAPA Strobe Trigger max
          format += "H" #PAPA Strobe end event fraction
          format += "H" #Energy Trigger min
          format += "H" #Energy Trigger max
          format += "H" #Energy end event fraction
          format += "B" #AD A filter sample interval length
          format += "B" #AD D filter sample interval length
          format += "B" #Gate Capture Polarity
          format += "B" #Timer reset edge Polarity
          format += "H" #Coincidence lead timer
          format += "H" #Coincidence lag timer
          format += "B" #Gray to binary conversion adder
          format += "B" #Binary big shift
          format += " 2H " #Zone temperature set point
          format += " 2H " #Zone KP Gain
          format += " 2H " #Zone KI Gain
          format += " 2H " #Zone KD Gain
          format += " 2H " #Zone temperature
          format += "H" #strobe pulse width
          format += "39x" #unused
          format += "H" #Year
          format += "H" #Month
          format += "H" #Day
          format += "H" #Hour
          format += "H" #Minute
          format += "H" #Second
          header = Header._make(struct.unpack(format,bytes))
          return header
  
#+end_src

    The =getgains= function returns the signal amplification on the
    photomultiplier tubes used to position detection on the PAPA
    detector.  This is useful for trying to set the gains on the PMTs
    automatically. If the data is coming from the Helium-3 detector, then
    this function is worthless.

#+name:reader_pelfile_getgains
#+begin_src python
        def getgains(self,h):
                """Pulls the PMT gains information into a numpy array"""
                return np.array([h.x1Gain,h.x2Gain,h.x3Gain,h.x4Gain,h.x5Gain,h.x6Gain,h.x7Gain,h.x8Gain,h.x9Gain,h.x10Gain,
                        h.y1Gain,h.y2Gain,h.y3Gain,h.y4Gain,h.y5Gain,h.y6Gain,h.y7Gain,h.y8Gain,h.y9Gain,h.y10Gain],np.double)
#+end_src

    The =readfileimage= member loads the raw events from the data file
    straight into memory.

#+name:reader_pelfile_readfileimage
#+begin_src python
        def readfileimage(self,path):
                """Reads a raw Pel File into memory."""
                start=clock()
                statusfunc = self.statusfunc
                with open(path,"rb") as infile:
                    #self.header = self.parseHeader(infile.read(256))
                    #Raw File has no header
                    #point = infile.read(8)
                    self.data = np.fromfile(infile,np.int32,-1)
                infile.close()
                stop=clock()
#+end_src

** MonFile

   The =MonFile= class is used to read the files produced by the SNS
   beam monitor software.

*** MonFile Skeleton

    The monfile package mostly consists of the MonFile class.  There
    are, however, a couple of notes which are non-intuitive.  First,
    monfile imports graphframe, so it's not suited for use on a
    headless system.  In practice, that's not a big deal, but you
    should be aware of it.  Also, monfile is one of the oldest parts
    of PELVis and has quite a bit of cruft.  For instance, it imports
    pylab, but it never uses it.  (That's probably a good thing, as you
    shouldn't use pylab.)  I'll try to comment on the cruft as I pass
    through, but you should pay attention.

#+begin_src python :tangle monfile.py :noweb tangle :padline no
"""Classes for dealing with neutron monitor data

This module contains a single class: MonFile.  This class is used to read
the time, intensity, and spectrum information out of a file produced
by the SNS's BMM_server

"""

import numpy as np
import re
import scipy.interpolate as ip
import scipy.optimize as op
import matplotlib.pyplot as pyplot
from graphframe import GraphFrame
import pylab as pl
import math

class MonFile:
    """Manages a file which holds neutron monitor data."""
    KbT = 2.0e-3
    
    <<monfile_init>>

    <<monfile_converttime>>

    def func(self, x, A, b, k, c):
        return A*x**2 * np.exp(-(x-k)**2*b) + c

    <<monfile_load>>
#+end_src

*** Initialization

    The constructor has two, optional parameters.  The first is a file
    name, which can cause that file to be loaded into memory.  The
    second is a boolean which declares whether we want a graph of the
    monitor spectrum to be displayed on the screen.

    The constructor declares two members.  The first is =time=, which
    is no longer used.  Under the old PAPA data collection system, the
    monitor files were stored in ASCII format and included the run
    time in microseconds.  This information could then be used for certain kinds
    of background subtraction and normalization.  However, the monitor
    files produces by the SNS software are binary arrays of floating
    points and do not have the time information, so it is no longer
    included.

    The other member, =spec=, stores an array of the monitor counts
    per TOF bin.  This array is the primary purpose of the class.

#+name:monfile_init
#+begin_src python
    def __init__(self,file=None,plot=True):
        """Creates a MonFile object"""
        self.time = None #The amount of time that the monitor ran.
        self.spec = None #The neutron spectrum detected on the monitor.
        if file is not None:
            self.load(file,plot)
#+end_src


*** File Loading

    The SNS software saves an array of 50,000 32 bit integers
    representing the counts in each time of flight bin.  Each bin
    represents 1us, so the 50,000 bins give 50ms, which corresponds to
    our 20Hz pulse rate.

    The main parts of the code are at the beginning of the class.
    numpy loads the neutron spectrum from the SNS data file with the
    =fromfile= function.  With the exception of the last line, every
    other part of the function is dedicated to displaying the graph
    and has no result on the actual data analysis.

    The =x= variable is used to store the wavelenghts for the neutron
    counts in =y=.
#+name:monfile_load
#+begin_src python
    def load(self,file,plot=True):
        """Load data from the file given in the path string."""
        self.time = -1
        base = 0.1
        count = 0
        uplim = 31
        
        y = np.fromfile(file,np.int32,-1)
        x = np.arange(0,50001,1,dtype=np.float32)
        x = self.convertTime(x)
#+end_src

    The =xs= and =ys= arrays are made to rebin the data from x and y.
    The code cycles through each data point and adds the data from =y=
    into the corresponding bin in =ys=.  The =base= variable is used
    to keep track of the current position in ys.

    Note that this binning algorithm is incredibly slow and should
    probably be replaced.

#+name:monfile_load
#+begin_src python
    #
        #f = ip.interp1d(x,y)
        #p0 = [10., 0.0001, 10000., 2.]
        #p1, cov = op.curve_fit(self.func, x, y, p0)
        #print(p1)
        #p1f = self.func(x, *p1) #Fit of neutron monitor
        #xs = range(200)
        #xs = np.arange(0,35,0.1)
        #ys = np.zeros(350,dtype=np.uint32)

        xs = np.arange(0,uplim,base)
        ys = np.zeros(uplim/base,dtype=np.uint32)

        for (i,j) in zip(x,y):
            if i > base:
                ys[int(10*base-1)]=count
                base += 0.1
                count = 0
            count += j
        base = 0.1
        count = 0
        uplim = 31
#+end_src

    ymean is supposed to find the background level by looking at the
    count rate of the neutron between 25  and 30 , but it only seems
    to be used in =ynew=, which is never used again.  In practice, the
    noise on the neutron monitor is low enough that this really
    shouldn't be necessary.

#+name:monfile_load
#+begin_src python            
    #
        ymean = np.mean(ys[250:300])
        ynew = np.array([float(yo)-ymean*(uplim/base)/50001 for yo in y])
#+end_src

    The results are rebinned again for reasons that I honestly cannot
    fathom at this point.

#+name:monfile_load
#+begin_src python        
    #
        ysnew = np.zeros(uplim/base,dtype=np.float32)
        for (i,j) in zip(x,ynew):
            if i > base:
                ysnew[int(10*base-1)]=count
                base += 0.1
                count = 0
            count += j
#+end_src

    Finally, the results are plotted.

#+name:monfile_load
#+begin_src python
    #
        if plot:
            graph = GraphFrame(None,"Monitor")
            graph2 = GraphFrame(None,"Monitor Adjusted")
        #        graph.plot(np.arange(0.0,20.0,0.1),f(xs))
        #    graph.plot(xs,ys)
            graph2.plot(xs,ysnew)          
#+end_src

    The final, but most important step, is to store the monitor
    spectrum in the class.  The =expand_dims= function is used to turn
    a 1D array with fifty thousand elements into a 3d arry with
    dimensions (1,1,50000).  The reasoning is that the time
    information is now stored on the same array axis by both the
    monitor file and the detector reader.

#+name:monfile_load
#+begin_src python
    #
        self.spec = np.expand_dims(np.expand_dims(y,axis=0),axis=0)

#+end_src

    The convert time function takes an array of us and returns their
    corresponding wavelengths in Angstroms.  Most of this has already
    been covered in the [[convertTime][similar function]] for the neutron data

#+name:monfile_converttime
#+begin_src python
    def convertTime(self,t):
        """Converts a numpy array of time bins into neutron wavelengths"""
        distanceToG4 = 3.7338+2.5297
        #The distance between the end of G4 and the Helium 3 monitor.
        distanceToMonitor = 0.02 #FIXME
        t -= 860
        t *= 3.956034e-7/(distanceToMonitor+distanceToG4)/1e-10*1e-6
        return t
#+end_src



** Combiner

The =Combiner= module contains two helper functions.  These function
are used for parsing the metadata from individual runs and combining
them into a single run file.

*** Combiner Skeleton

The =XMLNS= global variable is the [[http://www.w3.org/TR/REC-xml-names/][XML Namespace]] that the SNS has
chosen to use in their configuration files.  The good news is that
Python's =xml.etree= module correctly handles namespaces.  The bad
news is that every attempt to pull a tag from an XML file requires
that the tag be prefaced with the namespace, which is a pain.

#+begin_src python :tangle Combiner.py :noweb tangle :padline no
import xml.etree.ElementTree as ET
import HTMLParser
import json
import numpy as np
import os.path
from time import strptime,mktime
from math import floor,sqrt

XMLNS = "{http://neutrons.ornl.gov/SNS/DAS/runinfo_v4_3}"

<<combiner-load>>
<<combiner-save>>
#+end_src



*** Load

The =load= function takes a list of paths to runinfo files and
returns a dictionary with the current configurations as a key and the
runs associated with the configuration as the value.  It also takes
an optional =filter= parameter, which is currently ignored and should
be removed.

#+name:combiner-load
#+begin_src python
def load(paths,filter=None):
    currents = set([])#List of the configurations of the instrument
    runsets = {}#Directionary of lists of run nodes, indexed by their instrument configuration

#+end_src

For each run_info file, we use element tree to find the =<Notes>=
tag.  This text is then extracted out.  The SNS software does HTML
encoding on the text in the notes tag, despite the fact that this is
XML and not HTML.  In any case, we use the HTMLParser module to
remove the text encoding.  Finally, our =save= function in
=Sesame_init.py= saves the power supply status as a [[http://www.json.org][JSON]] string,
which we then interpret.

#+name:combiner-load
#+begin_src python
#
    for path in paths:
        print(path)
        base = os.path.dirname(path)
        text = ET.parse(path).getroot().find(".//"+XMLNS+"Notes").text 
        text = HTMLParser.HTMLParser().unescape(text)
        manifest = json.loads(text)
#+end_src

The dictionary of the power supply currents is turned into a tuple.
The tuple is a value by itself and can be put into a Set, while the
dictionary is an object with a unique identity and doesn't mesh as
well with Sets and uniqueness checking.  A useful improvement would
be to turn this into a [[https://docs.python.org/2/library/collections.html][NamedTuple]], which would allow the constituents
to be called by name, instead of location.

#+name:combiner-load
#+begin_src python
        
##        if ((filter is not None) and 
##            (floor(float(manifest['triangle1'])) != filter)):
##            continue #wrong triangle current
        try:
            current = (manifest['Flipper'],
                       manifest['Guide'],
                       manifest['Phase'],
                       manifest['Sample'],
                       manifest['Triangle1'],
                       manifest['Triangle2'],
                       manifest['Triangle3'],
                       manifest['Triangle4'],
                       manifest['Triangle5'],
                       manifest['Triangle6'],
                       manifest['Triangle7'],
                       manifest['Triangle8'])
        except:
            print("Could not retrieve currents for run " + str(base[-5:]))
            continue
#+end_src

If this combination of power supply currents hasn't been seen before,
it's added to the dictionary.  Replacing runsets with a [[https://docs.python.org/2/library/collections.html][defaultDict]]
could save us some effort here.

Finally, the function returns the dictionary.

#+name:combiner-load
#+begin_src python
#
        if current in currents:
            runsets[current].append(path)
        else:
            currents.add(current)
            runsets[current]=[path]
    return runsets

#+end_src

*** Save

The =save= function is used to export a set of runs into a single
file.

- path :: The location where the file should be saved.  This includes
          both the directory and the prefix for the file name.  For
          instance, if =path= is "C:/PELVis/example", then the
          detector data would be saved in "example_neutron_event.dat"
          in the "C:/PELVis" directory.
- minmon :: The minimum number of monitor counts per second that we
            expect when the beam is on.  Runs with a count rate below
            this will be ignored, as the assumption is that there
            were no neutrons and the detector merely contains noise.
- keys :: Which current sets should be included in the export
- runsets :: The dictionary of data runs produced by =load=

We begin by using the key to extract from the dictionary the paths
for all of the runs were are interested in.
#+name:combiner-save
#+begin_src python
def save(path,minmon,keys,runsets):
    runs = [x for key in keys for x in runsets[key]]
#+end_src

The =mon= array holds out total monitor spectrum.

#+name:combiner-save
#+begin_src python
#
    mon = np.zeros((50001,),dtype=np.int32)
#+end_src

The =tottime= and =detcount= are just interesting statistics and
could be dropped.

#+name:combiner-save
#+begin_src python
#
    tottime = 0
    detcount=0
#+end_src

There's a weird bug in the SNS code.  I'm pretty sure that the bug is
in their code and is not something that I did.  When a runinfo file is
saved, it gives a malformatted timestamp for the =StartTime= and
=StopTime=.  The format strings below allow Python to parse these strings.

#+name:combiner-save
#+begin_src python
#
    format1 = "%Y-%m-%dT%H:%M:%S-04:00"
    format2 = "%Y-%m-%dT%H:%M:%S-04:00-04:00"
#+end_src

We open the final output file (outfile), and cycle through the
monitor files (monpath) and detecto files (detpath).

#+name:combiner-save
#+begin_src python
#
    with open(path+"_neutron_event.dat","wb") as outfile:
        for r in runs:
            monpath = r[:-11] + "bmon_histo.dat"
            detpath = r[:-11] + "neutron_event.dat"
#+end_src

We extract the starting and ending times and put the total number of
seconds spent during the measurement into the variable =time=.

#+name:combiner-save
#+begin_src python
#
            starttime = strptime(ET.parse(r).getroot().find(".//"+XMLNS+"StartTime").text.strip(),format1)
            stoptime = strptime(ET.parse(r).getroot().find(".//"+XMLNS+"StopTime").text.strip(),format2)

            time = mktime(stoptime)-mktime(starttime)

#+end_src

The monitor spectrum for the individual run is slurped into the
variable =montemp= with the total number of counts being stored in
=moncount=. 

#+name:combiner-save
#+begin_src python
#
            with open(monpath,"r") as infile:
                montemp = np.fromfile(infile,dtype=np.int32)

            moncount = 1.*np.sum(montemp)
            print "Run number: " + str(r[-17:-12])
            print "Time: " + str(time)


#+end_src

We check to see if we're within 20 counts per second of the expected
monitor count rate.  If not, then we stop processing this run.

#+name:combiner-save
#+begin_src python
#
            #Fixed for enabling dead run substraction 04/01/2013 done by Radian 
            if time <= 0 or ((moncount/time < minmon-20 or \
                              moncount/time>minmon+20) and minmon >0):
                print ":::: SKIPPING RUN: " + str(r[-17:-12]) + " ::::\n"
                print moncount/time
                print time
                continue

            print "Monitor counts: " + str(moncount)
            print "Monitor count rate: " + str(round(moncount/time,2))

            mon += montemp
            tottime += time

#+end_src

The contents of the detector file is loaded into dettemp.  There's
also some code to calculate the detector count rate.  That code could
probably be removed.

#+name:combiner-save
#+begin_src python
#
            with open(detpath,"rb") as infile:
                dettemp = np.fromfile(infile,count=-1)
                dc = 1.*len(dettemp)
                dcr = round(dc/moncount,2)
                dcrerr = sqrt(dc/(moncount**2) + (dc**2)/(moncount**3))
                print "Detector counts: " + str(dc)
                print "Detector count rate: " + str(round(dc/time,2))
                print "Detector counts/Monitor counts: " + str(dcr) + \
                      " +/- " + str(dcrerr) + "\n"
                if dcr <= 0:# or dcrerr/dcr > 0.02:
                    print "#### SKIPPING RUN: " + str(r[-17:-12]) + " ####\n"
                    mon -= montemp
                    continue

#+end_src

We increment the total detector count and add the events to our final
run file.  We also delete the current data from memory to save some space.

#+name:combiner-save
#+begin_src python
#
                detcount += len(dettemp)
                dettemp.tofile(outfile)
                del dettemp

#+end_src

Finally, we dump the total monitor spectrum to a file and display the
cumulative statistics for all of the runs.

#+name:combiner-save
#+begin_src python
#
    with open(path+"_bmon_histo.dat","wb") as stream:
        mon.tofile(stream)
    print "Total Monitor Counts = " + str(np.sum(mon))
    print "Total Detector Counts = " + str(detcount)
    print "Total Time = " + str(tottime)
    if tottime > 0:
        print "Monitor Count Rate = " + str(np.sum(mon)/tottime)
        print "Detector Count Rate = " + str(detcount/tottime)

#+end_src


* Reduction

** Reduction Skeleton

#+begin_src python :tangle Reduction.py :noweb tangle :padline no
from reader import PelFile
from monfile import MonFile
import matplotlib.pyplot as plt
import Combiner
import numpy as np
from optparse import OptionParser
import os

basedir = "C:/userfiles/EXP011/"
RESOLUTION = 400

<<reduction_load>>

<<reduction_export>>

<<reduction_plot_2d_range>>
<<reduction_get_2d_int>>

<<reduction_plot_int_range>>

<<reduction_plot_pol_range>>
    
    
<<reduction_getIntegratedSpectra>>
<<reduction_normalize_name>>


<<reduction_spectrum>>

<<reduction_errspectrum>>
<<reduction_simple_spectrum>>

<<reduction_fr>>

<<reduction_run_int>>


<<reduction_singleplot>>

<<reduction_echoplot>>
<<reduction_intensity>>
    

<<reduction_echofr>>

<<reduction_poldrift>>
<<reduction_echodiff>>

<<reduction_twoflipper>>           
    
<<reduction_main>>
#+end_src


** Main Command

   The program begins by creating an [[https://docs.python.org/2/library/optparse.html][OptionParser]] to handle the
   numerous command line options of the application.

#+name:reduction_main
#+begin_src python

if __name__=='__main__':

    parser = OptionParser()
#+end_src

   The =choices= dictionary gives a simple mapping between the human
   readable names of the power supplies and their numbering.  This
   will be used to interpret channel selection from the user at the
   command line.

#+name:reduction_main
#+begin_src python
#

    choices = {None:None,"flipper":0,"guides":1,"phase":2,"sample":3,"1":4,"2":5,"3":6,"4":7,"5":8,"6":9,"7":10,"8":11}
#+end_src

   The export command tells the reducer that the files need to be
   combined before they can be plotted.  If the command has been run
   once, then subsequent runs can plot the *same data* in different
   way.  However, if you want to change the run number or anything
   about the currents examined, the data needs to be exported again.

   The =twoflip= option is a duplication of functionality and should
   be removed.  It can be just as easily performed with a =sortby=
   option without adding in duplicated code.

#+name:reduction_main
#+begin_src python
#

    parser.add_option("-e","--export", type="choice", action="store", \
                      help="Export into pel files",
                      choices=["flip","twoflip"])
#+end_src

   The =sortby= command is used to get flipping measurements sorted by
   the current in another power supply.  For instance, if the unit was
   flipping one triangle 3 and performing a tuning scan on triangle 8,
   then =--sortby 8= would separate out all of the different tuning runs.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--sortby",action="store",type="choice", \
                       help = "Which power supply is scanned",
                       choices=choices.keys())
#+end_src

   The =filter= option is used to only examine a single state from the
   power supply indicated by =sortby=.  For instance, if you have
   found that the instrument was tuned at 4.5A after a tuning scan on
   triangle 7, then =--sortby 7 --filter 4.5= would only process runs
   where the instrument was tuned.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--filter",action="store",type="float", \
                       help="Focuses the export to only a single \
                       value in the sortby parameter")
#+end_src

   The =flip= option indicated which power supply acted as the
   flipper.  This is necessary for splitting the spin states.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--flip",action="store",type="choice", \
                       help="Which power supply runs the flipper",
                       choices=choices.keys())
#+end_src

   The =flip2= command is used to indicate which power supply served
   for the second flipper in a two flipper measurement.  Like the
   =twoflip= option on =export=, this is better server by using the
   =sortby=  command and should be removed.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--flip2",action="store",type="choice", \
                       help="Which power supply runs the second flipper \
                       in a two flipper run",
                       choices=choices.keys())
#+end_src

   The =mon= command sets a minimum monitor value for a run.  If the
   count rate per second on the monitor is less than this value, the
   beam is assumed to have gone down and the run is not included.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--mon",action="store",default=32,type="float", \
                       help="Minimum monitor value.  If the value \
                       is lessthan or equal to zero, all runs are \
                       included, regardless of monitor count.")
#+end_src

   The =(x,y)(min,max)= options give a pixel range on the detector,
   indicating the area where the relevant signal should be expected.

#+name:reduction_main
#+begin_src python
#

    parser.add_option("--xmin",action="store",type="int",help="Minimum x value",default=0)
    parser.add_option("--ymin",action="store",type="int",help="Minimum y value",default=0)
    parser.add_option("--xmax",action="store",type="int",help="Maximum x value",default=16)
    parser.add_option("--ymax",action="store",type="int",help="Maximum y value",default=128)
#+end_src

   When the =sortby= command is used, the =start=, =stop=, and =step=
   command give the bounds of the current that should be expected, as
   well as the step size between them.  Honestly, the program should
   be improved so that it can find these values automatically, but
   they need to be manually entered for now.

#+name:reduction_main
#+begin_src python
#

    parser.add_option("--start",action = "store",type="float", help="The starting current of the scan")
    parser.add_option("--stop",action = "store", type="float", help="The ending current of the scan")
    parser.add_option("--step",action = "store", type="float", help="The current step of the scan")
#+end_src

   The =skip= command can be used to exclude a bad run (e.g. power
   supply failure).  Calling it multiple times allows for skipping
   multiple runs.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--skip",action = "append", type="int", help="Marks that a run should NOT be included in the file export.")
#+end_src

   The =plot= option tells the program which kind of plot to make.

#+name:reduction_main
#+begin_src python
#

    parser.add_option("--plot",action="store",type="choice",
                      help="Where to make a simple plot or perform a height diff",
                      choices=["plot","diff","fr","echo","intensity","poldrift","int2drange","pol2drange"])
#+end_src

   The =save= option takes a file name and saves the data that would
   be plotted into that file.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--save",action="store",type="string",default=None,
                      help="A file in which to save the dataset.")
#+end_src

   The =mask= option takes the path of a binary bitmap mask, as
   [[OnExportROI][exported by PELVis]] and uses it to examine only the signal portion of
   the detector.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--mask",action="append",type="string",default=None,
                      help="A mask file indicating which pixel to use in the analysis")
#+end_src

   This function seems to duplicate the filter command.  It should be
   seen if both are really necessary.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--current",action="store",type="int",
                      default=None,
                      help="A triangle current to filter the results.")
#+end_src

   Again, this probably isn't necessary.

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--watch",action="store",type="choice", \
                      choices=choices.keys(), \
                      help="Which coil are we watching the current of (see --current)")
#+end_src

   If there are a large number of runs which need to be removed or if
   two measurements taken far apart in time are to be combined, then
   the =complex= option can take the name of a text file which has the
   list of the run numbers to be examined, with one run number per
   line.
#+end_src

#+name:reduction_main
#+begin_src python
#
    parser.add_option("--complex",action="store_true",
                     help="Whether to load the run data from runlist.txt")
#+end_src

   Now that we've parsed the command line arguments, we can start
   actually crunching some data.  The =runs= variable is a list of the
   run numbers, which can either be loaded from the command line or
   from a file.

#+name:reduction_main
#+begin_src python
#

    (options,runs) = parser.parse_args()

    if options.complex:
        runs = list(np.loadtxt("runlist.txt"))
    else:
        runs = range(int(runs[0]),int(runs[1])+1)
#+end_src

   We then remove any skipped runs from the list.

#+name:reduction_main
#+begin_src python
#
    if options.skip:
        for item in options.skip:
            runs.remove(item)
#+end_src

   We now combine and export the runs.  Against, the =twoflip= option
   is unnecessary.

#+name:reduction_main
#+begin_src python
#

    if options.export=="flip":
        export(runs, choices[options.sortby], choices[options.flip], \
               options.mon, options.current, options.filter, options.watch)
    if options.export=="twoflip":
        two_flipper(runs, choices[options.flip], choices[options.flip2], \
               options.mon, options.current, options.watch)
#+end_src

   If the user has added mask files, we now create a custom mask that
   passes through every one of the loaded files.

#+name:reduction_main
#+begin_src python
#

    if options.mask is not None:
        mask = np.ones((128,16),dtype=np.bool)
        for m in options.mask:
            if m[-3:] == "dat":
                mask = np.logical_and(mask,np.loadtxt(m))
            else:
                mask = np.logical_and(mask,np.load(m))
    else:
        mask = None
#+end_src

   Finally, if the user hasn't chosen to plot anything, then the task
   is complete.

#+name:reduction_main
#+begin_src python
#
    if options.plot is None:
        pass

#+end_src

   We now need to know the names of the exported files.  If there was
   no attempt to sort by a triangle current, then the names aren't
   necessary.  Otherwise, we step through the currents given by
   =start=, =stop=, and =step= and check to see if the file exists.
   If it does, it's added to the list of files.

#+name:reduction_main
#+begin_src python
#
    else:
        if options.sortby is None or options.filter is not None:
            names = [""]
        else:
            count = round((options.stop-options.start)/options.step)+1
            print(count)
            names = [str(x) 
                     for x in 
                     np.linspace(
                    options.start,
                    options.stop,
                    count)]
            print(names)
            names = [name for name in names
                     if os.path.exists(basedir+"SESAME_%i/" % runs[-1] + 
                                       normalize_name(name)+
                                       "up_neutron_event.dat") 
                     and os.path.exists(basedir+"SESAME_%i/" % runs[-1] + 
                                        normalize_name(name)+
                                        "down_neutron_event.dat")]
            print(names)
#+end_src

   Finally, we pass the users options to the associated plotting function.

#+name:reduction_main
#+begin_src python
#

        if options.plot=="plot":
            print runs
            print names
            singleplot(runs[-1],names[0],(options.xmin,options.ymin),(options.xmax,options.ymax))
        elif options.plot=="fr":
            echofr(runs[-1],names,(options.xmin,options.ymin),(options.xmax,options.ymax),outfile=options.save,mask=mask)
        elif options.plot=="diff":
            echodiff(runs[-1],names,187(options.xmin,options.ymin), \
                     (options.xmax,options.ymax),options.save)
        elif options.plot=="echo":
            echoplot(runs[-1],names,(options.xmin,options.ymin), \
                     (options.xmax,options.ymax),outfile=options.save)
        elif options.plot=="intensity":
            intensity(runs[-1],names,(options.xmin,options.ymin),(options.xmax,options.ymax),outfile=options.save)
        elif options.plot=="poldrift":
            poldrift(runs,(options.xmin,options.ymin),(options.xmax,options.ymax),outfile=options.save)
        elif options.plot=="int2drange":
            plot_int_range(runs[-1])
        elif options.plot=="pol2drange":
            plot_pol_range(runs[-1],mask)

#+end_src


** Export

   The load function performs most of the actual file sorting.  It
   takes a list of run numbers and an optional current for filtering.
   It returns a dictionary.  The keys to the dictionary are the
   various current states that were used for measurements.  The values
   in the dictionary are the lists of runs which were performed in
   those current states.

#+name: reduction_load
#+begin_src python
def load(runs,current=None):
    paths = [basedir + "SESAME_%i/SESAME_%i_runinfo.xml"
             % (run,run) for run in runs]
    return Combiner.load(paths,current)

#+end_src

   The =export= function takes several parameters to determine how to
   properly organize the combined runs.

   - runs :: A list of run numbers
   - sortby :: An index for which element in the current tuple
               returned by the [[Combiner]] should be used to separate the
               measurements.
   - flipper :: The index for the element which contains the power
                supply used as the flipper
   - minmon :: The minimum monitor count rate that should be used as a
               basis for accepting or rejecting runs.
   - watch :: A third power supply to use for filtering.  In addition
              to setting the power supply for the flipper and for
              tuning, we can chose a third power supply where we will
              fix the current.  Only values with that current in the
              power supply will be exported.  This allows us to
              perform a polarization scan of a two dimensional space
              with respect to the power supplies.
   - current :: A current to be watched for in the power supply
                selected by =watch=.
   - filter :: A single current value to be examined at the exclusion
               of others.  The current value is searched for in the
               power supply specified by =sortby=.

  The function begins by using [[Combiner]] to get the metadata for all of
  the runs and place them in the data dictionary.

#+name: reduction_export
#+begin_src python
def export(runs,sortby=None,flipper=0,minmon=8,current=None,\
           filter=None,watch=None):
    data = load(runs,current)

    keys = data.keys()
    print keys
#+end_src

  The =values= variable is the list of possible currents that could be
  in the power supply that's being used for sorting.  If there's no
  sorting, then the value isn't necessary.  If there's a filter on the
  sorting, then only one value can occur.  Otherwise, we pull all of
  the values from the keys.

#+name: reduction_export
#+begin_src python
#

    if sortby is None:
        values = [""]
    else:
        if filter is None:
            values = set([x[sortby] for x in keys])
        else:
            values = [filter]
#+end_src

  The =base= variable stores the directory where all of the data will
  be exported.  By default, it's the data directory of the last run
  being examined.  

#+name: reduction_export
#+begin_src python
#

    base = basedir + "SESAME_%i/" % runs[-1]
#+end_src

  We then divide up the current keys into up state runs, down state
  runs, and "same" runs, when the flipper is turned off.  The up state
  is defined as the flipper current being negative and the down state
  as the flipper current being positive.  Since the bender and
  Helium-3 analyzer require a spin flip to achieve a high count rate,
  the negative convention was chosen.

  In addition to filtering on the flipper, the list comprehensions
  also filter on the =current= and =watch= parameters, as well as the
  =sortby= value.

#+name: reduction_export
#+begin_src python
#

    for value in values:
        if type(value) is not str:
            value = normalize_name(value)
        ups = [x for x in keys if (flipper is None or x[flipper] < 0) \
               and (watch is None or x[choices[watch]]==current) \
               and (sortby is None or normalize_name(x[sortby]) == value)]
        downs = [x for x in keys if (flipper is not None and x[flipper] > 0)  \
                and (watch is None or x[choices[watch]]==current) \
                and (sortby is None or normalize_name(x[sortby]) == value)]
        sames = [x for x in keys if (flipper is not None and x[flipper] == 0)  \
                and (watch is None or x[choices[watch]]==current) \
                and (sortby is None or normalize_name(x[sortby]) == value)]
#+end_src

  When we're only exporting a single current, we can now set the value
  variable back to a blank, just as if there was no =sortby= parameter.

#+name: reduction_export
#+begin_src python
#
        if filter is not None:
            value = "" #Don't put values on files when we're only running a single export
#+end_src

  If we used a =watch= and =current= filter, we'll want to save the
  current in the file name so that we can run the reduction multiple
  times with multiple currents and get multiple files.

#+name: reduction_export
#+begin_src python
#
        if current==None:
            titleend=""
        else:
            titleend="_current="+str(current)
#+end_src

  Finally, the combined runs are saved through the [[Combiner]].  If there
  is no spin up or spin down data, then the =sames= are saved.  Also,
  we do not attempt to save the data if there were no measurements in
  that particular spin state.

#+name: reduction_export
#+begin_src python
#
        if ups == [] and downs == []:
            Combiner.save(base+value+"Combined"+titleend,
                          0,
                          sames,
                          data)
        if ups != []:
            print "-------------- Up state --------------"
            Combiner.save(base+value+"up"+titleend,
                          minmon,
                          ups,
                          data)
        if downs != []:
            print "-------------- Down state --------------"
            Combiner.save(base+value+"down"+titleend,
                          minmon,
                          downs,
                          data)
        
            


#+end_src

The =twoflipper= function allows for exporting the states of a
two-flipper measurement.  This is deprecated, since the same
functionality can be performed by =sortby=.

#+name:reduction_twoflipper
#+begin_src python
def two_flipper(runs, flipper1, flipper2, minmon, current, \
                watch="2"):
    
    data = load(runs,current)
    keys = data.keys()
    values = [""]
    base = basedir + "SESAME_%i/" % runs[-1]

    for value in values:
        if type(value) is not str:
            value = normalize_name(value)
        upup = [x for x in keys if x[flipper1] < 0 and x[flipper2] < 0 \
                and x[choices[watch]]==current]
        updown = [x for x in keys if x[flipper1] < 0 and x[flipper2] > 0 \
                  and x[choices[watch]]==current]
        downup = [x for x in keys if x[flipper1] > 0 and x[flipper2] < 0 \
                  and x[choices[watch]]==current]
        downdown = [x for x in keys if x[flipper1] > 0 and x[flipper2] > 0 \
                    and x[choices[watch]]==current]
        if filter is not None:
            value = "" #Don't put values on files when we're only running a single export

        if upup != []:
            print "-------------- Up/Up state --------------"
            Combiner.save(base+value+"upup_current=" + str(current),
                          minmon,
                          upup,
                          data)
        if updown != []:
            print "-------------- Up/Down state --------------"
            Combiner.save(base+value+"updown_current=" + str(current),
                          minmon,
                          updown,
                          data)
        if downup != []:
            print "-------------- Down/Up state --------------"
            Combiner.save(base+value+"downup_current=" + str(current),
                          minmon,
                          downup,
                          data)
        if downdown != []:
            print "-------------- Down/Down state --------------"
            Combiner.save(base+value+"downdown_current=" + str(current),
                          minmon,
                          downdown,
                          data)
            
        if [upup,updown,downup,downdown]==[[],[],[],[]]:
            print("No data to write")

#+end_src



** Import

The =spectrum= function takes a run number directory (=run=) and a designation
(=name=) and returns the polarization spectrum.  The remaining
optional parameters allow the user to specify which parts of the
detector contain the signal.

#+name: reduction_spectrum
#+begin_src python
def spectrum(run,name,mins=(0,0),maxs=(16,128),mask=None):
    name = normalize_name(name)
    p = PelFile(basedir+"SESAME_%i/" % run + name+"up_neutron_event.dat")
    mon = MonFile(basedir+"SESAME_%i/" % run + name+"up_bmon_histo.dat",False)
    up = p.make1d(mins,maxs,mask)
    uperr = np.sqrt(up)/np.sum(mon.spec)
    up /= np.sum(mon.spec)
    p = PelFile(basedir+"SESAME_%i/" % run + name+"down_neutron_event.dat")
    mon = MonFile(basedir+"SESAME_%i/" % run + name+"down_bmon_histo.dat",False)
    down = p.make1d(mins,maxs,mask)
    downerr = np.sqrt(down)/np.sum(mon.spec)
    down /= np.sum(mon.spec)

    return (up-down)/(up+down)
#+end_src

The =errspectrum= function is similar to =spectrum=, except that it
also returns the uncertainty in the polarization.

#+name: reduction_errspectrum
#+begin_src python
def errspectrum(run,name,mins=(0,0),maxs=(16,128),mask=None):
    name = normalize_name(name)
    p = PelFile(basedir+"SESAME_%i/" % run + name+"up_neutron_event.dat")
    mon = MonFile(basedir+"SESAME_%i/" % run + name+"up_bmon_histo.dat",False)
    up = p.make1d(mins,maxs,mask)
    uperr = np.sqrt(up)/np.sum(mon.spec)
    up /= np.sum(mon.spec)
    p = PelFile(basedir+"SESAME_%i/" % run + name+"down_neutron_event.dat")
    mon = MonFile(basedir+"SESAME_%i/" % run + name+"down_bmon_histo.dat",False)
    down = p.make1d(mins,maxs,mask)
    downerr = np.sqrt(down)/np.sum(mon.spec)
    down /= np.sum(mon.spec)

    p = (up-down)/(up+down)
    err = p*np.sqrt((up-down)**-2+(up+down)**-2)*np.sqrt(uperr**2+downerr**2)
    return p,err
#+end_src


Most of the plotting functions rely upon =getIntegratedSpectra= to get
the actual state counts for their results.  It returns the monitor
normalized intensity spectrums of the spin up and spin down states,
as well as the corresponding uncertainties.

- run :: The run number for the folder containing the data
- name :: Any additional infixed on the name of the run.  This is
          mostly to handle sortby runs where we need to load a
          specific power supply state.
- mins :: The minimum x and y corrdinate on the detector to examine
- maxs :: The maximum x and y corrdinate to examine
- mask :: A bit mask for eliminating unwanted pixels.

In theory, the =spectrum= and =errspectrum= functions can be rewritten
as a quick wrappers around =getIntegratedSpectra=.  You should do
this.

#+name: reduction_getIntegratedSpectra
#+begin_src python
def getIntegratedSpectra(run,name,mins,maxs,mask):
    name = normalize_name(name)
    p = PelFile(basedir+"SESAME_%i/" % run + name+"up_neutron_event.dat")
    mon = MonFile(basedir+"SESAME_%i/" % run + name+"up_bmon_histo.dat",False)
    up = np.sum(p.make1d(mins,maxs,mask)[40:90])
    uperr = np.sqrt(up)/np.sum(mon.spec)
    up /= np.sum(mon.spec)
    p = PelFile(basedir+"SESAME_%i/" % run + name+"down_neutron_event.dat")
    mon = MonFile(basedir+"SESAME_%i/" % run + name+"down_bmon_histo.dat",False)
    down = np.sum(p.make1d(mins,maxs,mask)[40:90])
    downerr = np.sqrt(down)/np.sum(mon.spec)
    down /= np.sum(mon.spec)

    return (up,uperr,down,downerr)

#+end_src

The =reduction_fr= function is a thin wrapper around the
getIntegratedSpectra function to provide the flipping ratio versus
wavelength for a given run.

#+name: reduction_fr
#+begin_src python
def fr(run,name,mins=(0,0),maxs=(16,128),mask=None):
    up,uperr,down,downerr = getIntegratedSpectra(run,name,mins,maxs,mask)

    ratio = up/down
    rerr = ratio * np.sqrt((uperr/up)**2+(downerr/down)**2)

    return (ratio,rerr)
#+end_src

Similarly, =reduction_run_int= gives the total neutron intensity
between the spin up and spin down states.

#+name:reduction_run_int
#+begin_src python
def run_int(run,name,mins=(0,0),maxs=(16,128),mask=None):
    up,uperr,down,downerr = getIntegratedSpectra(run,name,mins,maxs,mask)

    total = up+down
    total_err = np.sqrt(uperr**2+downerr**2)

    return (total,total_err)
#+end_src


The =simple_spectrum= routine is similar to =getIntegrateSpectra=,
but it only loads a single subrun based on the run number.  It's
largest advantage is that the data does not need to be exported for
it to be used.

#+name:reduction_simple_spectrum
#+begin_src python
def simple_spectrum(run,mins=(0,0),maxs=(16,128),mask=None):
    p = PelFile(basedir+"SESAME_%i/SESAME_%i_neutron_event.dat"%(run,run))    
    mon = MonFile(basedir+"SESAME_%i/SESAME_%i_bmon_histo.dat"%(run,run),False)    
    data = p.make1d(mins,maxs,mask)
    err = np.sqrt(data)/np.sum(mon.spec)
    data /= np.sum(mon.spec)

    return (data,err)
#+end_src



Some plots depend more on the 2d detector image and less on the
wavelength spectrum.  The =get_2d_int= function returns a monitor
normalized 2d array representing the neutron intensity per pixel.

- run :: The run number for the directory where the flipping run data
         has been exported
- name :: The name of the data file.  This can theoretically allow
          this function to be used to load the results of a sortby
          operation, but, in practice, it's only ever used for just
          up and down spin states.

#+name:reduction_get_2d_int
#+begin_src python
def get_2d_int(run,name):
    p = PelFile(basedir+"SESAME_%i/" % run + name+"_neutron_event.dat")
    mon = MonFile(basedir+"SESAME_%i/" % run + name+"_bmon_histo.dat",False)
    return np.sum(p.make3d(),axis=2) / np.sum(mon.spec)    
#+end_src


** Plotting

The single plot command takes a single data file and plots it to the
screen.

- run :: The run number of the directory where the file is stored.
- name :: The file name for the data file to be plotted.
- mins :: The upper left pixel of the region of interest on the detector.
- maxs :: The lower right pixel of the region of interest on the detector.

#+name: reduction_singleplot
#+begin_src python
def singleplot(run,name,mins=(0,0),maxs=(16,128)):
    data = spectrum(run,name,mins,maxs)
    data[np.isnan(data)]=0
    plt.plot(np.arange(RESOLUTION)*20.0/RESOLUTION,data,"r-")
    plt.show()
#+end_src

=echofr= takes a list of runs generated by a =sortby= and plots the
flipping ratio, integrated over all wavelengths, versus the current

#+name:reduction_echofr
#+begin_src python
def echofr(run,names,mins=(0,0),maxs=(16,128),mask=None,outfile=None):
#    names = [name for name in names if float(name) != 5.475]
    print names
    data = [fr(run,name,mins,maxs,mask) for name in names]
    errs = np.array([x[1] for x in data])
    data = np.array([x[0] for x in data])
    data[np.isnan(data)]=0
    errs[np.isnan(data)]=1
    xs = np.array([float(x) for x in names])
    print xs
    plt.errorbar(xs,data,yerr=errs)
#    if outfile is None:
    plt.show()
    if outfile is not None:
        np.savetxt(outfile,np.transpose(np.vstack((xs,data,errs))))
    #trying the fitting
    # data = (data-1.0)/(data+1.0)
    # print(data)
    # data = np.log(data)
    # fit = np.polyfit(xs,data,2)
    # a = fit[0]
    # b = fit[1]
    # c = fit[2]
    # print(fit)
    # plt.plot(xs,np.exp(data),"b*")
    # plt.plot(xs,np.exp(c+b*xs+a*xs**2),"r-")
    # plt.show()
    # print(-1*b/(2*a))
#+end_src

=echodiff= is useful for finding position sensitive differences in the
echo polarization.  It plots a color plot versus both tuning current
and wavelength.  The intensity in the plot is based on the difference
in neutron precession angle, in radians, between the top and bottom of
the detector.  The =split= variable is used to declare the dividing
line between the "top" and the "botto".

#+name:reduction_echodiff
#+begin_src python
def echodiff(run,names,split,mins,maxs,outfile=None):
    data = np.vstack(tuple([np.arccos(spectrum(run,name,mins,(split,302))) - 
                            np.arccos(spectrum(run,name,(split,223),maxs)) for name in names]))

    data[np.isnan(data)]=0

    xs = np.arange(RESOLUTION)*20.0/RESOLUTION
    ys = np.array([float(x) for x in names])
    plt.pcolor(xs,ys,data,vmin=-np.pi,vmax=np.pi)
    if outfile is None:
        plt.show()
    else:
        print name
        plt.savefig(outfile)
        plt.clf()
#+end_src

The =echoplot= is a full spectrum color plot of the echo tune.  The
axes are wavelength and tuning current and the color represents the
polarization.  This is slower =echofr= and harder to read.  However,
it does have the advantage that it's possible to distinguish between a
deploarized beam and a beam which is far from echo.  It's also
possible to to tell whether a given peak is on echo or just near it.
=echoplot= also can show if there are problems out at long
wavelengths, which would be masked by the high counts at short
wavelength in =echofr=.  Finally, it's much prettier than =echofr=.

#+name:reduction_echoplot
#+begin_src python
def echoplot(run,names,mins=(0,0),maxs=(16,128),mask=None,outfile=None):
    data = [errspectrum(run,name,mins,maxs,mask) for name in names]
    errs = np.vstack(tuple([d[1] for d in data]))
    data = np.vstack(tuple([d[0] for d in data]))
    data[np.isnan(data)]=0
    xs = np.arange(101)*0.1
    ys = sorted([float(x) for x in names])
    ys += [ys[-1]+ys[1]-ys[0]] #Add last element
    ys = np.array(ys)
    plt.pcolor(xs,ys,data,vmin=-1,vmax=1)
    if outfile is None:
        plt.show()
    else:
        print name
        if outfile[-4:] == ".png":
            plt.savefig(outfile)
            plt.clf()
        else:
            with open(outfile,"w") as of:
                y,x = data.shape
                of.write("wavelength\tcurrent\tpolarization\terror\n")
                for i in range(x):
                    for j in range(y):
                        print((xs[i],ys[j]))
                        print(data[j,i])
                        of.write("%f\t%f\t%f\t%f\n"
                                 %(xs[i],ys[j],data[j,i],errs[j,i]))



#+end_src

The =intensity= plot gives the detector count, with uncertainty,
versus current.  It doesn't come in handy very often.

#+name:reduction_intensity
#+begin_src python
def intensity(run,names,mins=(0,0),maxs=(16,128),mask=None,outfile=None):
    names = [name for name in names if float(name) != 5.475]
    data = [run_int(run,name,mins,maxs,mask) for name in names]
    errs = np.array([x[1] for x in data])
    data = np.array([x[0] for x in data])
    data[np.isnan(data)]=0
    errs[np.isnan(data)]=1
    xs = np.array([float(x) for x in names])
    plt.errorbar(xs,data,yerr=errs)
#    if outfile is None:
    plt.show()
    if outfile is not None:
        np.savetxt(outfile,np.transpose(np.vstack((xs,data,errs))))

#+end_src

The =poldrift= function plots the polarization versus run number.
This functionality has laregely been supplanted by [[beamdeath]], which
makes runs far faster, though it does not produce errorbars.

#+name:reduction_poldrift
#+begin_src python
def poldrift(runs,mins,maxs,outfile=None):
    if len(runs)%2 == 1:
        runs = runs[:-1]
    ups = [simple_spectrum(run,mins,maxs)
                           for run in runs[1::2]]
    downs = [simple_spectrum(run,mins,maxs)
                           for run in runs[0::2]]
    uperrs = np.array([np.sqrt(np.sum(run[1]**2)) for run in ups])
    downerrs = np.array([np.sqrt(np.sum(run[1]**2)) for run in downs])
    ups = np.array([np.sum(run[0]) for run in ups])
    downs = np.array([np.sum(run[0]) for run in downs])
    p = ups/downs
    err = p * np.sqrt((uperrs/ups)**2+(downerrs/downs)**2)
    xs = np.array(runs[0::2])
    plt.errorbar(xs,p,yerr=err)
    plt.show()
    if outfile is not None:
        np.savetxt(outfile,np.transpose(np.vstack((xs,p,err))))

#+end_src

The =plot_2d_range= plot takes in a 3D data set of any sort.  It then
finds creates a scatter plot.  The x axis of the scatter plot is a
given pixel value.  The y axis is the number of pixel whose value is
less than the x-coordinate.  Think of it like a cummulative histogram
of the data.

The optional =rnge= variable gives the domain of the x-axis.  If no
domain is given, it runs over the full pixel value range of the given
data.  The =steps= parameter can be used to chose the resolution of
the plot along the x-axis.  Finally, =mask= can be used to pass a
binary mask of pixels to ignore.

#+name:reduction_plot_2d_range
#+begin_src python
def plot_2d_range(data,rnge=None,steps=100,mask=None):
    """Takes a 2d data set and plots a plateau plot"""
    if type(rnge) is tuple:
        vmin,vmax=rnge
    else:
        vmin = np.min(data)
        vmax = np.max(data)
    if mask is None:
        mask = data >= vmin
    print(vmax,vmin,steps)
    print((vmax-vmin))
    print((vmax-vmin)/steps)
    xs = np.arange(vmin,vmax,(vmax-vmin)/steps)
    ys = [len(np.where(np.logical_and(data<x,mask))[0]) for x in xs]
    ys = np.array(ys)
    plt.plot(xs,ys,"r*")
    plt.show()
#+end_src

The =plot_int_range= takes a single run number and plots a cumulative
histogram of the wavelength integrate intensity of the pixels.  The
x-axis is the minimum pixel intensity and the y axis is how many
pixels meat that minimum.  The function examines both spin states for
the run and it is assumed that reduction has already exported the up
and down run files for that run.

#+name:reduction_plot_int_range
#+begin_src python
def plot_int_range(run):
    up = get_2d_int(run,"up")
    down = get_2d_int(run,"down")
    plot_2d_range(up+down,steps=1000)
#+end_src

The =plot_pol_range= function is similar to =plot_int_range=, except
that it examines the polarization at each pixel, instead of the total intensity.

#+name:reduction_plot_pol_range
#+begin_src python
def plot_pol_range(run,mask=None):
    up = get_2d_int(run,"down")
    down = get_2d_int(run,"up")
    plot_2d_range((up-down)/(up+down),(-1.0,1.0),mask=mask)
#+end_src


=normalize_name= takes either a number or an empty string.  If it
takes an empty string, it returns the same.  If it gets a number, it
returns a string with that number out to three places after the
decimal.  This is useful for naming runs, since we don't always want
to append a current value to the file name.

#+name:reduction_normalize_name
#+begin_src python
def normalize_name(name):
    if name != '':
        return "%0.3f"%float(name)
    else:
        return name
#+end_src

* Power Supplies

  The power supplies are currently controlled via an DAC card on the
  motor computer.  This card sends an analog voltage between -10 V and
  10 V to each power supply, which is then used to control the
  current.

  To run the power supplies, the =ps_server.py= program must be run on
  the Motor computer and the =Coils= class needs to be loaded into
  PyDAS.  The =sesame_init.py= script currently loads the power supply
  client into the variable =coils=.
  
** Power Supply Server

*** Power Supply Class Module

**** Module Skeleton

#+name: power_supply_skeleton 
#+begin_src python :tangle ps.py :noweb tangle :padline no
import __future__
import ctypes
import numpy
import struct
import json

<<power_supply_constants>>
<<power_supply_compensate>>
class PowerSupply:
    
    def __init__(self):
        <<power_supply_init>>
    <<power_supply_set>>

    <<power_supply_triangle>>
    <<power_supply_fields>>
    <<power_supply_chk>>
    <<power_supply_stop>>
    def __del__(self):
        self.stop()



if __name__=="__main__":
    x=PowerSupply()


#+end_src


**** Constants

The nidaq object is a link to the DLL file which contains National
Instrument DAQmx interface to their hardware.  It may not be quite as
friendly as something like Measurement Studio, but it's actually a nice
and simple API and it gets the job done.  All of the functions in the
[[file://C:/Program Files/National Instruments/NI-DAQ/docs/daqmxcfunc.chm][NI-DAQmx C Reference Help]] are available from this DLL.  This help
reference is installed with the drivers and you should update the link
to where it is install on your computer.

#+name: power_supply_constants
#+begin_src python

nidaq = ctypes.windll.nicaiu #Link to nicaiu.dll
#+end_src

Since DAQmx is a C api, we do need to care about the size of our data
types.  The [[https://docs.python.org/2/library/ctypes.html][python ctypes]] module can handle most of these conversions
for us.  I've included some simple names to both help keeping track of
bit size and to simplify the code.

#+name: power_supply_constants
#+begin_src python

int32 = ctypes.c_long
uInt32 = ctypes.c_ulong
uInt64 = ctypes.c_ulonglong
float64 = ctypes.c_double
TaskHandle = uInt32
#+end_src

The following constants are from the C header files for DAQmx.  

#+name: power_supply_constants
#+begin_src python


DAQmx_Val_Cfg_Default = int32(-1)
DAQmx_Val_Volts = 10348
DAQmx_Val_Rising = 10280
DAQmx_Val_FiniteSamps = 10178
DAQmx_Val_ContSamps = 10123
DAQmx_Val_GroupByChannel = 0
#+end_src

The triangles array is no longer used and should be removed

#+name: power_supply_constants
#+begin_src python

#List of which tasks control the triangles
triangles = ["Triangle1",
             "Triangle2",
             "Triangle3",
             "Triangle4",
             "Triangle5",
             "Triangle6",
             "Triangle7",
             "Triangle8"]
#+end_src

The =supplies= maps between the power supply names and the DAQmx
channels that we intend to control.  

#+name: power_supply_constants
#+begin_src python

#Dictionary of tasks which contorl small supplies
supplies = {"flipper":"Flipper",
            "phase":"Phase",
            "guides":"Guides",
            "sample":"Sample"}


#+end_src

The =compensate= function is a simple helper to scale a current with a
slope =m= and y-intercept =b= given in a dictionary.  

#+name: power_supply_compensate
#+begin_src python
def compensate(value,f):
    return value*f['m']+f['b']

#+end_src


**** Initialization

We need to load the DAQmx task for each control channel for each power
supply.  The triangles are stored in a simple list, while other
supplies can be stored in a dictionary.

If you are looking for a good place to improve the program, this could
probably be turned into a single list corresponding to the power
supply number, which could then be access through a dictionary.  It's
the best of both worlds.

#+name: power_supply_init
#+begin_src python


        self.triangleHandles = []
        self.supplyHandles = {}
#+end_src

We also create a dictionary to store the current current in each power
supply.  As we don't have any read back function at the moment, this is
the best we can do.

#+name: power_supply_init
#+begin_src python

        self.values = {}
#+end_src

We now load the DAQmx task for each hardware channel for each power
supply.  The tasks are referenced by a TaskHandle, which we pass as a
pointer to the =LoadTask= function.  Note that, since we're working
with pointers, we need to create a new task handle object each time.
Otherwise, it'll always be the same pointer to the same object and
each cycle through the loop will overwrite all of the previous values.

#+name: power_supply_init
#+begin_src python

        for t in triangles:
            taskHandle = TaskHandle(0)
            print t
            self.CHK(nidaq.DAQmxLoadTask(t,
                              ctypes.byref( taskHandle )))
            self.triangleHandles.append(taskHandle)
            self.triangle
#+end_src

We perform a similar operation for the non-triangle supplies, with
task handles being reference by name in a dictionary, instead of an
index on a list.

#+name: power_supply_init
#+begin_src python
        for (k,v) in supplies.items():
            taskHandle = TaskHandle(0)
            self.CHK(nidaq.DAQmxLoadTask(v,
                              ctypes.byref( taskHandle )))
            self.supplyHandles[k] = taskHandle
            
        print self.supplyHandles
#+end_src

The relationship between DAC voltage and power supply current is
stored in a [[http://json.org][JSON]] file.  The file should contain an object with one
member for each power supply.  That member should have two members of
its own, representing the slope =m= and intercept =b=.

#+name: power_supply_init
#+begin_src python

        with open("calibration.json") as configFile:
            self.calibration = json.load(configFile)

#+end_src

Finally, we see all of the power supply currents to zero to start.

#+name: power_supply_init
#+begin_src python

        self.values['triangles'] = [0]*8
        for i in range(1,9):
            self.triangle(i,0)
        self.flipper(0)
        self.guides(0)
        self.phase(0)
        self.sample(0)
            


#+end_src


**** Low Level Control

The set function takes a task handle and a voltage value and tell
that task to output the given voltage

#+name: power_supply_set
#+begin_src python

    def set(self,task,x):
        """Takes a task handle and a current and sets that task to that current."""
        self.CHK(nidaq.DAQmxWriteAnalogScalarF64( task,
                                                  True,
                                                  float64(1.0),
                                                  float64(x), #Voltage
                                                  None))
#+end_src

Since we're using the C interface to DAQmx, we don't have the benefit
of such linguistic niceties as exceptions.  Instead, each function
call returns an error code.  An error of zero indicates that the
function returned properly.  A positive error code indicates that a
warning was generated.  A negative error code indicates that the
function failed.  The =CHK= function reads the error code and, if a
warning or error was triggered, it raises an exception with a
description of the problem.

#+name: power_supply_chk
#+begin_src python
    def CHK( self, err ):
        """a simple error checking routine"""
        if err < 0:
            buf_size = 100
            buf = ctypes.create_string_buffer('\000' * buf_size)
            nidaq.DAQmxGetErrorString(err,ctypes.byref(buf),buf_size)
            raise RuntimeError('nidaq call failed with error %d: %s'%(err,repr(buf.value)))
        if err > 0:
            buf_size = 100
            buf = ctypes.create_string_buffer('\000' * buf_size)
            nidaq.DAQmxGetErrorString(err,ctypes.byref(buf),buf_size)
            raise RuntimeError('nidaq generated warning %d: %s'%(err,repr(buf.value)))
                
#+end_src

The shop function ends all of the tasks and clears the task handles.
This is necessary to allow another application to access the tasks
afterward.  This function is also called by the destructor of the
class to handle the cleanup.

#+name: power_supply_stop
#+begin_src python
    def stop( self ):
        for task in self.triangleHandles:
            self.set(task,0)
            nidaq.DAQmxStopTask( task )
            nidaq.DAQmxClearTask( task )
        for task in self.supplyHandles:
            self.set(task,0)
            nidaq.DAQmxStopTask( task )
            nidaq.DAQmxClearTask( task )
            

#+end_src


**** High Level Control

The currents through the triangles are set via the =triangle=
function.  The current current is returned via the =getTriangle=
function.  Each function takes a =tri= prarameter, which is the number
of the triangle supply from 1 to 8.  We do a little arithmetic to
account for the fact that the list index ranges from 0 to 7.

#+name: power_supply_triangle
#+begin_src python
    def triangle(self,tri,curr):
        self.set(self.triangleHandles[tri-1],
                 compensate(curr,self.calibration['tri'+str(tri)]))
        self.values['triangles'][tri-1]=curr
        return self.getTriangle(tri)

    def getTriangle(self,tri):
        return self.values['triangles'][tri-1]

#+end_src

There is almost identical code for the other power supplies.  There
should be a way to eliminate this boilerplate code.

#+name: power_supply_fields
#+begin_src python

    def flipper(self,curr):
        self.set(self.supplyHandles["flipper"],
                 compensate(curr,self.calibration['flipper']))
        self.values['flipper']=curr
        return self.getFlipper()
    def getFlipper(self):
        return self.values['flipper']
    
    def guides(self,curr):
        self.set(self.supplyHandles["guides"],
                 compensate(curr,self.calibration['guides']))
        self.values['guides']=curr
        return self.getGuides()
    def getGuides(self):
        return self.values['guides']
    def phase(self,curr):
        self.set(self.supplyHandles["phase"],
                 compensate(curr,self.calibration['phase']))
        self.values['phase']=curr
        return self.getPhase()
    def getPhase(self):
        return self.values['phase']
    def sample(self,curr):
        self.set(self.supplyHandles["sample"],
                 compensate(curr,self.calibration['sample']))        
        self.values['sample']=curr
        return self.getSample()
    def getSample(self):
        return self.values['sample']



#+end_src


*** Power Supply Server

The power supplies are controlled over the network by the program
=ps_server.py=.  We use an [[http://en.wikipedia.org/wiki/XML-RPC][XML-RPC]] server to allow other computers to
call functions.  This server is attached to a single PowerSupply
object and allows us to call any of its member functions.  The actual
server parts of the code are conveniently supplied by the python
[[https://docs.python.org/2/library/simplexmlrpcserver.html][SimpleXMLRPCServer]] class.

#+begin_src python :tangle ps_server.py :padline no
from ps import PowerSupply
from SimpleXMLRPCServer import SimpleXMLRPCServer
from SimpleXMLRPCServer import SimpleXMLRPCRequestHandler


# Restrict to a particular path.
class RequestHandler(SimpleXMLRPCRequestHandler):
    rpc_paths = ('/RPC2',)

# Create server
server = SimpleXMLRPCServer(("192.168.70.160", 7892),
                            requestHandler=RequestHandler)
server.register_introspection_functions()

server.register_instance(PowerSupply())

server.serve_forever()

#+end_src


** Power Supply Client

The =Coils= module implements an XMLRPC client to go along with the
XMLRPC server we defined in the previous section.  By inheriting from
the [[https://docs.python.org/2/library/xmlrpclib.html][ServerProxy]] class, we can treat the object produced as though it
were a PowerSupply object on the motor computer.

The only intialization parameter is =failmethod= which is a function
to call when the server is unreachable.  It can be used to send
e-mails, but it's currently not used, as we've turned off most of the
e-mail functionality in the move to PyDAS.

#+begin_src python :tangle Coils.py :padline no
"""This module handles controlling the current through the solenoids

This code was written to talk with a custom labview server on the
current control computer.  Note that, currently, the server does
not respond with the current currents.  When you first load the
module, you should set all of the current values to synchronize
with the server.

"""

import __future__
import xmlrpclib

class Coils(xmlrpclib.ServerProxy):
    """This object manages the connection to the current control server"""
#    HOST = "http://192.168.70.160"#IP address for the server
    HOST = "http://192.168.70.160"
    PORT=7892#port number for the server

    def __init__(self,failmethod):
        """Creates the connection object"""
        xmlrpclib.ServerProxy.__init__(self,self.HOST + ":" + str(self.PORT) + "/RPC2")
        self.fail = failmethod
#+end_src

There's a flip function hard coded into the object.  In practice, I'd
recommend against using it and it should probably be removed.

#+begin_src python :tangle Coils.py :padline no
#
    def flip(self):
        """Reverses the current through the flipping coil"""
        self.proxy.flipper(-1*self.proxy.getFlipper())
#+end_src

We've overloaded the =__getattr__= function to allow us to
automatically place the function in a wrapper that calls a function is
the method fails.  In practice, we're not using this right now and it
should also be removed.

#+begin_src python :tangle Coils.py :padline no
#
    def __getattr__(self,name):
        method = xmlrpclib.ServerProxy.__getattr__(self,name)
        def wrapped(*args):
            try:
                return method.__call__(*args)
            except Exception, e:
                self.fail("SESAME Power Supply Server Down",
                          "The SESAME beamline has lost its connection to the power supply server",
                          "Notthepassword")
                print("Connection Failed")
                print(e)
                raise e
        return wrapped
        

if __name__=="__main__":
    coils = Coils()
    for i in range(1,5):
        coils.triangle(i,i*2-1)
    

#+end_src
#  LocalWords:  livewatch

#+TITLE: PELVis: The PEL Visualizer
#+AUTHOR: Adam Washington
#+OPTIONS: toc:4

* Introduction

  This docment is a [[http://www.literateprogramming.com/index.html][literate]] program for analyzing data collected on
  the SESAME beamline. The document itself was written in
  [[http://orgmode.org/][Org Mode]] while the majority of the source is intended to be run
  through python.

  If your primary goal is to simply use PELVis, then the
  [[file:readme.org][user documentation]] would be the best place to start.

* PELVis application

  The main user application is the pelvis.py script that the user runs
  to view neutron data.

** Application skeleton

   Below is the rough layout of the PELVis application.  More details can be found in the individual sections

#+begin_src python :tangle pelvis.py :noweb tangle :padline no
  """A GUI for handling polarization data generated by a PAPA detector.
  
  This program was written to help with analyzing polarization data produced
  by the PAPA detector.  The general workflow is:
  1)Load Neutron Data
  2)Subtract Background
  3)Select Region of Interest
  4)Plot Spectrum data
  
  The primary class is PelvisFrame, which controls the whole program.
  PelvisFrame contains a PositionPanel, to examine single pixels, and
  a PelvisOptionPanel, which accepts user parameters.
  
  """
  
  <<pelvis_imports>>
  
  RESOLUTION = 400

  <<position_panel>>
  <<pelvis_option_panel>>
  <<pelvis_frame>>
  if __name__=="__main__":
      app=wx.PySimpleApp()
      pelvisframe = PelvisFrame(app.Yield)
      app.MainLoop()
  
#+end_src
** Imports

   The PELVis application uses a large number of packages to handle
   the work. 


   This code was originally written for Python 2.5.  This version of
   Python did not have the =with= statement and needed it imported
   from the future.  If PELVis is run on version 2.6 or later, this
   should not be an issue.  As such, it should be possible to remove
   this import, but it has not been tested.
#+name:pelvis_imports
#+begin_src python
  import __future__
#+end_src

   The [[Reader][PelFile]] class handles all of the data loading from the neutron
   event files.

#+name:pelvis_imports
#+begin_src python
  
  from reader import PelFile
#+end_src

   [[ImagePanel]] is a custom widget for displaying 2D graph data in a
   wxPython frame.

#+name:pelvis_imports
#+begin_src python
  from ImagePanel import ImagePanel
#+end_src

   [[GraphPanel][GraphPanel]] is a custom widget for displayed 1D graphs in a wxPython
   Frame.

#+name:pelvis_imports
#+begin_src python
  from GraphPanel import GraphPanel
#+end_src

   The [[ColorBarPanel]] is a custom widget for displaying a legended
   color bar for 2D color maps.  The [[ColorMapPicker]] is a custom dialog
   for chosing a color bar.

#+name:pelvis_imports
#+begin_src python
  from colorbarpanel import ColorBarPanel, ColorMapPicker
#+end_src

   The [[MonFile]] class handles reading the SNS monitor count files.

#+name:pelvis_imports
#+begin_src python
  from monfile import MonFile
#+end_src

   [[SpectrumDialog]] is a custom dialog which handles viewing and
   exporting 1D spectral data from the Pelvis application.

#+name:pelvis_imports
#+begin_src python
  from SpectrumDialog import SpectrumDialog
#+end_src

   The Python built-in TemporaryFile class is used to cache Flat
   Files, since they can use a large amount of memory.  If the Flat
   File functionality is removed, this import can be dropped.

#+name:pelvis_imports
#+begin_src python
  
  from tempfile import TemporaryFile
#+end_src

   =math= is not used, as it has been essentially superseded by
   numpy.  This import should be dropped.

#+name:pelvis_imports
#+begin_src python
  
  import math
#+end_src

   =time= is used for sleeping in a couple of functions.  This is
   almost never truly necessary and probably should be dropped.

#+name:pelvis_imports
#+begin_src python
  import time
#+end_src

   [[http://docs.numpy.org][=numpy=]] is a Python library for handling multidimensional arrays.
   It is many orders of magnitude faster and smaller than using Python
   Lists, plus easier to read, once you're used to it.  By local
   convention, =numpy= is always imported as =np=, just because it's
   called so often.

#+name:pelvis_imports
#+begin_src python
  
  import numpy as np
#+end_src

   [[http://matplotlib.org][=matplotlib=]] is a plotting library for python.  It handles all of
   the plots within the application.

#+name:pelvis_imports
#+begin_src python
  from matplotlib import pyplot as plt
#+end_src

   The =cm= submodule of matplotlib handles color maps and is needed for
   controlling the display of the 2D detector data.

#+name:pelvis_imports
#+begin_src python
  import matplotlib.cm as cm
#+end_src

   [[http://www.wxpython.org][wx]] is the GUI toolkit used to make the user interface for PelVis

#+name:pelvis_imports
#+begin_src python
  
  import wx
#+end_src


** GUI Controls

   We're using [[https://www.wxwidgets.org/][wxWidgets]] as our GUI toolkit through the [[http://www.wxpython.org][wxPython]]
   binding library.  wxWidgets was chosen as it is cross platform and
   provided a more complete toolkit than the default Tk toolkit that
   comes with Python.  The largest disadvantage to this decision is
   that wxPython has not yet been officially ported to Python 3.

*** Pelvis Frame

    The Pelvis Frame is the main UI for the application.
    Unfortunately, it also contains a large amount of application
    logic, which should be extracted out into its own class.  That
    would certainly make working on the Reduction programs easier.
    If you're looking for a good improvement to make to the code.
    This would be it.

    The class starts off with a large number of constant definitions.
    These constants are identifiers for menu commands, which are
    needed for the wxWidget menu system.

#+name:pelvis_frame
#+begin_src python
  class PelvisFrame(wx.Frame):
      """The main application window for PELvis"""
  
      #Menu ID constants
      ID_OPEN = 100
      ID_OPENTWO = 110
      ID_SAVE = 130
      ID_SPECTRUM=140
      ID_IMAGE_ARRAY=160
      ID_EXIT = 190
  
      ID_GREY = 200
      ID_HUEVAL = 220
      ID_SPECTRAL = 230
      ID_PICKER = 290
      ID_POLAR = 300
      ID_FLIPPING = 310
      ID_SPIN_UP = 320
      ID_SPIN_DOWN = 330
  
      ID_FLAT = 420
      ID_FAKEFLAT = 430
      ID_ROD = 440
      ID_EXPORT_ROI = 450
      ID_IMPORT_ROI = 460
  
      ID_COPY = 500
  
      def __init__(self,Yield):
          <<pelvis_frame_init>>
  
      <<pelvis_handle_pels>>
  
      <<pelvis_on_image_array>>
  
      <<pelvis_load_norm_pel>>
                  
  #    def getLambdaRange(self):
  #        try:
  #            lmin = int(float(self.lambdaMin.GetValue())*10)
  #        except ValueError:
  #            lmin = 0
  #        try:
  #            lmax = int(float(self.lambdaMax.GetValue())*10)
  #        except ValueError:
  #            lmax = 200 
  #        return (lmin,lmax)
  
      <<pelvis_updaters>>
  
      <<pelvis_on_update_button>>
  
      <<pelvis_on_open>>
  
      <<pelvis_on_open_set>>
  
      <<pelvis_flat_files>>
  
      <<pelvis_menu_commands>>  
      def setColorMap(self,cmap):
          """Changes to the given colormap"""
          self.imPanel.cmap = cmap
          self.colorbar.setCmap(cmap)
          self.update()
  
  
      <<pelvis_on_exit>>
      <<pelvis_load_up_and_down>>
  
      <<pelvis_menu_commands_2>>
                  
  
  
  
#+end_src

**** Initialization

     The frame is created with a single parameter: =Yield=.  This points
     to a function which allows Pelvis to temporarily return control
     back to the GUI.  This is necessary to amintain responsiveness
     of the user interface while performing long calculations
     (e.g. loading a file).

     We start by creating a wxFrame.  We also set the initial data to
     an empty file, store the =Yield= command, and create a default
     data mask that accepts all pixels.

#+name:pelvis_frame_init
#+begin_src python
          """Create a PELvis frame
  
          Keyword arguments:
          Yield -- A function to give control back to the main event loop
  
          """
          wx.Frame.__init__(self,None,wx.ID_ANY,"PEL Visualizer")
          self.data = PelFile()
          self.Yield = Yield
          self.mask = np.ones((128,16),dtype=np.bool)
#+end_src


     Now we can create the actual components of the GUI.  The =xPanel=
     and =yPanel= are [[GraphPanel][graphs]] which display the integrated intensity
     along an axis.  =imPanel= displays the actual, 2D detector [[ImagePanel][image]].
     =colorbar= gives the current scale of the color scheme on the
     imPanel.  =opPanel= is a generic [[Option Panel][panel]] for the user to input data
     about the current region of interest.  =posPanel= displays
     position information to the user.  =cmp= stores the current color
     map for use on the =imPanel=. =specDlg= is a [[SpectrumDialog][dialog box]]
     which handles displaying and saving wavelength spectrums.
     Finally, =imageSaveDialog= is a custom file saving dialog for
     handling saving the current detector image to a file.

#+name:pelvis_frame_init
#+begin_src python  
          #Create items in the frame
          self.yPanel = GraphPanel(self,(2,8),64,GraphPanel.VERTICAL)
          self.xPanel = GraphPanel(self,(8,2),64,GraphPanel.INVERTED)
          self.colorbar = ColorBarPanel(self,cm.jet)
          self.opPanel = PelvisOptionPanel(self)
          self.posPanel = PositionPanel(self)
          self.imPanel = ImagePanel(self,self.posPanel.set,
                                    self.opPanel.setPosMin,self.opPanel.setPosMax)
          self.specDlg = SpectrumDialog(self)
  
          self.cmp = None #color map
          self.imageSaveDialog=wx.FileDialog(self,"Choose graphics file",wildcard="Portable Network Graphic (png)|*.PNG|Windows Bitmap (bmp)|*.BMP|Joint Photographic Experts Group (jpg)|*.JPG|Portable Network Monocrome (pnm)|*.PNM|Tagged Image File Format (tif)|*.TIF|Archaic, useless format (pcx)|*.PCX",style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
#+end_src

     The Pelvis Frame class has two dynamic member functions.  The
     first is =update=, which is responsible for setting the image in
     the image panel.  The function assumes that the 3D array of data
     that has been displayed hasn't changed, but that some of the
     parameters for the display (e.g. wavelength range, intensity
     caps) may have changed.  The other member function, =updateData=,
     is used whenever the underlying 3D array may have changed.

#+name:pelvis_frame_init
#+begin_src python  
  
          self.update = self.updateSingle#update the image
          self.updateData = self.updateSingleData#update the data in the image
#+end_src

     Below is the creation and layout of the menu for the PELVis
     application.  To add an entry to a menu, we need to append both a
     message code (e.g. =ID_EXIT=) and a title.  If the title contains
     a tab character, a hotkey can follow that tab character to allow
     for a more keyboard oriented interaction with the program.
     Additionally, if there is an ampersand in front of a character,
     then that character will serve as the hotkey for that command
     when accessing the menu through the keyboard.  The =Append=
     function will also accept tooltext for the menu, but the current
     version of wxpython seems to be ignoring it.

#+name:pelvis_frame_init
#+begin_src python  
  
          #Create the menu
          menubar = wx.MenuBar()
          filemenu = wx.Menu()
          editmenu = wx.Menu()
          scalemenu = wx.Menu()
          analysismenu = wx.Menu()
          noisemenu = wx.Menu()
  
          #populate the menu
          filemenu.Append(self.ID_OPEN,"&Open\tCtrl-O"," Open a PEL file")
          filemenu.Append(self.ID_OPENTWO,"&Polarized Set"," Open two PEL files")
          filemenu.Append(self.ID_SAVE,"&Save\tCtrl-S"," Save an image file")
          filemenu.Append(self.ID_SPECTRUM,"Spectrum"," View the TOF spectrum")
          filemenu.Append(self.ID_IMAGE_ARRAY,"&Export Images..."," Save a series of TOF snapshots")
          filemenu.Append(self.ID_EXIT,"&Quit\tCtrl-Q"," Quit")
  
          editmenu.Append(self.ID_COPY,"&Copy\tCtrl-c","Copy the current image to the clipboard")
  
          scalemenu.Append(self.ID_GREY,"Greyscale\tCtrl-G","Monochrome images")
          scalemenu.Append(self.ID_HUEVAL,"Hue and Value\tCtrl-H","Scaled Rainbow Images")
          scalemenu.Append(self.ID_SPECTRAL,"spectral","Uses spectrum of light")
          scalemenu.Append(self.ID_PICKER,"Map Picker..."," Select from the full list of colormaps")
  
          analysismenu.Append(self.ID_POLAR,"Check Polarization\tCtrl-P","2d plot of polarization data")
          analysismenu.Append(self.ID_FLIPPING,"Check Flipping Ratio\tCtrl-F","2d plot of  spin up over spin down")
          analysismenu.Append(self.ID_SPIN_UP,"View Spin Up State\tCtrl-U","2d plot of  spin up")
          analysismenu.Append(self.ID_SPIN_DOWN,"View Spin Down State\tCtrl-D","2d plot of  spin down")
  
          noisemenu.Append(self.ID_FLAT,"&Load Flat"," Load a blank run for background subtraction")
          noisemenu.Append(self.ID_FAKEFLAT,"Si&mulate Flat"," Drop out background within the same image")
          noisemenu.Append(self.ID_ROD,"Region of &Disinterest"," Drop out background within the same image")
          noisemenu.Append(self.ID_EXPORT_ROI,"Export ROI"," Export a binary file corresponding to where the data is above the minimum intensity.")
          noisemenu.Append(self.ID_IMPORT_ROI,"Import ROI"," Add another exclusion mask.")
#+end_src

     Each menu item needs to be bound to a function.  This is
     performed by connecting the menu signal (e.g. =ID_EXIT=) to the
     corresponding function (e.g. =OnExit=).  There's probably a
     better way of doing this through some config file, but that will
     be left as an exercise to the reader.

#+name:pelvis_frame_init
#+begin_src python  
  
  
          #Bind events to the menu
          self.Connect(self.ID_EXIT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnExit)
          self.Connect(self.ID_OPEN,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnOpen)
          self.Connect(self.ID_OPENTWO,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnOpenSet)
          self.Connect(self.ID_SAVE,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSave)
          self.Connect(self.ID_SPECTRUM,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSpectrum)
          self.Connect(self.ID_IMAGE_ARRAY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnImageArray)
          self.Connect(self.ID_GREY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnGrey)
          self.Connect(self.ID_HUEVAL,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnHueVal)
          self.Connect(self.ID_SPECTRAL,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnSpectral)
          self.Connect(self.ID_PICKER,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnPicker)
          self.Connect(self.ID_POLAR,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnPolar)
          self.Connect(self.ID_FLIPPING,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFlipping)
          self.Connect(self.ID_SPIN_UP,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnAnalysisSpinUp)
          self.Connect(self.ID_SPIN_DOWN,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnAnalysisSpinDown)
  
          self.Connect(self.ID_FLAT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFlat)
          self.Connect(self.ID_FAKEFLAT,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnFakeFlat)
          self.Connect(self.ID_ROD,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnROD)
          self.Connect(self.ID_EXPORT_ROI,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnExportROI)
          self.Connect(self.ID_IMPORT_ROI,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnImportROI)
          self.Connect(self.ID_COPY,-1,wx.wxEVT_COMMAND_MENU_SELECTED,self.OnCopy)
#+end_src

     We can now add the menus into the menubar and assign that menubar
     to the application.  Adding an ampersand into the title of a
     menu assigns an Alt hotkey to that menu (e.g. pressing Alt+F
     will open the =&File= menu).

#+name:pelvis_frame_init
#+begin_src python  

  
          menubar.Append(filemenu,"&File")
          menubar.Append(editmenu,"&Edit")
          menubar.Append(scalemenu,"&Color")
          menubar.Append(analysismenu,"&Analysis")
          menubar.Append(noisemenu,"&Noise")
          self.SetMenuBar(menubar)
#+end_src

     We can now add all of the GUI components to the window.  A
     progress bar is added to the bottom of the window to give
     feedback on the loading of files.

#+name:pelvis_frame_init
#+begin_src python  
  
          #arrange window
          sizer = wx.GridBagSizer()
          sizer.Add(self.colorbar,pos=wx.GBPosition(0,9),span=wx.GBSpan(9,1))
          sizer.Add(self.imPanel,pos=wx.GBPosition(0,1),span=wx.GBSpan(8,8))
          sizer.Add(self.yPanel,pos=wx.GBPosition(0,0),span=wx.GBSpan(8,1))
          sizer.Add(self.xPanel,pos=wx.GBPosition(8,1),span=wx.GBSpan(1,8))
          sizer.Add(self.opPanel,pos=wx.GBPosition(0,10),span=wx.GBSpan(8,1),flag=wx.EXPAND)
          sizer.Add(self.posPanel,pos=wx.GBPosition(8,0),flag=wx.EXPAND)
          self.progress = wx.Gauge(self,range=1000)
          sizer.Add(self.progress,pos=wx.GBPosition(9,0),span=wx.GBSpan(1,11),flag=wx.EXPAND)
#+end_src

     A button to force the image display to update is added and bound
     to the [[pelvis_on_update_button_link][OnUpdateButton]] function.

#+name:pelvis_frame_init
#+begin_src python  
  
          updateButton = wx.Button(self,-1,"Update")
          updateButton.Bind(wx.EVT_BUTTON,self.OnUpdateButton)
          sizer.Add(updateButton,flag=wx.EXPAND,pos=wx.GBPosition(8,10))
#+end_src

     All that remains is some final cleanup.  The data is set to an
     empty file, the background is set to empty, as the window
     undergoes stanard intialization.

#+name:pelvis_frame_init
#+begin_src python  
  
          self.data = self.makePel()
          self.flatrun = None#background data
          
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Show(True)
#+end_src

     


**** Handling Pel Files

     There's a large amount of references to Pel files in this
     section, which might be confusing, since you will almost never
     encounter an actual Pel file.  The PELVis program was originally
     written to view neutron data comes of off the PAPA detector.  The
     data off of the PAPA was saved in a binary format called the PAPA
     Electronic Log, or PEL for short.  

     The software which came with the detector was written in
     Labview 5.  [[http://ni.com/labview][Labview]] files are stored in a proprietary format
     which can only be read by Labview itself.  Modern versions of
     Labview are not backwards compatible enough to read Labview 5
     code.  Versions of Labview old enough to read the code are
     generally unavailable and difficult to install on modern
     operating systems.  Thus, while the vendor's supplied code could
     open the files, we could not extended it to perform the sorts of
     calulcations that we would like.  Thus, it was necessary to write
     a new program from scratch to read these files.  This is that
     application.

     Once we obtained the Helium-3 detector, we replaced the PAPA
     detector, as the PAPA had terrible noise issues.  However, PELVis
     had grown to the point where the reading of the data file was
     only a small part of the functionality.  By changing the [[reader]]
     code to handle the SNS file format (which was quite similar to
     the Pel format), we were able to continue using the same suite.

     The =makePel= function creates a blank neutron run.  It's just a
     default for when the user hasn't loaded any data yet.

#+name: pelvis_handle_pels
#+begin_src python
  def makePel(self):
      """Create a blank Pel object for loading detector data"""
      data = PelFile()
      def statusfunc(x):
          self.progress.SetValue(x)
          self.Yield()
      data.statusfunc = statusfunc
      return data
#+end_src

     The =loadPel= command reads in a neutron data file.  It takes as
     a single parameter a message to display to the user about what
     sort of file should be loaded.  There is also the ability to load
     a pre-histogrammed version of the neutron data, stored in the
     [[http://docs.numpy.org][numpy's]] native binary format.  In practice, this hasn't been that
     useful and may be dropped.  The numpy files do read far faster,
     but they also take up huge amounts of disk space compared to the
     event files, plus they need preprocessing from said event files
     to be created in the first place.

     This function also loads the monitor file that corresponds to the
     data set.

#+name: pelvis_handle_pels
#+begin_src python  
  def loadPel(self,message):
      """Load a .pel file and its monitor data.
      
      Keyword arguments:
      message -- The title for the load file dialog.
      
      """
      dlg=wx.FileDialog(self,message,wildcard="He3 data|*neutron_event.dat|Preformatted Histograms|*.npy",style=wx.FD_OPEN)
      if dlg.ShowModal()==wx.ID_OK:
      #            self.SetCursor(wx.CURSOR_WAIT)
          path = dlg.GetPath()
          if path[-3:] == "dat":
              data = self.makePel()
              data.readfileimage(path)
          elif path[-3:] == "npy":
              data = np.load(path)
      #            self.SetCursor(wx.CURSOR_ARROW)
      else:
          return (None,None)
      mon = MonFile(path[:-17]+"bmon_histo.dat")
      return (data,mon)
#+end_src

     The =loadNormPel= function loads a neutron data set and a set of
     counts from the beam monitor.  In the unlikely event that there
     is a [[flat run]], the flat is subtracted out of the data set.  The
     neutron data is then normalized to the monitor count.

#+name: pelvis_load_norm_pel
#+begin_src python

      def loadNormPel(self,message):
          """Load a .pel file, normalize it by monitor, and subtract background"""
          (data,mon) = self.loadPel(message)
          if isinstance(data,PelFile):
              data = np.asarray(data.make3d(),np.float32)
          if mon is None:
              return (data,1)
          if self.flatrun != None:
              flatrun = np.load(self.flatrun)
              self.flatrun.seek(0)
              flatrun *= mon.time
              data -= flatrun
          spec = mon.spec
          monsum = np.sum(spec)
          print("Integrated monitor counts: " + str(monsum))
          data /= monsum
          return (data,np.sum(mon.spec))
#+end_src

     The =loadUpAndDown= function is a helper function to load both
     spin states of a flipping measurement.

#+name:pelvis_load_up_and_down
#+begin_src python
      def loadUpAndDown(self):
          """Read in spin flip data"""
          u3d,uscale = self.loadNormPel("Spin Up State")
          if u3d is None:
              return False
          del self.data
          d3d,dscale = self.loadNormPel("Spin Down State")
          self.data = (u3d,d3d)
          self.scale = (uscale,dscale)
          return True
#+end_src



**** Menu Commands

     The Image Array command causes Pelvis to export the detector
     image, one wavelength bin at a time.  It can be useful to find
     effects which are sensitive to both position and wavelength, but
     it honestly hasn't seen much use.

     The =path= and =ext= variables are used to get the file name that
     the user chose and then sandwich the wavelength between them.

#+name: pelvis_on_image_array
#+begin_src python

      def OnImageArray(self,event):
          """Exports the 2d detector image by wavelength"""
          dlg = self.imageSaveDialog
          if dlg.ShowModal()==wx.ID_OK:
              path=dlg.GetPath()
              ext = path[-4:]
              path = path[:-4]
              (lmin,lmax) = self.opPanel.getLambdaRange()
              for i in range(lmin,lmax):
                  file=path+("%03i"%i)+ext
                  self.opPanel.setLambdaRange(0.1*i,0.1*(i+1))
                  self.updateData()
                  self.update()
                  self.imPanel.saveImage(file)
                  self.progress.SetValue(1000*(i-lmin)/(lmax-lmin))
                  self.Yield()
              self.opPanel.setLambdaRange(lmin*0.1,lmax*0.1)
              self.updateData()
              self.progress.SetValue(0)
#+end_src

     The =OnUpdateButton= isn't really a menu command, but is rather
     the calback for when the user clicks the update button.  All it
     does is call the current value of the =updateData= function.
     This function exists mostly because wxWidgets won't follow the
     dynamically changing definition for =updateData= and needs a
     static location for the callback.

<<pelvis_on_update_button_link>>
#+name: pelvis_on_update_button
#+begin_src python
      def OnUpdateButton(self,event):
          """Refresh the data when the user pushes the "Update" button"""
          #This function is needed for wxWidgets to allow
          #for dynamically changing the bound function
          self.updateData(event)
#+end_src

     The =OnOpen= function handles opening a single data set.
     [[*Handling%20Pel%20Files][loadNormPel]] does all of the actual file loading.  The =data= and
     =scale= values are set to the actual neutron data and monitor
     counts, respectively.  The =updateData= and =update= functions
     are also set to single data file mode.

#+name:pelvis_on_open
#+begin_src python
      def OnOpen(self,event):
          """Load a single .pel file for display"""
          data,scale = self.loadNormPel("Choose the Pel File to Open")
          if data is None:
              return
          self.data = data
          self.scale = scale
          self.progress.SetValue(0)
          self.specDlg.setMode("up")
          self.updateData = self.updateSingleData
          self.update = self.updateSingle
          self.updateData()
#+end_src

     Similarly to =OnOpen=, =OnOpenSet= loads two data files for
     examining a polarization measurement.  The actual file loading is
     handled by [[*Handling%20Pel%20Files][loadUpAndDown]].  Should the files load, the application
     switches to presenting polarization information.

#+name:pelvis_on_open_set
#+begin_src python
      def OnOpenSet(self,event):
          """Load a spin flip measurement for display"""
          if self.loadUpAndDown():
              self.OnPolar(event)
#+end_src

     Back when the PAPA detector first arrived, there was a light leak
     that caused an enormous noise signal across the detector.  The
     flat files were an attempt to eliminate that.  The flat files are
     essentiall a position sensitive calculation of the detector noise
     per unit time.  In practice, this functionality is almost never
     used and should probably be removed, as it may be out of date or
     inaccurate. 

     =OnFlat= starts by having the user load in a background run.
     This run is then flattened into a 3D positional map (the
     background is assumed to be wavelength independent).  This 2D map
     is normalized to the time of the measurement.

     The =OnFakeFlat= function tries to use the background to simulate
     having performed a flat measurement.  Honestly, this is probably
     better perofrmed by simple background subtraction and should be
     removed from the program.

#+name:pelvis_flat_files
#+begin_src python
      def OnFlat(self,event):
          """Load a blank run for background subtraction"""
          (data,mon) = self.loadPel("Choose a Blank Run")
          if data == None:
              return
          if isinstance(data,PelFile):
              flatrun = data.make3d()
          elif isinstance(data,np.ndarray):
              flatrun = data
          flatrun = np.sum(flatrun,axis=2)
          flatrun /= RESOLUTION
          flatrun /= float(mon.time)
          flatrun = np.expand_dims(flatrun,2)
          self.flatrun = TemporaryFile()
          np.save(self.flatrun,flatrun)
          self.flatrun.seek(0)
          self.progress.SetValue(0)
  
      def OnFakeFlat(self,event):
          """Create a fake background run from outside the region of interest."""
          (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
          totarea = 512*512
          centarea = (yMax-yMin)*(xMax-xMin)
          backgroundarea = totarea-centarea
          if type(self.data) is tuple:
              (u,d)=self.data
  
              totu = np.sum(u)
              totd = np.sum(d)
              centu = np.sum(u[yMin:yMax,xMin:xMax,:])
              centd = np.sum(d[yMin:yMax,xMin:xMax,:])
  
              backgroundu = totu-centu
              backgroundd = totd-centd
              backgroundrateu = backgroundu/backgroundarea
              backgroundrated = backgroundd/backgroundarea
              backgroundrateu /= (RESOLUTION + 1) #normalize against the wavelengths
              backgroundrated /= (RESOLUTION + 1) #normalize against the wavelengths
              ###Stupid Memory Errors
              del self.data
              u -= backgroundrateu
              d -= backgroundrated
              ###
              self.data=(u,d)
          else:
              d=self.data
              tot = np.sum(d)
              cent = np.sum(d[yMin:yMax,xMin:xMax,:])
              background = tot-cent
              backgroundrate = background/backgroundarea
              backgroundrate /= (RESOLUTION + 1) #normalize against the wavelengths
              self.data-=backgroundrate
          self.updateData()
#+end_src

     The =OnROD= command is really just the background subtraction
     function.  The =ROD= standards for "Region of Disinterest", which
     is a play on the phrase "Region of Interest".

     The code simply finds the average per pixel count rate in the current
     selected region of interest and subtracts it from all the pixel.
     Note that the background subtraction is performed per wavelength
     bin, so wavelength specific backgrounds are handled appropriately.

#+name:pelvis_menu_commands
#+begin_src python
  #Subtract out the region of disinterest
  def OnROD(self,event):
      """Take the region of interest as background noise"""
      (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
      area = (yMax-yMin)*(xMax-xMin)
      if type(self.data) is tuple:
          u,d=self.data
          del self.data
          totu = np.sum(np.sum(u[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          totd = np.sum(np.sum(d[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          totu /= area
          totd /= area
          u -= totu
          d -= totd
          self.data=(u,d)
      else:
          d=self.data
          totd = np.sum(np.sum(d[yMin:yMax,xMin:xMax,:],axis=0),axis=0)
          #totd = np.atleast_3d(totd)
          totd /= area
          #print(totd.shape)
          #print(self.data.shape)
          self.data -= totd
      self.updateData()
#+end_src

     The =OnExportROI= function creates a 2D binary map of all of the
     pixels where the intensity is less that the minimum intensity and
     saves the map to a file.  The map can either be a text file for
     readability or a binary file in numpy format for speed and
     compactness.  Not that =OnExportROI= does *not* change the
     current mask for the application. 

#+name:pelvis_menu_commands
#+begin_src python 
  
  def OnExportROI(self,event):
      """Save a file containing a map of where the current data
      image is greater than vmin"""
      vMin,_ = self.opPanel.getIntensityRange()
      mask = self.flatdata > vMin
      # (vMin,vMax) = self.opPanel.getIntensityRange()#
      # (xMin,xMax,yMin,yMax) = self.opPanel.getRoi()#
      # (lMin,lMax) = self.opPanel.getLambdaRange()#
      # (lMin,lMax) = (lMin/10,lMax/10)#
      # mask = [["xMin",xMin], ["xMax",xMax], ["yMin",yMin], ["yMax",yMax], \
      #         ["lMin",lMin], ["lMax",lMax], ["vMin",vMin], ["vMax",vMax]]#
      dlg = wx.FileDialog(self,
                          "Where to save the mask file?",
                          wildcard="Numpy dump (npy)|*.npy|Text (dat)|*.dat",
                          style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
      if dlg.ShowModal()==wx.ID_OK:
          path=dlg.GetPath()
          ext = path[-4:]
          if ext == ".dat":
              np.savetxt(path,mask,fmt="%d")
          else:
              np.save(path,mask)
#+end_src

     The =OnImportROI= sets the detector mask used for specifying the
     region of interest.  It can load either of the mask formats
     exported by =OnExportROI=.  A mask is loaded additively - if a
     pixel is masked in either the current mask or in the loaded mask
     file, it will be masked in the final mask.  Currently, the only
     way to remove a pixel from the mask is to restart the
     application.  Obviously, this is suboptimal and a simple
     =RemoveMask= function should be written to return to an unmasked
     state.

#+name:pelvis_menu_commands
#+begin_src python 
  
  def OnImportROI(self,event):
      """Adds another mask to the current system mask"""
      dlg = wx.FileDialog(self,
                          "Which Mask File?",
                          wildcard="Numpy dump (npy)|*.npy|Text (dat)|*.dat",
                          style=wx.FD_OPEN)
      time.sleep(.1)
      if dlg.ShowModal()==wx.ID_OK:
          path = dlg.GetPath()
          ext = path[-4:]
          if ext == ".dat":
              newmask = np.loadtxt(path,dtype=np.bool)
              newmask=dict(newmask)#
          else:
              newmask = np.load(path)
          self.mask = np.logical_and(self.mask,newmask)
          #self.opPanel.setPosMin(newmask["xMin"],newmask["yMin"])#
          #self.opPanel.setPosMax(newmask["xMax"],newmask["yMax"])#
          #self.opPanel.setLambdaRange(newmask["lMin"],newmask["lMax"])#
          #self.opPanel.setIntensityRange(newmask["vMin"],newmask["vMax"])#
          self.updateData()
  
#+end_src

     =OnSave= save the current detector image to a graphics file.  The
     actual image saving is handled by the [[ImagePanel]] class.

#+name:pelvis_menu_commands
#+begin_src python   
  
  def OnSave(self,event):
      """Save the current 2D image to a file"""
      print("OnSave")
  #        dlg=wx.FileDialog(self,"Choose graphics file",wildcard="Windows Bitmap (bmp)|*.BMP|Portable Network Graphic (png)|*.PNG|Joint Photographic Experts Group (jpg)|*.JPG|Portable Network Monocrome (pnm)|*.PNM|Tagged Image File Format (tif)|*.TIF|Archaic, useless format (pcx)|*.PCX",style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
      dlg = self.imageSaveDialog
      if dlg.ShowModal()==wx.ID_OK:
          self.imPanel.saveImage(dlg.GetPath())
#+end_src

     The =OnSpectrum= function formats the data into a 1D format for
     use by the [[SpectrumDialog]] in actually giving the spectral
     information.  The data is masked by both the mask generated by
     =OnImportROI= and by the user's chosen region of interest.  The
     total counts per wavelength bin are then sent to the
     SpectrumDialog, along with the scale from the monitor count. 

     The user's chosen intensity range display is also sent to the
     spectrum dialog.  This is helpful in getting proper bounds for
     graphing the polarization and flipping ratio, since dividing by
     small numbers can give strange boundary ranges.  Unfortunately,
     this is NOT useful with raw intensity rates, since the intensity
     range per pixel on the detector doesn't necessarily correspond to
     what we're interested in with  the intensity per wavelength bin.

#+name:pelvis_menu_commands
#+begin_src python   
  
  def OnSpectrum(self,event):
      """Display a plot of the region of interest versus wavelength"""
      print("OnSpectrum")
      (xMin,xMax,yMin,yMax)=self.opPanel.getRoi()
      if type(self.data) is tuple:
          u3d,d3d = self.data
          u3d = u3d[:,:,:]
          d3d = d3d[:,:,:]
          u3d[np.logical_not(self.mask)] = 0
          d3d[np.logical_not(self.mask)] = 0
          u = np.sum(np.sum(u3d[yMin:yMax,xMin:xMax],0),0)
          d = np.sum(np.sum(d3d[yMin:yMax,xMin:xMax],0),0)
          uscale,dscale = self.scale
          self.specDlg.setScale(uscale,dscale)            
          self.specDlg.setData(u,d)
      else:
          copy = self.data[:,:,:]
          copy[np.logical_not(self.mask)] = 0
          u = np.sum(np.sum(copy[yMin:yMax,xMin:xMax],0),0)
          #            u *= self.scale
          self.specDlg.setScale(self.scale)
          self.specDlg.setData(u)
      self.specDlg.setIntensityRange(self.opPanel.getIntensityRange())
      self.specDlg.Show()
#+end_src
     
     There are a couple of menu functions for setting the color scheme
     of the detector image.  =OnGrey= gives a greyscale image, as one
     would expect.  =OnHueVal= gives an image where the intensity if
     encoded into the Hue, with the saturation and Value both pegged
     at the maximum.  Finally, =OnSpectral= is the default, with a
     color scheme that starts at zero and passes through the range of
     hues before arriving at white.

     If the user wants a different color map, they can use the
     [[ColorMapPicker]] to chose from any of the installed color maps.
     PELVis currently does not support creating custom color spectra.

#+name:pelvis_menu_commands
#+begin_src python   
    
  def OnGrey(self,event):
      """Set the colormap to gray"""
      self.imPanel.cmap = cm.gray
      self.colorbar.setCmap(cm.gray)
      self.update()
  
  def OnHueVal(self,event):
      """Set the colormap to a rainbow"""
      self.imPanel.cmap = cm.jet
      self.colorbar.setCmap(cm.jet)
      self.update()
  
  def OnSpectral(self,event):
      """Set the colormap to the spectral map"""
      self.imPanel.cmap = cm.spectral
      self.colorbar.setCmap(cm.spectral)
      self.update()
  
  def OnPicker(self,event):
      """Let the user pick a color map from a list"""
      if self.cmp is None:
          self.cmp = ColorMapPicker(self,self.setColorMap)
      self.cmp.Show()
  
#+end_src

     The =OnExit= function is run when the user closes the program
     from the menu.  It's not that interesting.
     
#+name:pelvis_on_exit
#+begin_src python
    
  def OnExit(self,event):
        """Quit the program"""
        self.Close()
#+end_src

     There are four functions to set the current data interpretation
     mode for the application.  Each one sets the =update= and
     =updateData= functions to the [[*Updaters][proper function]] to handle the data
     type, then sets the mode of the spectrum dialog.

     It currently looks like the update function is always set to
     updateSingle.  If this is the case, then the code can be
     simplified.  This is worth investigation.

#+name:pelvis_menu_commands_2
#+begin_src python
  def OnPolar(self,event):
      """Display neutron polarization"""
      print("OnPolar")
      self.specDlg.setMode("polar")
      self.updateData = self.updateDataPolar
      self.update = self.updateSingle
      self.updateData()
    
  def OnFlipping(self,event):
      """Display the flipping ratio"""
      print("OnFlip")
      self.specDlg.setMode("flipping")
      self.updateData = self.updateDataFlip
      self.update = self.updateSingle
      self.updateData()
    
  def OnAnalysisSpinUp(self,event):
      """Display the Spin Up data"""
      print("OnSpinUp")
      self.specDlg.setMode("up")
      self.updateData = self.updateDataUp
      self.update = self.updateSingle
      self.updateData()
    
  def OnAnalysisSpinDown(self,event):
      """Display the Spin Down data"""
      print("OnSpinDown")
      self.specDlg.setMode("down")
      self.updateData = self.updateDataDown
      self.update = self.updateSingle
      self.updateData()
#+end_src

     =OnCopy= is called when a user selects the Copy command from the
     Edit menu.  This copies the current detector image to the
     clipboard, though everything is really handled by the [[ImagePanel]] class.

#+name:pelvis_menu_commands_2
#+begin_src python   
      
  def OnCopy(self,event):
      """Copy the image to a clipboard"""
      self.imPanel.copyToClipboard()
#+end_src


     

**** Updaters

     There are two updates which need to be performed.  The first is
     updating the data, which involves taking the 3D arrays of neutron
     data and turning them into a single, 2D map.  The second is using
     that 2D data to update the other parts of the application.  All
     of the function with data in the name handle converting the 3D
     data into the 2D map, while the remaining functions pass the 2D
     data to the rest of the application.

     =updateSingleData= is used when only a single file is loaded.  As
     the only thing we can do is give intensity per pixel, a simple
     sum is performed along the wavelength axis.

#+name: pelvis_updaters
#+begin_src python
      def updateSingleData(self,event=None):
          """Update changes in wavelength on a single file"""
          print("Make 2d")
          (lmin,lmax) = self.opPanel.getLambdaRange()
          self.flatdata = np.sum(self.data[:,:,lmin:lmax],2)
          self.update()
#+end_src

     =updateDataFlip= and =updateDataPolar= require both an up and
     down state from a polarization measurement.  They then calculate
     the per pixel neutron flipping ratio and polarization,
     respectively.  a value of 10^{-9} is added to the denominator to
     prevent divide by zero errors.

#+name:pelvis_updaters
#+begin_src python
  
      def updateDataFlip(self,event=None):
          """Update changes in wavelength for flipping ratios"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,d3d)=self.data
          u = np.sum(u3d[:,:,lmin:lmax],2)
          d = np.sum(d3d[:,:,lmin:lmax],2)
          self.flatdata = u/(d+1e-6)
          self.update()
  
      def updateDataPolar(self,event=None):
          """Update changes in wavelength for polarizations"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,d3d)=self.data
          u = np.sum(u3d[:,:,lmin:lmax],2)
          d = np.sum(d3d[:,:,lmin:lmax],2)
          self.flatdata = (u-d)/(u+d+1e-6)
          self.update()
#+end_src

     The =updateDataUp= and =updateDataDown= commands display the
     neutron intensity per pixel in a single spin state.  They are
     largely identical to =updateSingleData=, except for the line
     which selects the spin state.

#+name:pelvis_updaters
#+begin_src python

      def updateDataUp(self,event=None):
          """Update changes in wavelength for the spin up state"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (u3d,_)=self.data
          self.flatdata = np.sum(u3d[:,:,lmin:lmax],2)
          self.update()
  
      def updateDataDown(self,event=None):
          """Update changes in wavelength for the spin down state"""
          (lmin,lmax) = self.opPanel.getLambdaRange()
          (_,d3d)=self.data
          self.flatdata = np.sum(d3d[:,:,lmin:lmax],2)
          self.update()
#+end_src

     The =updateSingle= function takes the current 2D data, performs
     the appropriate masking, and updates the data in the [[GraphPanel][GraphPanels]].
     It also updates the range on the color bar and forces the
     [[ImagePanel][detector image]] to update.

#+name:pelvis_updaters
#+begin_src python
  
      def updateSingle(self,event=None):
          """Update the 2D data for the region of interest and intensity"""
          (vMin,vMax) = self.opPanel.getIntensityRange()
          (xMin,xMax,yMin,yMax) = self.opPanel.getRoi()
          data = self.flatdata[:,:]
  
          #Mask to zero during the summing parts
          data[np.logical_not(self.mask)] = 0
          self.posPanel.data = data
          self.posPanel.setRange(xMin,yMin,xMax,yMax)
          x=np.arange(128,0,-1)
          y=np.sum(data[:,xMin:xMax],axis=1)
          self.yPanel.SetPlot(x,y)
          #handle the x-plot
          x=np.arange(0,16,1)
          y=np.sum(data[yMin:yMax,:],axis=0)
          self.xPanel.SetPlot(x,y)
          if vMin is None:
              vMin = np.min(data)
          if vMax is None:
              vMax = np.max(data)
          self.colorbar.setRange(vMin,vMax)
          self.colorbar.update()
          #mask to vmin for the plotting
          data[np.logical_not(self.mask)] = vMin
          self.imPanel.update(self.flatdata,vMin,vMax)

#+end_src


*** Position Panel

    This is a class to provide a small panel which provides
    information about single pixels of detector data via the cursor
    position.  It also provides aggregate information over the region
    of interest.

**** Position Panel Class Skeleton

#+Name:position_panel
#+begin_src python :noweb tangle
  class PositionPanel(wx.Panel):
      """A panel with pixel information
  
      The intent of this panel is to provide information about
      single pixels of detector data via cursor position.  It
      also provides aggregate information over the region of
      interest.
  
      """

      def __init__(self,parent):
          """Create a PositionPanel"""
          <<position_panel_init>>
      <<position_panel_updating>>
#+end_src

**** Initialization of the PositionPanel

     Creating a new PositionPanel requires only a single parameter:
     the parent frame which will hold the panel.  The constructor
     begins by creating the text controls that display the X and Y
     position of the cursor, as well as the value under the cursor (Z)
     and the integrated value over the region of interest (ROI).

#+name: position_panel_init
#+begin_src python
          wx.Panel.__init__(self,parent)
          sizer=wx.GridBagSizer(3,2)
          sizer.Add(wx.StaticText(self,-1,"X:"),pos=wx.GBPosition(0,0))
          self.x = wx.TextCtrl(self,-1,"")   
          sizer.Add(self.x,pos=wx.GBPosition(0,1))
          sizer.Add(wx.StaticText(self,-1,"Y:"),pos=wx.GBPosition(1,0))
          self.y = wx.TextCtrl(self,-1,"")
          sizer.Add(self.y,pos=wx.GBPosition(1,1))
          sizer.Add(wx.StaticText(self,-1,"Z:"),pos=wx.GBPosition(2,0))
          self.intensity = wx.TextCtrl(self,-1,"")
          sizer.Add(self.intensity,pos=wx.GBPosition(2,1))
          self.integrate = wx.TextCtrl(self,-1,"")
          sizer.Add(wx.StaticText(self,-1,"ROI:"),pos=wx.GBPosition(3,0))
          sizer.Add(self.integrate,pos=wx.GBPosition(3,1))

#+end_src
  
     We give a default region of interest that covers the entire detector.

#+name: position_panel_init
#+begin_src python
          #Set the starting region of interest
          self.minX = 0
          self.minY = 0
          self.maxX = 16
          self.maxY = 128

#+end_src

     The text controls are for display purposes only, so we'll ensure
     that they aren't editable.

#+name: position_panel_init
#+begin_src python  
          self.x.SetEditable(False)
          self.y.SetEditable(False)
          self.intensity.SetEditable(False)
#+end_src

     The class member =self.data= is a pointer to the actual data
     being examined.  We'll initialize it to =None= to begin with.

#+name: position_panel_init
#+begin_src python
          self.data = None #A 2D numpy array of the data being examined.

#+end_src

Finally, we need to do the standard GUI layout code.

#+name: position_panel_init
#+begin_src python
          self.SetAutoLayout(True)
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Layout()
#+end_src

**** Update position data

     As implied by the name, the primary function of the position
     panel is to provide the direct numbers for the value under the
     user's cursor.  To do that, it must know where the mouse is.  The
     =set= function takes the x and y position of the cursor and
     updates the panel accordingly.

#+Name:position_panel_updating
#+begin_src python
      def set(self,x,y):
          """Updates the position being examined"""
          self.x.SetValue(str(x))
          self.y.SetValue(str(y))
          if self.data is None:
              return
          self.intensity.SetValue(str(self.data[y,x]))
#+end_src

     Obviously, this is of no use if the panel doesn't know the
     detector values.  The =setData= function provides a 2D array of
     values for the Panel to report on.

#+Name:position_panel_updating
#+begin_src python
      def setData(self,data):
          """Updates the data being examined"""
          self.data=data
#+end_src

     The remaining functions deal with the region of interest
     integration.  The =setRange= function controls the region of
     interest while the =updateIntegration= function handles
     calculating 

#+Name:position_panel_updating
#+begin_src python
      def setRange(self,minX,minY,maxX,maxY):
          """Updates the region of interest for integration"""
          self.minX = minX
          self.minY = minY
          self.maxX = maxX
          self.maxY = maxY
          self.updateIntegration()
      def updateIntegration(self):
          """Calculates the sum of the data over the region of interest"""
          self.integrate.SetValue(
              str(np.sum(self.data[self.minY:self.maxY,self.minX:self.maxX])))
#+end_src


*** Option Panel

    The class PelvisOptionPanel creates a panel of labeled text boxes
    for user entry.  This is used to control values such as the
    wavelength range, region of interest, and intensity values.

    As an experiment in software architecture, the class generates the
    layout of the panel from a list of configurations.  Each list item
    is a tuple of four values

    | Position | 0           |                      1 | 2                    | 3             |
    | Value    | Name        | Relative list position | Label                | Default Value |
    | Type     | string      |                    int | string               | string        |
    | Example  | "lambdaMax" |                     30 | "Maximum Wavelength" | "19.7"        |

    The panel generates a set of text controls with the given labels
    and default values.  The text controls are arranged from top to
    bottom by the order of the relative list position from smallest to
    largest.

    The advantage to this setup is that adding new options onto the
    panel is trivial.  Putting a new item into the list adds a new
    option onto the panel.  The disadvantage is that the data is a
    little more cumbersome to access as the values are not members of
    the class.  This could be fixed with Python accessors and
    properties, but I have not done so yet.  As this design decision
    was made to ease life for future maintainers and, seeing as you're
    reading this, you are the future maintainer, feel free to return
    to hard coded values if you find it easier to handle.
    
#+name:pelvis_option_panel
#+begin_src python :noweb tangle
  class PelvisOptionPanel(wx.Panel):
      """A panel for user parameters
  
      The panel gets it's parameters and appearance from the built in
      DEFAULTS variable.  This was designed to allow the easy addition
      of more parameters in the future.
  
      """
      #Each parameter is a tuple
      #0 - variable name
      #1 - position in list
      #2 - label
      #3 - default value
      DEFAULTS = [("lambdaMax",0,"Maximum Wavelength","20"),
                  ("lambdaMin",10,"Minimum Wavelength","0"),
                  ("intMax",20,"Maximum Intensity",""),
                  ("intMin",30,"Minimum Intensity",""),
                  ("xMin",40,"Minimun X","0"),
                  ("xMax",50,"Maximum X","16"),
                  ("yMin",60,"Minimun Y","0"),
                  ("yMax",70,"Maximum Y","128")]
  
      def __init__(self,parent):
          """Creates a PelvisOptionPanel"""
          <<pelvis_option_panel_init>>
  
      <<pelvis_option_panel_wavelength>>
  
      <<pelvis_option_panel_intensity>>
  
      <<pelvis_option_panel_roi>>
  
  
#+end_src

**** Initialization

     We begin by initializing the superclass and creating a sizer for
     the panel
#+name:pelvis_option_panel_init
#+begin_src python
          wx.Panel.__init__(self,parent)
          sizer=wx.BoxSizer(wx.VERTICAL)
#+end_src   

     We then create the text controls.  The controls are held in the
     local dictionary =options=, which will need to be used every time
     we want to access one of the values.
#+name:pelvis_option_panel_init
#+begin_src python
          self.options={}#member which holds the created text controls
  
          self.DEFAULTS.sort(lambda x,y: x[1]-y[1])
          for option in self.DEFAULTS:
              (key,_,title,val) = option
              sizer.Add(wx.StaticText(self,-1,title))
              self.options[key] = wx.TextCtrl(self,-1,val)
              sizer.Add(self.options[key])
#+end_src

     Finally, we perform the standard cleanup for a wxPanel
  
#+name:pelvis_option_panel_init
#+begin_src python
          self.SetAutoLayout(True)
          self.specDlg = SpectrumDialog(self)
          sizer.SetSizeHints(self)
          self.SetSizer(sizer)
          self.Layout()
#+end_src

**** Wavelength Range

     When a set of parameters is added, it's useful to put in a
     standard getter and setter.  The setters are fairly standard, but
     the getter can be a little tricky, since the user might add a
     non-standard value.  It's good to provide default values if the
     user's input cannot be parsed.

     Note that the code below is *wrong*.  It holds true while
     the RESOLUTION is 200, which is the default case, but the
     multiplication by ten should be replaced with a value dependent
     on the current resolution.

#+Name:pelvis_option_panel_wavelength
#+begin_src python

      def getLambdaRange(self):
          """Gives a tuple with the minimum and maximum wavelength indices"""
          try:
              lmin = int(float(self.options["lambdaMin"].GetValue())*10)
          except ValueError:
              lmin = 0
          try:
              lmax = int(float(self.options["lambdaMax"].GetValue())*10)
          except ValueError:
              lmax = RESOLUTION
          return (lmin,lmax)
  
      def setLambdaRange(self,min,max):
          """Set the minimum and maximum wavelengths"""
          self.options["lambdaMin"].SetValue(str(min))
          self.options["lambdaMax"].SetValue(str(max))
#+end_src

**** Intensity Range

     We create similar getters and setters for the minimum and maximum
     intensity.  The values create bounds for both the 2D color plot
     and the spectrum display.  They're also used as part of the mask
     making routines.

#+name:pelvis_option_panel_intensity
#+begin_src python
      def getIntensityRange(self):
          """Return a tuple with the floor and ceilling for intensity
  
          If a value isn't specified, or is not a number, None is returned
          for that part of the range.
  
          """
          try:
              vMin = float(self.options["intMin"].GetValue())
          except ValueError:
              vMin = None
          try:
              vMax = float(self.options["intMax"].GetValue())
          except ValueError:
              vMax = None
          return (vMin,vMax)
  
      def setIntensityRange(self,min,max):
          self.options["intMin"].SetValue(str(min))
          self.options["intMax"].SetValue(str(max))
          self.specDlg.setIntensityRange((min,max))

#+end_src

**** Region of Interest

     Finally, we need getters and setters for our region of interest.
     The getter works pretty much the same as the others, but the
     setter has been split into two functions: one for the upper left
     corner and another for the lower right.  This allows us to set
     the region of interest with two mouse clicks.

#+name:pelvis_option_panel_roi
#+begin_src python
      def getRoi(self):
          """Returns a 4-tuple with the region of interest
  
          Returns (xmin,xmax,ymin,ymax).  Minimum values, if
          unspecified, are set to zero.  Maximum values, if
          unspecified, are set to 512.
  
          """
          try:
              xMin = int(self.options["xMin"].GetValue())
          except ValueError:
              xMin = 0
          try:
              xMax = int(self.options["xMax"].GetValue())
          except ValueError:
              xMax = 512
          try:
              yMin = int(self.options["yMin"].GetValue())
          except ValueError:
              yMin = 0
          try:
              yMax = int(self.options["yMax"].GetValue())
          except ValueError:
              yMax = 512
          return (xMin,xMax,yMin,yMax)
  
      def setPosMin(self,x,y):
          """Takes the x and y coordinates for the NW corner of the ROI."""
          self.options["xMin"].SetValue(str(x))
          self.options["yMin"].SetValue(str(y))
  
      def setPosMax(self,x,y):
          """Takes the x and y coordinates for the SE corner of the ROI."""
          self.options["xMax"].SetValue(str(x))
          self.options["yMax"].SetValue(str(y))
#+end_src

#  LocalWords:  wxWidget


*** GraphPanel
* Utility Classes

  This section is for libraries which are used by more than one part
  of the system.  These are usually the modules which read and write
  data files, as they are needed by both the GUI and command line applications.
** Reader

   The =reader= module handles reading and interpreting neutron event
   files.  It's main purpose is to take a data file, which is a binary
   record of events, and turn it into a histogram of events in space
   and time.

*** Reader Skeleton

#+begin_src python :tangle reader.py :noweb tangle :padline no
"""This module contains classes for reading PEL files

This module contains a single class: PelFile.  This class reads the header
information and neutron data saved in PEL files.  more information about
the format of these files can be found in the Lexitech PAPA Software Manual.

"""

import __future__

import struct
#import re
import numpy as np

from time import clock
from collections import namedtuple

RESOLUTION = 400

<<reader_mapim>>

class PelFile:
        """Handles the data stored in PEL files"""
        data = np.ndarray(shape=(0),dtype=np.int64)#Raw detector data

        <<reader_pelfile_init>>                

        <<reader_pelfile_parseHeader>>
        <<reader_pelfile_convertTime>>
        <<reader_pelvis_make3d>>
        
        def spectrum(self,output):
                """Save the neutron spectrum to a text file"""
                with open(output,'w') as of:
                        timearr = (self.data >> 32) & 0x7FFFFFFF
                        timearr = self.convertTime(timearr)
                        timearr /= 10

                        #Get the spectrum and wavelengths
                        (spec,lmbda) = np.histogram(timearr,bins = \
                                                    np.arange(2.0,50.0,0.1))
                        hist = np.column_stack((lmbda[1:],spec))
                        for point in hist:
                                of.write("%f %i\n" % (point[0],point[1]))
                        of.close()
                        return (spec,lmbda)
                

        def statusfunc(self,x):
                """Status update function

                This function is called to tell other program components
                the progress in loading the PelFile.  The progress is given
                on a scale of 0 to 1000.  This function should be overwritten
                by whatever function is loading the pel file to do what it
                needs with the load time information.

                """
                return

        def getgains(self,h):
                """Pulls the PMT gains information into a numpy array"""
                return np.array([h.x1Gain,h.x2Gain,h.x3Gain,h.x4Gain,h.x5Gain,h.x6Gain,h.x7Gain,h.x8Gain,h.x9Gain,h.x10Gain,
                        h.y1Gain,h.y2Gain,h.y3Gain,h.y4Gain,h.y5Gain,h.y6Gain,h.y7Gain,h.y8Gain,h.y9Gain,h.y10Gain],np.double)

        def readfileimage(self,path):
                """Reads a raw Pel File into memory."""
                start=clock()
                statusfunc = self.statusfunc
                with open(path,"rb") as infile:
                    #self.header = self.parseHeader(infile.read(256))
                    #Raw File has no header
                    #point = infile.read(8)
                    self.data = np.fromfile(infile,np.int32,-1)
                infile.close()
                stop=clock()

        def make1d(self,mins,maxs,mask=None):
                """Make a 1D histogram from the spectrum data."""

                c = self.make3d()
                if mask is None:
                    xmin,ymin = mins
                    xmax,ymax = maxs
                    c = c[ymin:ymax,xmin:xmax]
                else:
                    c[np.logical_not(mask)] = 0
                return np.sum(np.sum(c,axis=0,dtype=np.float64()),axis=0)
                

if __name__=="__main__":
        data = PelFile()
        
        data.readfileimage("C:/Documents and Settings/adlwashi/Desktop/20091102101415-AM12.pel")
        print("Read File")
        data.spectrum("spectrum.txt")
        #print("Reverse Grey")
        #data.reverseGrey()
        #temp = set([data.fullGrayCode(i) for i in range(512)])
        #for i in temp:
        #        print "%03o" % i
        #print(len(temp))

#+end_src


*** Image Mapping

    The TOF for each event is given as a count since the T_0 pulse,
    where the each count is 100ns.  The convertTime function takes a
    numpy array of counts and turns it into a wavelength into a
    wavelength bin, where the bins are spaced by =20/RESOLUTION=.  For
    instance, if RESOLUTION is 200 and the neutron has a 2 Angstrom
    wavelength, then the bin is 20.

    The relationship between TOF and wavelength is controlled almost
    completely by the variables =distanceToG4= and
    =distanceToDetector=.  This sum should be the distance, in meters,
    from the neutron moderator to the Helium-3 detector.  The
    =distanceToG4= variable is based on Jak doskow's drawings on how
    far it should be from the neutron moderator to the exit of G4.
    The actual distance to the detector can then be measured with a
    tape measure.

    According to Dave Baxter's measurements, there is an 860us delay
    between the T0 signal and when the neutrons first start coming out
    of the moderator.  This value is subtracted off of the times to
    compensate.  This value should be checked occasionally to make
    sure that it has not changed.  If you are seeing neutrons with
    negative wavelengths, or if the proton pulse is not occuring at
    zero angstroms, then this value needs to be changed.  The best way
    of checking it is via the neutron monitor, as the proton flash is
    quite visible in the output and the results are given in 50
    microsecond bins.

<<convertTime>>
#+name:reader_pelfile_convertTime
#+begin_src python
        #Remember to use in-place operations to save on memory overhead
        def convertTime(self,timearr):
                """Convert an array of TOF data into neutron wavelengths."""
                #convert timearr into microseconds
                timearr *= 0.1 #Convert to microseconds
                #convert timearr into wavelength
                distanceToG4 = 3.7338+2.5297
                distanceToDetector = 3.835 #FIXME
                timearr -= 860
                timearr *= 3.956034e-7/(distanceToDetector+distanceToG4)/1e-10*1e-6*(RESOLUTION/20) #The last term is to handle fractional angstroms
                return timearr
#+end_src


     The SNS software for the Helium-3 detector returns a set of
     events.  Each even has a channel number, the distance along the
     channel, and a time of flight.  However, each channel on our
     detector has two tubes in series.  Thus, we need to convert the
     position on the channel to the position on the tube and assign
     the data to the right tube.

     Paul wrote this code and it has some idiosyncratic behavior.  For
     example, the test of 
: 0.5*ti!=int(0.5*ti)
     is really just a test to see if ti is odd or even.  It should
     probably be replaced with a simple
: ti%2==1
     which returns the same result for all values.  In fact, I have a
     sneaking suspicion that the entire thing can be done through
     numpy, eliminating the need for slow python loops, but I haven't
     proved it yet.

     The function takes a single input value, which is a 2D array of
     neutron counts with dimensions =XDIM= x =YDIM=.  It returns an array
     with dimensions =XDIMM= and =YDIMM=.  The =ZPAD= variable is used
     to account for dead pixels at the top or bottom of the tubes.
     The =maparray= variable gives the order of the tubes on the
     detector.  This has been found by calibration, but it should be
     checked periodically (e.g. biennially) to ensure that it's still accurate.

<<mapim>>
#+name:reader_mapim
#+begin_src python
def mapim(imarray):
    XDIM=8
    YDIM=256
    XDIMIM=16
    YDIMIM=128
    ZPAD=0
#    maparray=[2, 15, 1, 16, 4, 13, 3, 14, 6, 11, 5, 12, 8, 9, 7, 10]
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]#Old July 2013
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 14, 10, 13, 12, 9, 11, 16, 15]# SESANS October 2013
#    maparray =[2, 1, 4, 3, 6, 5, 8, 7, 14, 10, 13, 12, 9, 11, 16, 15]# SESANS July 2013
    maparray =[4, 3, 1, 2, 6, 5, 15, 16, 8, 13, 7, 14, 10, 11, 9, 12] # From tube mapping October 2013
    #    maparray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
#    maparray = [12, 9, 11, 14, 10, 7, 1, 2, 3, 4, 5, 6, 8, 13, 15, 16]
#    maparray =[2, 1, 4, 3, 6, 15, 5, 16, 8, 7, 13, 14, 11, 12, 9, 10]
#    maparray =[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    newimarray=np.zeros((YDIMIM+ZPAD,XDIMIM))
    for i in range(len(maparray)):
        ti=maparray[i]
        if 0.5*ti!=int(0.5*ti):
           for j in range(YDIMIM):
                tj=j
                if ti<9:
                    newimarray[j+ZPAD,i]=imarray[YDIMIM-1-tj,(ti-1)/2]
                else:
                    newimarray[j,i]=imarray[YDIMIM-1-tj,(ti-1)/2]
        else:
            for j in range(YDIMIM):
                tj=j+YDIMIM
                if ti<9:
                    newimarray[j+ZPAD,i]=imarray[tj,ti/2-1]
                else:
                    newimarray[j,i]=imarray[tj,ti/2-1]
    return newimarray
#+end_src


     The make3D function is the primary function for turning an array
     of neutron events into a histogram of events versus position and
     wavelength.

     The data type is 64 bits per event.  The first 32 bits are the
     TOF information, which can be turned into a wavelength by the
     [[convertTime]] function.  The next 32 bits are the position
     information.

     We begin by setting some default variables.  The =statusfunc= is
     a function that can be called with the current progress on
     loading the file.  It expects a value between 0 and 1000, where 0
     is having just started and 1000 means that the process is
     complete.  The =cube= variable is the actual 3D array of neutron
     events.  If there is no data in the file, we can immediately
     return an empty array.
     
#+name:reader_pelvis_make3d
#+begin_src python
  def make3d(self):
          """Make a 3D histogram from the raw data."""
          start=clock()                
          statusfunc = self.statusfunc
          l = len(self.data)
          sd =self.data
          i=0;
  
          cube = np.zeros([128,16,RESOLUTION],dtype=np.float32)
  
          #If there's no data, return an empty array
          if l==0:
                  return cube
#+end_src

     The 64-bit events are broken down into the 32-bit array of
     position information, =Z=, and the 32-bit array of the time
     information, =timearr=.  The time information is then converted
     into a wavelength bin.

#+name:reader_pelvis_make3d
#+begin_src python
  #
          Z = self.data[1::2] & 0xFFFF#position data
  
          timearr = self.convertTime(np.asarray(self.data[0::2], \
                                                dtype=np.float64))#time data
          timearr = np.asarray(np.floor(timearr),np.uint16)
#+end_src

     a lot of this code used to purely work with integers.  As such,
     numpy was set to [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html][raise an exception on integer overflow]].  This is
     largely unnecessary now and could probably be removed.

#+name:reader_pelvis_make3d
#+begin_src python          
  #
          #Loop over 20 angstroms in steps of 0.1 angstroms
          np.seterr(over='raise')
  #+end_src

     It's possible to run the entire histogram calculation in a single
     numpy call, which would actually be faster than the code below.
     The problem is that the entire application would hang while the
     calculation was performed, which leaves you wondering if
     everything just crashed.  This slower version was implemented,
     since it was easier to put in feedback as to how much time would
     be left.

     The function cycles through each time of flight bin.  The =place=
     variable stores the indexes of events which fall into this time
     of flight bin.  If there are any such events, then their position
     information is histogrammed into a 1D array.  This array can then
     be converted into a 2D array, since we know the number of
     channels and the number of points per channel.  Finally, the
     [[mapim]] function takes the point and channel numbers and returns a
     2D array of position information.  Finally, this array is copied
     into the appropriate wavelength bin in the =cube= array.

#+name:reader_pelvis_make3d
#+begin_src python
  #
          for i in range(RESOLUTION):
                  place = np.where(timearr==i)
                  if len(place[0]) > 0:
                          temp,_ = np.histogram(Z[place],bins = \
                                                np.arange(8*256+1))
                          temp = temp.reshape(256,8,order="F")
                          cube[:,:,i] = mapim(temp)[::-1,:]
                  statusfunc(i*1000.0/RESOLUTION)
                          
  
          stop=clock()
          del timearr
  
          return cube
  
#+end_src


*** Initialization

    The constructor for the PelFile doesn't need to do much other than
    load a file passed as a parameter.  If there is no file, we don't
    want to do anything.
    
#+name: reader_pelfile_init
#+begin_src python

        def __init__(self,file=""):
                """Create a PelFile"""
                if(file!=""):
                        self.readfileimage(file)

#+end_src

*** File Reading

    The original PEL file format used by the PAPA detector included a
    256 byte header with metadate about the detector status during the
    run.  This function would parse that information into a Python
    [[https://docs.python.org/2/library/collections.html][namedTuple]], which is fairly similar to a standard struct.  With
    the new Helium-3 detector, this code is no longer necessary or
    useful.  It should not be called and could probably be deleted.

#+name:reader_pelfile_parseHeader
#+begin_src python
  
  def parseHeader(self,bytes):
          """Turn the Pel file header into structured data"""
          Header = namedtuple(
                  'Header',
                  "pel endian FileMajVer FileMinVer BytesPerSample " +
                  "SysHealth AppMajVer AppMinVer AppBetaVer LensPos " +
                  "DetectorName ProductNumber BitsPerCoord CanEnergy " +
                  "CanTime ADclockFrequ FirmMajVer FirmMinVer FirmBeta Serial " +
                  "AcquisitionMode CanAcqMode Shutter " +
                  "PAPAPowerSupplyVoltageCommand " +
                  "PAPAPowerSupplyVoltageCommandGain " +
                  "PAPAPowerSupplyVoltageCommandOffset " +
                  "PAPAPowerSupplyControlVoltageCommandGain " +
                  "PAPAPowerSupplyControlVoltageCommandOffset " +
                  "PAPAPowerSupplyVoltageEnable " +
                  "EnergyPowerSupplyVoltageCommand " +
                  "EnergyPowerSupplyVoltageCommandGain " +
                  "EnergyPowerSupplyVoltageCommandOffset " +
                  "EnergyPowerSupplyControlVoltageCommandGain " +
                  "EnergyPowerSupplyControlVoltageCommandOffset " +
                  "EnergyPowerSupplyVoltageEnable " +
                  "MCPPowerSupplyVoltageCommand " +
                  "MCPPowerSupplyVoltageCommandGain " +
                  "MCPPowerSupplyVoltageCommandOffset " +
                  "MCPPowerSupplyControlVoltageCommandGain " +
                  "MCPPowerSupplyControlVoltageCommandOffset " +
                  "MCPPowerSupplyVoltageEnable " +
                  "x1Gain x2Gain x3Gain x4Gain x5Gain x6Gain x7Gain x8Gain x9Gain x10Gain " +
                  "y1Gain y2Gain y3Gain y4Gain y5Gain y6Gain y7Gain y8Gain y9Gain y10Gain " +
                  "strobeGain EnergyGain ThresholdGain "+
                  "ADVoltageOffset ADAOffset ADBOffset ADCOffset ADDOffset "+
                  "StrobeTriggerMin StrobeTriggerMax StrobeEndEventFrac " +
                  "EnergyTriggerMin EnergyTriggerMax EnergyEndEventFrac " +
                  "ADAFillSampleIntervalLength ADDFillSampleIntervalLength " +
                  "GateCapturePolarity TimerResetEdgePolarity " +
                  "LeadTimer LagTimer Gray BitShift " +
                  "TemperatureSetPoint1 TemperatureSetPoint2 " +
                  "KP1 KP2 KI1 KI2 KD1 KD2 Temperature1 Temperature2 " +
                  "StrobePulseWidth " +
                  "Year Month Day Hour Minute Second")
  
  
          format = "4s" #header
          format += " ?" #endian  Note that this is currently ignored
          (pelstring,endian) = struct.unpack(format,bytes[0:5])
  
          if endian:
                  format = ">" #big endian
          else:
                  format = "<" #little endian
          format += "4s ?" #header and endian
          format += "B" #Major version
          format += "B" #Minor Version
          format += "B" #Bytes per sample
          format += "B" #System Health
          format += "B" #Application Software Major Version
          format += "B" #Application Software Minor Version
          format += "B" #Application Software Beta Version
          format += "H" #Lens focus position
          format += " 40s " # Detector Name
          format += "H" # Product Number
          format += "B" # Bits per coordinate
          format += "B" #Detector Energy Capability
          format += "B" #Detector Timing Capability
          format += "H" #AD Clock Frequency
          format += "B" #Firmware Major Version
          format += "B" #Firmware Minor Version
          format += "B" #Firmware Beta Version
          format += "H" #Serial Number
          format += "B" #Acquisition Mode
          format += "I" #Acquisition Mode Capability
          format += "B" #Shutter State
          format += "H" #PAPA PMT power supply voltage command
          format += "H" #PAPA PMT power supply voltage gain
          format += "H" #PAPA PMT power supply voltage command offset
          format += "H" #PAPA PMT power supply control voltage command gain
          format += "H" #PAPA PMT power supply control voltage command offsert
          format += "B" #PAPA PMT power supply voltage enable
  
          format += "H" #Energy PMT power supply voltage command
          format += "H" #Energy PMT power supply voltage gain
          format += "H" #Energy PMT power supply voltage command offset
          format += "H" #Energy PMT power supply control voltage command gain
          format += "H" #Energy PMT power supply control voltage command offsert
          format += "B" #Energy PMT power supply voltage enable
          format += "H" #Intensifier MCP power supply voltage command
          format += "H" #Intensifier MCP power supply voltage gain
          format += "H" #Intensifier MCP power supply voltage command offset
          format += "H" #Intensifier MCP power supply control voltage command gain
          format += "H" #Intensifier MCP power supply control voltage command offsert
          format += "B" #Intensifier MCP power supply voltage enable
          format += " 10H " #X Channel gains
          format += " 10H " #Y Channel gains
          format += "H" #Strobe PMT Channel Gain
          format += "H" #Energy PMT Channel Gain
          format += "H" #Threshold Channel Gain
          format += "H" #AD Voltage Offset
          format += "H" #AD Channel A Offset
          format += "H" #AD Channel B Offset
          format += "H" #AD Channel C Offset
          format += "H" #AD Channel D Offset
          format += "H" #PAPA Strobe Trigger min
          format += "H" #PAPA Strobe Trigger max
          format += "H" #PAPA Strobe end event fraction
          format += "H" #Energy Trigger min
          format += "H" #Energy Trigger max
          format += "H" #Energy end event fraction
          format += "B" #AD A filter sample interval length
          format += "B" #AD D filter sample interval length
          format += "B" #Gate Capture Polarity
          format += "B" #Timer reset edge Polarity
          format += "H" #Coincidence lead timer
          format += "H" #Coincidence lag timer
          format += "B" #Gray to binary conversion adder
          format += "B" #Binary big shift
          format += " 2H " #Zone temperature set point
          format += " 2H " #Zone KP Gain
          format += " 2H " #Zone KI Gain
          format += " 2H " #Zone KD Gain
          format += " 2H " #Zone temperature
          format += "H" #strobe pulse width
          format += "39x" #unused
          format += "H" #Year
          format += "H" #Month
          format += "H" #Day
          format += "H" #Hour
          format += "H" #Minute
          format += "H" #Second
          header = Header._make(struct.unpack(format,bytes))
          return header
  
#+end_src

#+RESULTS: reader_pelfile_parseHeader
: None

